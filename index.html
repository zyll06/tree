<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>åœ£è¯æ ‘</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background-color: #000;
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
        }
        canvas {
            display: block;
        }
        
        /* ğŸ•’ åŠ¨ç”»é˜¶æ®µè®¡æ—¶å™¨æ ·å¼ */
        
        /* å¯åŠ¨ç•Œé¢æ ·å¼ */
        #start {
            position: fixed;
            inset: 0;
            background: transparent;
            color: white;
            font-size: 28px;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            z-index: 9999;
            text-shadow: 0 0 10px rgba(255, 255, 255, 0.8);
        }
    </style>
</head>
<body>

    <!-- å¯åŠ¨ç•Œé¢ (åˆå§‹éšè—ï¼ŒèƒŒæ™¯åŠ è½½å®Œæˆåæ˜¾ç¤º) -->
    <div id="start" style="display: none;">ç‚¹å‡»è¿›å…¥ ğŸ„</div>

    <!-- éŸ³é¢‘å…ƒç´  - è‡ªåŠ¨å¾ªç¯æ’­æ”¾ï¼Œä¸æ˜¾ç¤º -->
    <audio id="christmasAudio" loop preload="auto" style="display: none;">
        <source src="tree.mp3" type="audio/mpeg">
        æ‚¨çš„æµè§ˆå™¨ä¸æ”¯æŒéŸ³é¢‘å…ƒç´ ã€‚
    </audio>

    
    <script src="three.min.js"></script>
    <script>
        // Three.jså¯¹è±¡å·¥å‚å‡½æ•° - å‡å°‘é‡å¤çš„new THREEè°ƒç”¨ï¼ˆéœ€è¦åœ¨CONFIGä¹‹å‰å®šä¹‰ï¼‰
        const ThreeFactory = {
            // åˆ›å»ºVector3å¯¹è±¡çš„å¿«æ·æ–¹æ³•
            Vector3: (x = 0, y = 0, z = 0) => new THREE.Vector3(x, y, z),
            
            // åˆ›å»ºColorå¯¹è±¡çš„å¿«æ·æ–¹æ³•  
            Color: (color) => new THREE.Color(color),
            
            // åˆ›å»ºBufferAttributeçš„å¿«æ·æ–¹æ³•
            BufferAttribute: (array, itemSize) => new THREE.BufferAttribute(array, itemSize),
            
            // åˆ›å»ºç‚¹å…‰æºçš„å¿«æ·æ–¹æ³•
            PointLight: (color, intensity, distance) => new THREE.PointLight(color, intensity, distance),
            
            // åˆ›å»ºCanvasTextureçš„å¿«æ·æ–¹æ³•
            CanvasTexture: (canvas) => new THREE.CanvasTexture(canvas)
        };

        // å¸¸é‡å®šä¹‰ï¼šå®šä¹‰æ‰€æœ‰ç³»ç»Ÿå‚æ•°é…ç½®
        const CONFIG = { // åˆ›å»ºå…¨å±€é…ç½®å¯¹è±¡
            // é›ªèŠ±ç³»ç»Ÿé…ç½® - â„ï¸ æ§åˆ¶é›ªèŠ±çš„åŸºæœ¬ç‰©ç†å±æ€§
            SNOW: { // é›ªèŠ±ç›¸å…³å‚æ•°
                COUNT: 3500, //  æ§åˆ¶é›ªèŠ±çš„å¯†åº¦
                MAX_HEIGHT: 30, // é›ªèŠ±æœ€å¤§é«˜åº¦(20-50) - é›ªèŠ±èµ·å§‹é«˜åº¦
                MIN_HEIGHT: -5, // é›ªèŠ±æœ€å°é«˜åº¦(-10-5) - é›ªèŠ±æ¶ˆå¤±é‡æ–°ç”Ÿæˆçš„ä½ç½®
                RANGE: 40, // é›ªèŠ±åˆ†å¸ƒèŒƒå›´(20-80) - é›ªèŠ±åœ¨Xå’ŒZè½´çš„åˆ†å¸ƒåŒºåŸŸ
                           // 20: åˆ†å¸ƒé›†ä¸­ï¼Œé›ªèŠ±åŒºåŸŸå°
                           // 40: é€‚ä¸­åˆ†å¸ƒï¼Œè¦†ç›–ä¸»è¦åŒºåŸŸ(âœ¨æ¨è)
                           // 80: åˆ†å¸ƒå¹¿æ³›ï¼Œè¦†ç›–æ•´ä¸ªåœºæ™¯
                WIND_DIRECTION: ThreeFactory.Vector3(-0.015, 0, 0.008), // é£çš„æ–¹å‘å‘é‡(-0.05-0.05) - æ§åˆ¶é›ªèŠ±çš„é£˜å‘
                                                                                    // Xè´Ÿå€¼: å‘å·¦é£˜ï¼Œæ­£å€¼: å‘å³é£˜
                                                                                    // Zè´Ÿå€¼: å‘åé£˜ï¼Œæ­£å€¼: å‘å‰é£˜
                BASE_SPEED: 0.01, // é›ªèŠ±åŸºç¡€ä¸‹è½é€Ÿåº¦(0.02-0.15) - æ§åˆ¶æ•´ä½“ä¸‹è½å¿«æ…¢
                                  // 0.02: ææ…¢ä¸‹è½ï¼Œåƒç©ºä¸­æ‚¬æµ®
                                  // 0.055: é€‚ä¸­é€Ÿåº¦ï¼Œè‡ªç„¶é£˜è½æ„Ÿ(âœ¨æ¨è)
                                  // 0.15: å¿«é€Ÿä¸‹è½ï¼Œåƒæš´é£é›ª
                SPEED_VARIANCE: 0.11 // é€Ÿåº¦å˜åŒ–èŒƒå›´(0.05-0.3) - é›ªèŠ±é€Ÿåº¦çš„éšæœºå·®å¼‚
                                    // 0.05: é€Ÿåº¦ç»Ÿä¸€ï¼Œæœºæ¢°æ„Ÿå¼º
                                    // 0.12: é€‚ä¸­å·®å¼‚ï¼Œè‡ªç„¶é£˜è½(âœ¨æ¨è)
                                    // 0.3: é€Ÿåº¦å·®å¼‚å¤§ï¼Œæ··ä¹±æ„Ÿå¼º
            }, // SNOWé…ç½®ç»“æŸ
            // æ ‘ç³»ç»Ÿé…ç½® - ğŸ„ æ§åˆ¶åœ£è¯æ ‘çš„å¤–è§‚å’ŒåŠ¨ç”»æ•ˆæœ
            TREE: { // åœ£è¯æ ‘ç›¸å…³å‚æ•°
                PARTICLE_COUNT: 13000, // æ ‘çš„æ€»ç²’å­æ•°é‡(5000-20000) - æ§åˆ¶æ ‘çš„å¯†åº¦å’Œè´¨é‡
                TRUNK_RATIO: 0.15, // æ ‘å¹²ç²’å­æ¯”ä¾‹(0.1-0.3) - æ§åˆ¶æ ‘å¹²çš„ç²—ç»†ç¨‹åº¦
                TRUNK_HEIGHT: 2, // æ ‘å¹²é«˜åº¦(1-4) - æ§åˆ¶æ ‘å¹²çš„å‚ç›´é•¿åº¦
                TRUNK_BASE_RADIUS: 0.6, // æ ‘å¹²åº•éƒ¨åŠå¾„(0.3-1.0) - æ ‘å¹²åº•éƒ¨ç²—ç»†
                TRUNK_TOP_RADIUS: 0.2, // æ ‘å¹²é¡¶éƒ¨åŠå¾„(0.05-0.4) - æ ‘å¹²é¡¶éƒ¨ç²—ç»†
                LEAF_HEIGHT_RANGE: 10, // æ ‘å¶é«˜åº¦èŒƒå›´(5-15) - æ§åˆ¶æ ‘å† çš„å‚ç›´è·¨åº¦
                LEAF_BASE_HEIGHT: 1, // æ ‘å¶èµ·å§‹é«˜åº¦(0-2) - æ ‘å¶ä»å¤šé«˜å¼€å§‹ç”Ÿé•¿
                LEAF_BASE_RADIUS: 4.26, // æ ‘å¶åŸºç¡€åŠå¾„(2-8) - æ§åˆ¶æ ‘å† çš„å®½åº¦
                RIBBON_PROBABILITY: 0.15, // å½©å¸¦ç²’å­å‡ºç°æ¦‚ç‡(0.05-0.3) - å¢åŠ å½©å¸¦å¯†åº¦
                RIBBON_COUNT: 4, // å½©å¸¦æ•°é‡(1-6) - å¢åŠ ä¸€æ¡å½©å¸¦
                RIBBON_SPIRAL_TURNS: 4, // å½©å¸¦èºæ—‹åœˆæ•°(1-5) - å¢åŠ èºæ—‹åœˆæ•°ï¼Œä½¿å½©å¸¦æ›´ä¸°å¯Œ
                POSITION_OFFSET: ThreeFactory.Vector3(0, -7, 0), // æ ‘çš„ä½ç½®åç§»å‘é‡(X:-5-5, Y:-10-0, Z:-5-5) - æ§åˆ¶æ ‘åœ¨åœºæ™¯ä¸­çš„ä½ç½®
                                                                                    // Yå€¼æ§åˆ¶æ ‘çš„æ•´ä½“é«˜åº¦ä½ç½®
                                                                                    // -7: é€‚ä¸­ä½ç½®ï¼Œæ ‘åº•éƒ¨æ¥è¿‘åœ°é¢(âœ¨æ¨è)
                SCALE: ThreeFactory.Vector3(2, 2.2, 2), // æ ‘çš„ç¼©æ”¾æ¯”ä¾‹(0.5-3.0) - æ§åˆ¶æ ‘çš„æ•´ä½“å¤§å°
                TILT_X: THREE.MathUtils.degToRad(-24), // Xè½´å€¾æ–œè§’åº¦(-60Â°-60Â°) - æ ‘çš„å‰åå€¾æ–œç¨‹åº¦
                BATCH_SIZE: 600, // æ¯æ‰¹å¤„ç†çš„ç²’å­æ•°é‡(300-1200) - æ§åˆ¶æ˜Ÿå½¢çš„ç²’å­å¯†åº¦
                                  // 300: å°æ‰¹ï¼Œæ˜Ÿå½¢æ›´ç²¾ç»†ä½†æ‰¹æ¬¡æ›´å¤š
                                  // 600: é€‚ä¸­æ‰¹æ¬¡ï¼Œå¹³è¡¡æ•ˆæœ(âœ¨æ¨è)
                                  // 1200: å¤§æ‰¹ï¼Œæ˜Ÿå½¢è¾ƒç²—ä½†è¿‡æ¸¡æ›´å¿«
            }, 
            // ç›¸æœºé…ç½® - ğŸ“· æ§åˆ¶è§‚å¯Ÿè§†è§’å’Œé€è§†æ•ˆæœ
            CAMERA: { // ç›¸æœºç›¸å…³å‚æ•°
                FOV: 65, // è§†åœºè§’åº¦(30-120åº¦) - æ§åˆ¶è§†é‡å®½åº¦
                         // 30: çª„è§†é‡ï¼Œæœ›è¿œæ•ˆæœï¼Œæ ‘æ˜¾å¾—æ›´å¤§
                         // 65: é€‚ä¸­è§†é‡ï¼Œæ ‡å‡†è§†è§’(âœ¨æ¨è)
                         // 120: å®½è§†é‡ï¼Œå¹¿è§’æ•ˆæœï¼Œèƒ½çœ‹åˆ°æ›´å¤šåœºæ™¯
                NEAR: 0.1, // è¿‘è£å‰ªé¢è·ç¦»(0.01-1.0) - æœ€è¿‘èƒ½çœ‹åˆ°çš„è·ç¦»
                            // 0.01: æè¿‘è·ç¦»ï¼Œå¯çœ‹åˆ°å¾ˆè¿‘çš„ç‰©ä½“
                            // 0.1: é€‚ä¸­è¿‘è·ï¼Œæ ‡å‡†è®¾ç½®(âœ¨æ¨è)
                            // 1.0: è¾ƒè¿œè¿‘è·ï¼Œé¿å…è¿‘å¤„ç‰©ä½“
                FAR: 1000, // è¿œè£å‰ªé¢è·ç¦»(100-5000) - æœ€è¿œèƒ½çœ‹åˆ°çš„è·ç¦»
                            // 100: è¾ƒçŸ­è·ç¦»ï¼Œè¿œå¤„ç‰©ä½“ä¼šè¢«è£å‰ª
                            // 1000: é€‚ä¸­è·ç¦»ï¼Œæ¶µç›–æ•´ä¸ªåœºæ™¯(âœ¨æ¨è)
                            // 5000: è¶…è¿œè·ç¦»ï¼Œç¡®ä¿æ‰€æœ‰ç‰©ä½“å¯è§
                INITIAL_POSITION: ThreeFactory.Vector3(12, 7, 12), // ç›¸æœºåˆå§‹ä½ç½®(X:5-20, Y:3-15, Z:5-20) - æ§åˆ¶è§‚å¯Ÿç‚¹çš„ä½ç½®
                                                                 // X,Zå€¼æ§åˆ¶æ°´å¹³ä½ç½®ï¼ŒYå€¼æ§åˆ¶é«˜åº¦
                                                                 // (12,7,12): å³å‰æ–¹è¾ƒé«˜ä½ç½®ï¼Œä¿¯è§†è§’åº¦(âœ¨æ¨è)
                                                                 // (15,10,15): æ›´è¿œæ›´é«˜ï¼Œæ›´å¹¿è§†è§’
                                                                 // (8,5,8): æ›´è¿‘æ›´ä½ï¼Œæ›´æ²‰æµ¸è§†è§’
                TARGET: ThreeFactory.Vector3(0, 4, 0) // ç›¸æœºè§‚å¯Ÿç›®æ ‡ç‚¹(X:-5-5, Y:0-10, Z:-5-5) - æ§åˆ¶ç›¸æœºçœ‹å‘å“ªé‡Œ
                                                     // Yå€¼æ§åˆ¶è§‚å¯Ÿç‚¹çš„å‚ç›´ä½ç½®
                                                     // (0,4,0): çœ‹å‘æ ‘çš„ä¸­éƒ¨(âœ¨æ¨è)
                                                     // (0,7,0): çœ‹å‘æ ‘çš„ä¸Šéƒ¨
                                                     // (0,1,0): çœ‹å‘æ ‘çš„ä¸‹éƒ¨
            }, // CAMERAé…ç½®ç»“æŸ
            // ç¯å…‰é…ç½® - ğŸ’¡ æ§åˆ¶è£…é¥°ç¯çš„é¢œè‰²å’Œé—ªçƒæ•ˆæœ
            LIGHTS: [ // è£…é¥°ç¯å…‰é…ç½®æ•°ç»„ - å¯å¢å‡ç¯å…‰æ•°é‡å’Œè°ƒæ•´å‚æ•°
                { 
                    color: 0xff0000, // çº¢è‰²ç¯å…‰(0xff0000) - åœ£è¯ç»å…¸é¢œè‰²
                    intensity: 0.8,   // å¼ºåº¦(0.2-2.0) - æ§åˆ¶äº®åº¦
                                       // 0.2: å¾®å¼±ç¯å…‰ï¼Œç‚¹ç¼€æ•ˆæœ
                                       // 0.8: é€‚ä¸­äº®åº¦ï¼Œæ¸©æš–æ°›å›´(âœ¨æ¨è)
                                       // 2.0: å¼ºçƒˆç¯å…‰ï¼Œè§†è§‰å†²å‡»åŠ›å¼º
                    distance: 5,      // å½±å“è·ç¦»(2-10) - å…‰ç…§èŒƒå›´
                                       // 2: å°èŒƒå›´ï¼Œå±€éƒ¨ç…§æ˜
                                       // 5: é€‚ä¸­èŒƒå›´ï¼Œç…§äº®å‘¨å›´(âœ¨æ¨è)
                                       // 10: å¤§èŒƒå›´ï¼Œå¹¿åŸŸç…§æ˜
                    flickerSpeed: 1.0 // é—ªçƒé¢‘ç‡(0.2-3.0) - æ§åˆ¶é—ªçƒå¿«æ…¢
                                       // 0.2: ç¼“æ…¢é—ªçƒï¼Œå¹³é™æ•ˆæœ
                                       // 1.0: é€‚ä¸­é—ªçƒï¼Œæ´»æ³¼æ„Ÿ(âœ¨æ¨è)
                                       // 3.0: å¿«é€Ÿé—ªçƒï¼ŒåŠ¨æ„Ÿå¼ºçƒˆ
                },  
                { 
                    color: 0x00ff00, // ç»¿è‰²ç¯å…‰ - è‡ªç„¶è‰²å½©
                    intensity: 0.6,   // è¾ƒä½å¼ºåº¦ï¼Œä¸çº¢è‰²å¹³è¡¡
                    distance: 4,      // ä¸­ç­‰èŒƒå›´
                    flickerSpeed: 1.2 // ç¨å¿«é—ªçƒ
                },  
                { 
                    color: 0x0000ff, // è“è‰²ç¯å…‰ - å†·è‰²è°ƒ
                    intensity: 0.7,   // ä¸­ç­‰å¼ºåº¦
                    distance: 4.5,    // ç¨å¤§èŒƒå›´
                    flickerSpeed: 2.0 // å¿«é€Ÿé—ªçƒï¼Œå¢åŠ æ´»åŠ›
                },   
                { 
                    color: 0xffff00, // é»„è‰²ç¯å…‰ - æ¸©æš–è‰²è°ƒ
                    intensity: 0.9,   // è¾ƒé«˜å¼ºåº¦ï¼Œçªå‡ºæ„Ÿ
                    distance: 5.5,    // å¤§èŒƒå›´ç…§æ˜
                    flickerSpeed: 1.5 // ä¸­ç­‰é€Ÿåº¦é—ªçƒ
                }
            ], // LIGHTSé…ç½®ç»“æŸ
            // é¢œè‰²é…ç½®
            COLORS: { // é¢œè‰²ç›¸å…³å‚æ•°
                TREE: [ // æ ‘çš„é¢œè‰²æ•°ç»„ - å¢å¼ºäº®åº¦ç‰ˆæœ¬
                    ThreeFactory.Color(0x00AA00),  // äº®ç»¿è‰²ï¼ˆæ ‘ä¸»ä½“ï¼‰(âœ¨å·²è°ƒäº®)
                    ThreeFactory.Color(0x008800),  // æ·±ç»¿è‰²ï¼ˆæ ‘ä¸»ä½“ï¼‰(âœ¨å·²è°ƒäº®)
                    ThreeFactory.Color(0x00CC33),  // äº®å†·ç»¿è‰²ï¼ˆæ ‘ä¸»ä½“ï¼‰(âœ¨å·²è°ƒäº®)
                    ThreeFactory.Color(0x007733),  // å†·ç»¿è‰²ï¼ˆæ ‘ä¸»ä½“ï¼‰(âœ¨å·²è°ƒäº®)
                    ThreeFactory.Color(0xff3333),  // äº®çº¢è‰²ï¼ˆè£…é¥°ï¼‰(âœ¨å·²è°ƒäº®)
                    ThreeFactory.Color(0xffdd33),  // äº®é‡‘è‰²ï¼ˆè£…é¥°ï¼‰(âœ¨å·²è°ƒäº®)
                    ThreeFactory.Color(0x3333ff),  // äº®è“è‰²ï¼ˆè£…é¥°ï¼‰(âœ¨å·²è°ƒäº®)
                    ThreeFactory.Color(0xffffdd),  // äº®æ·¡é»„è‰²ï¼ˆé«˜å…‰ï¼‰(âœ¨å·²è°ƒäº®)
                    ThreeFactory.Color(0xffffff),  // ç™½è‰²ï¼ˆé«˜å…‰ï¼‰
                    ThreeFactory.Color(0x7D5A20)   // äº®æ£•è‰²ï¼ˆæ ‘å¹²ï¼‰(âœ¨å·²è°ƒäº®)
                ], // TREEé¢œè‰²æ•°ç»„ç»“æŸ
                RIBBON: [4, 5, 6]  // å½©å¸¦ä½¿ç”¨çš„é¢œè‰²ç´¢å¼•ï¼ˆå¯¹åº”TREEæ•°ç»„ä¸­çš„é¢œè‰²ï¼‰
            }, // COLORSé…ç½®ç»“æŸ
            // åŠ¨ç”»é…ç½®
            ANIMATION: { // åŠ¨ç”»ç›¸å…³å‚æ•°
                PULSE_SPEED: 2.0, // è„‰å†²åŠ¨ç”»é€Ÿåº¦
                PULSE_AMOUNT: 0.1, // è„‰å†²åŠ¨ç”»å¹…åº¦
                DECORATION_FLICKER_SPEED: 5.0, // è£…é¥°ç¯é—ªçƒé€Ÿåº¦
            }, // ANIMATIONé…ç½®ç»“æŸ
            
            // ç²’å­äº®åº¦å¸¸é‡ - ğŸ¨ è°ƒæ•´è¿™äº›å€¼å¯ä»¥æ”¹å˜æ•´ä½“çš„æ˜æš—æ•ˆæœ
            BRIGHTNESS: {
                TRUNK_SHADOW_BASE: 1.2,        // ğŸŒ² æ ‘å¹²åŸºç¡€é˜´å½±å› å­(0.8-1.5) - æ§åˆ¶æ ‘å¹²æ•´ä½“äº®åº¦
                                              // 0.8: è¾ƒæš—æ ‘å¹²ï¼Œæ˜¾å¾—æ²‰ç¨³
                                              // 1.0: æ­£å¸¸äº®åº¦ï¼Œè‡ªç„¶æ•ˆæœ
                                              // 1.2: æ˜äº®æ ‘å¹²ï¼Œçªå‡ºå­˜åœ¨æ„Ÿ(âœ¨å·²è°ƒäº®)
                TRUNK_SHADOW_HEIGHT_FACTOR: 0.8, // ğŸ“ æ ‘å¹²é«˜åº¦é˜´å½±æ¸å˜å¼ºåº¦(0.0-0.3) - æ§åˆ¶æ ‘å¹²ä¸Šä¸‹äº®åº¦å·®å¼‚
                                                   // 0.0: æ— æ¸å˜ï¼Œä¸Šä¸‹äº®åº¦ä¸€è‡´
                                                   // 0.15: è½»å¾®æ¸å˜ï¼Œé¡¶éƒ¨ç•¥äº®
                                                   // 0.8: æ˜æ˜¾æ¸å˜ï¼Œé¡¶éƒ¨æ›´äº®(âœ¨å·²å¢å¼º)
                RIBBON_BRIGHTNESS_MULTIPLIER: 1.4, // ğŸ€ å½©å¸¦äº®åº¦å€æ•°(1.0-1.5) - æ§åˆ¶å½©å¸¦çš„çªå‡ºç¨‹åº¦
                                                        // 1.0: ä¸å…¶ä»–ç²’å­åŒäº®åº¦ï¼Œèå…¥æ•´ä½“
                                                        // 1.3: ç¨äº®ï¼Œè£…é¥°æ„Ÿæ˜æ˜¾
                                                        // 1.4: è¾ƒäº®ï¼Œå½©å¸¦æ›´åŠ çªå‡º(âœ¨æ¨è)
                SPARKLE_BASE_INITIAL: 2.0,       // âœ¨ åˆå§‹é—ªè€€åŸºç¡€äº®åº¦(0.5-1.5) - æ˜Ÿå½¢é˜¶æ®µçš„åŸºç¡€æ˜åº¦
                                                   // 0.5: æš—æ·¡æ˜Ÿå½¢ï¼Œä½è°ƒæ•ˆæœ
                                                   // 1.15: é€‚ä¸­äº®åº¦ï¼Œæ˜Ÿå½¢æ¸…æ™°
                                                   // 1.5: æ˜äº®æ˜Ÿå½¢ï¼Œè§†è§‰å†²å‡»å¼º
                                                   // 2.0: é«˜äº®åº¦æ˜Ÿå½¢ï¼Œé—ªçƒæ•ˆæœæ›´æ˜æ˜¾(âœ¨æ¨è)
                SPARKLE_AMPLITUDE_INITIAL: 1.0,   // ğŸŒŸ åˆå§‹é—ªè€€å¹…åº¦(0.1-1.5) - æ˜Ÿå½¢é—ªçƒçš„å˜åŒ–å¼ºåº¦
                                                   // 0.1: è½»å¾®é—ªçƒï¼Œç¨³å®šæ„Ÿ
                                                   // 0.7: æ˜æ˜¾é—ªçƒï¼Œæ´»æ³¼æ„Ÿ
                                                   // 0.8: å‰§çƒˆé—ªçƒï¼ŒåŠ¨æ„Ÿå¼ºçƒˆ
                                                   // 1.0: é«˜å¹…åº¦é—ªçƒï¼Œé¢‘é—ªæ•ˆæœ(âœ¨æ¨è)
                SPARKLE_BASE_FINAL: 1.2,          // ï¿½ æœ€ç»ˆé—ªè€€åŸºç¡€äº®åº¦(0.7-1.2) - æˆæ ‘åçš„åŸºç¡€æ˜åº¦
                                                   // 0.7: è¾ƒæš—æ•ˆæœï¼Œæ²‰ç¨³æ„Ÿ
                                                   // 1.15: é€‚ä¸­äº®åº¦ï¼Œè‡ªç„¶æ•ˆæœ(âœ¨æ¨è)
                                                   // 1.2: æ˜äº®æ•ˆæœï¼Œæ´»åŠ›æ„Ÿå¼º
                SPARKLE_AMPLITUDE_FINAL: 0.2,     // ğŸŠ æœ€ç»ˆé—ªè€€å¹…åº¦(0.05-0.3) - æˆæ ‘åçš„é—ªçƒå¼ºåº¦
                SPARKLE_FREQUENCY_INITIAL: 4.0,    // âœ¨ åˆå§‹é—ªçƒé¢‘ç‡(2.0-20.0) - æ˜Ÿå½¢é˜¶æ®µé—ªçƒå¿«æ…¢
                SPARKLE_FREQUENCY_FINAL: 3.0,      // âœ¨ æœ€ç»ˆé—ªçƒé¢‘ç‡(1.0-6.0) - æˆæ ‘åé—ªçƒå¿«æ…¢
                SPARKLE_AMPLITUDE_INITIAL: 0.3,      // ğŸŒŸ åˆå§‹é—ªçƒå¹…åº¦(0.1-0.8) - æ˜Ÿå½¢é˜¶æ®µé—ªçƒå˜åŒ–å¼ºåº¦
                BACKGROUND_OVERLAY_ALPHA: 0.1,       // ğŸŒƒ èƒŒæ™¯æš—åŒ–è¦†ç›–å±‚é€æ˜åº¦(0.0-0.5) - æ§åˆ¶èƒŒæ™¯çš„æš—åŒ–ç¨‹åº¦
                                                     // 0.0: æ— æš—åŒ–ï¼Œä¿æŒåŸèƒŒæ™¯äº®åº¦
                                                     // 0.3: é€‚ä¸­æš—åŒ–ï¼Œçªå‡ºå‰æ™¯(âœ¨æ¨è)
                                                     // 0.5: å¼ºçƒˆæš—åŒ–ï¼ŒèƒŒæ™¯å¾ˆæš—
                BACKGROUND_MULTIPLY_ALPHA: 0.7       // ğŸŒŒ èƒŒæ™¯æš—åŒ–ä¹˜æ³•é€æ˜åº¦(0.3-0.9) - æ§åˆ¶èƒŒæ™¯å¯¹æ¯”åº¦
                                                     // 0.3: è½»å¾®è°ƒæš—ï¼Œä¿æŒåŸè‰²
                                                     // 0.7: é€‚ä¸­è°ƒæš—ï¼Œå¯¹æ¯”åº¦å¥½(âœ¨æ¨è)
                                                     // 0.9: å¼ºçƒˆè°ƒæš—ï¼Œå¯¹æ¯”åº¦å¾ˆå¼º
            },
            
            // ç²’å­å°ºå¯¸å¸¸é‡ - ğŸ“ è°ƒæ•´è¿™äº›å€¼å¯ä»¥æ”¹å˜ç²’å­çš„å¤§å°å’Œåˆ†å¸ƒ
            SIZES: {
                TRUNK_BASE: 2.5,              // ğŸŒ² æ ‘å¹²åŸºç¡€å¤§å°(1.0-4.0) - æ§åˆ¶æ ‘å¹²ç²’å­çš„åŸºç¡€å°ºå¯¸
                                              // 1.0: å°æ ‘å¹²ï¼Œçº¤ç»†é€ å‹
                                              // 2.5: é€‚ä¸­å¤§å°ï¼Œæ¯”ä¾‹åè°ƒ(âœ¨æ¨è)
                                              // 4.0: å¤§æ ‘å¹²ï¼Œç²—å£®é€ å‹
                TRUNK_VARIANCE: 3.5,          // ğŸ“ æ ‘å¹²å¤§å°å˜åŒ–èŒƒå›´(1.0-5.0) - æ ‘å¹²å°ºå¯¸çš„éšæœºå·®å¼‚
                                              // 1.0: å˜åŒ–å°ï¼Œæ ‘å¹²å‡åŒ€
                                              // 3.5: é€‚ä¸­å˜åŒ–ï¼Œè‡ªç„¶çº¹ç†(âœ¨æ¨è)
                                              // 5.0: å˜åŒ–å¤§ï¼Œçº¹ç†ä¸°å¯Œ
                LEAF_BASE: 1.8,               // ğŸƒ æ ‘å¶åŸºç¡€å¤§å°(1.0-3.0) - æ§åˆ¶æ ‘å¶ç²’å­çš„åŸºç¡€å°ºå¯¸
                                              // 1.0: å°å¶å­ï¼Œç²¾ç»†æ„Ÿ
                                              // 1.8: é€‚ä¸­å¤§å°ï¼Œè‡ªç„¶æ•ˆæœ(âœ¨æ¨è)
                                              // 3.0: å¤§å¶å­ï¼ŒèŒ‚å¯†æ„Ÿå¼º
                LEAF_VARIANCE: 3.5,           // ğŸŒ¿ æ ‘å¶å¤§å°å˜åŒ–èŒƒå›´(1.0-5.0) - æ ‘å¶å°ºå¯¸çš„éšæœºå·®å¼‚
                                              // 1.0: å˜åŒ–å°ï¼Œå¶å­å‡åŒ€
                                              // 3.5: é€‚ä¸­å˜åŒ–ï¼Œè‡ªç„¶å±‚æ¬¡(âœ¨æ¨è)
                                              // 5.0: å˜åŒ–å¤§ï¼Œå±‚æ¬¡ä¸°å¯Œ
                RIBBON_MULTIPLIER: 2.2,        // ğŸ€ å½©å¸¦å°ºå¯¸å€æ•°(1.5-3.0) - å½©å¸¦ç›¸å¯¹æ™®é€šç²’å­çš„å¤§å°
                                              // 1.5: ç¨å¤§å½©å¸¦ï¼Œè½»å¾®çªå‡º
                                              // 2.0: é€‚ä¸­å¤§å°ï¼Œè£…é¥°æ•ˆæœå¥½
                                              // 2.2: è¾ƒå¤§å½©å¸¦ï¼Œè£…é¥°æ„Ÿæ›´å¼ºçƒˆ(âœ¨æ¨è)
                TOP_SIZE_FACTOR: 0.9,           // ğŸ„ æ ‘é¡¶éƒ¨ç²’å­å°ºå¯¸å› å­(0.7-1.2) - æ ‘é¡¶éƒ¨ç²’å­å¤§å°è°ƒæ•´
                                              // 0.7: å°é¡¶éƒ¨ï¼Œå°–é”¥é€ å‹
                                              // 0.9: é€‚ä¸­é¡¶éƒ¨ï¼Œè‡ªç„¶é”¥å½¢(âœ¨æ¨è)
                                              // 1.2: å¤§é¡¶éƒ¨ï¼Œå¹³é¡¶é€ å‹
                NORMAL_SIZE_FACTOR: 1.1,         // ğŸŒ² æ™®é€šç²’å­å°ºå¯¸å› å­(0.8-1.5) - æ ‘èº«ç²’å­å¤§å°è°ƒæ•´
                                              // 0.8: å°ç²’å­ï¼Œç²¾è‡´æ„Ÿ
                                              // 1.1: é€‚ä¸­ç²’å­ï¼Œå¹³è¡¡æ•ˆæœ(âœ¨æ¨è)
                                              // 1.5: å¤§ç²’å­ï¼Œé¥±æ»¡æ„Ÿå¼º
                SIZE_VARIANCE_BASE: 0.95,        // ğŸ² å°ºå¯¸éšæœºå˜åŒ–åŸºç¡€(0.8-1.2) - ç²’å­å°ºå¯¸éšæœºçš„åŸºç¡€å€¼
                                              // 0.8: åå°åŸºç¡€ï¼Œæ•´ä½“ç²¾è‡´
                                              // 0.95: æ ‡å‡†åŸºç¡€ï¼Œè‡ªç„¶æ•ˆæœ(âœ¨æ¨è)
                                              // 1.2: åå¤§åŸºç¡€ï¼Œæ•´ä½“é¥±æ»¡
                SIZE_VARIANCE_RANGE: 0.25        // ğŸ° å°ºå¯¸éšæœºå˜åŒ–èŒƒå›´(0.1-0.5) - ç²’å­å°ºå¯¸éšæœºçš„å˜åŒ–å¹…åº¦
                                              // 0.1: å˜åŒ–å°ï¼Œç²’å­å¤§å°å‡åŒ€
                                              // 0.25: é€‚ä¸­å˜åŒ–ï¼Œè‡ªç„¶å¤šæ ·æ€§(âœ¨æ¨è)
                                              // 0.5: å˜åŒ–å¤§ï¼Œç²’å­å¤§å°å·®å¼‚æ˜æ˜¾
            },
            
            // ç³»ç»Ÿæ—¶åºå¸¸é‡ - â±ï¸ è°ƒæ•´è¿™äº›å€¼å¯ä»¥æ”¹å˜åŠ¨ç”»çš„æ—¶é—´èŠ‚å¥
            TIMING: {
                PARTICLE_INIT_DELAY: 500,       // â±ï¸ ç²’å­ç³»ç»Ÿåˆå§‹åŒ–å»¶è¿Ÿ(100-2000) - é¡µé¢åŠ è½½åå¤šä¹…æ˜¾ç¤ºç²’å­(ms)
                                                    // 100: ç«‹å³æ˜¾ç¤ºï¼Œæ— å»¶è¿Ÿ
                                                    // 500: é€‚ä¸­å»¶è¿Ÿï¼Œè®©ç”¨æˆ·å…ˆçœ‹åˆ°èƒŒæ™¯(âœ¨æ¨è)
                                                    // 2000: é•¿å»¶è¿Ÿï¼Œè¥é€ æœŸå¾…æ„Ÿ
                BACKGROUND_RENDER_DELAY: 100,     // ğŸ–¼ï¸ èƒŒæ™¯æ¸²æŸ“å»¶è¿Ÿ(50-500) - èƒŒæ™¯å›¾ç‰‡æ¸²æŸ“å»¶è¿Ÿ(ms)
                                                    // 50: å¿«é€Ÿæ˜¾ç¤ºï¼Œæ— ç¼“å†²
                                                    // 100: é€‚ä¸­å»¶è¿Ÿï¼Œç¡®ä¿èƒŒæ™¯ç¨³å®š(âœ¨æ¨è)
                                                    // 500: é•¿å»¶è¿Ÿï¼Œç»™ç²’å­ç³»ç»Ÿå‡†å¤‡æ—¶é—´
                APPEAR_DURATION: 700,            // ğŸ‘ï¸ ç²’å­å‡ºç°æŒç»­æ—¶é—´(200-1000) - å•æ‰¹ç²’å­æ¸æ˜¾æ—¶é—´(ms)
                                                    // 200: å¿«é€Ÿå‡ºç°ï¼Œçªç„¶æ„Ÿ
                                                    // 700: é€‚ä¸­é€Ÿåº¦ï¼Œä¼˜é›…æ˜¾ç°(âœ¨æ¨è)
                                                    // 1000: ç¼“æ…¢å‡ºç°ï¼Œæ¸è¿›æ„Ÿå¼º
                SNOW_FADE_IN_DURATION: 500,     // â„ï¸ é›ªèŠ±æ·¡å…¥æŒç»­æ—¶é—´(200-1000) - é›ªèŠ±æ¸æ˜¾æ—¶é—´(ms)
                                                    // 200: å¿«é€Ÿæ·¡å…¥ï¼Œå³æ—¶æ•ˆæœ
                                                    // 500: é€‚ä¸­æ·¡å…¥ï¼Œè‡ªç„¶è¿‡æ¸¡(âœ¨æ¨è)
                                                    // 1000: ç¼“æ…¢æ·¡å…¥ï¼Œè½»æŸ”æ•ˆæœ
                FADE_IN_PROGRESS_CLAMP: 1.0,     // ğŸ¯ æ·¡å…¥è¿›åº¦æœ€å¤§å€¼(0.8-1.0) - æ·¡å…¥å®Œæˆçš„é˜ˆå€¼
                                                    // 0.8: æå‰å®Œæˆï¼Œæ›´å¿«è¿›å…¥ä¸‹ä¸€é˜¶æ®µ
                                                    // 1.0: å®Œå…¨å®Œæˆåè¿›å…¥ä¸‹ä¸€é˜¶æ®µ(âœ¨æ¨è)
                SNOW_OPACITY_TARGET: 0.95         // ğŸ’¨ é›ªèŠ±æœ€ç»ˆé€æ˜åº¦(0.3-1.0) - é›ªèŠ±å®Œå…¨ä¸é€æ˜æ—¶çš„é€æ˜åº¦
                                                    // 0.3: å¾ˆé€æ˜ï¼Œè½»æŸ”é›ªèŠ±
                                                    // 0.8: é€‚ä¸­é€æ˜åº¦ï¼Œè‡ªç„¶æ•ˆæœ
                                                    // 0.95: é«˜é€æ˜åº¦ï¼Œå¢å¼ºé›ªèŠ±äº®åº¦(âœ¨å·²è°ƒæ•´)
            },
            
            // é›ªèŠ±åŠ¨ç”»å¸¸é‡ - â„ï¸ è°ƒæ•´è¿™äº›å€¼å¯ä»¥æ”¹å˜é›ªèŠ±çš„åŠ¨æ€æ•ˆæœ
            SNOW_ANIMATION: {
                FALL_SPEED_FACTOR: 0.37,          // â¬‡ï¸ é›ªèŠ±ä¸‹è½é€Ÿåº¦å› å­(0.2-1.0) - é›ªèŠ±ä¸‹è½é€Ÿåº¦ï¼Œè¶Šå°è¶Šæ…¢
                WIND_EFFECT_FACTOR: 0.3,         // ğŸ’¨ é£æ•ˆæœå› å­(0.1-0.8) - é£çš„æ¨ªå‘å½±å“å¼ºåº¦
                SWAY_X_FREQUENCY: 0.3,           // ğŸ”„ Xè½´æ‘‡æ‘†é¢‘ç‡(0.1-0.8) - å·¦å³æ‘‡æ‘†é€Ÿåº¦
                SWAY_X_AMPLITUDE: 0.005,         // â†”ï¸ Xè½´æ‘‡æ‘†å¹…åº¦(0.001-0.02) - å·¦å³æ‘‡æ‘†è·ç¦»
                SWAY_Z_FREQUENCY: 0.4,           // ğŸ”„ Zè½´æ‘‡æ‘†é¢‘ç‡(0.1-0.8) - å‰åæ‘‡æ‘†é€Ÿåº¦
                SWAY_Z_AMPLITUDE: 0.004,         // â†•ï¸ Zè½´æ‘‡æ‘†å¹…åº¦(0.001-0.02) - å‰åæ‘‡æ‘†è·ç¦»
                ACTIVATION_DURATION: 0.8,        // â° é›ªèŠ±æ¿€æ´»æŒç»­æ—¶é—´(0.3-2.0) - å…¨éƒ¨é›ªèŠ±æ¿€æ´»å®Œæˆæ—¶é—´(ç§’)
                OPACITY_BASE: 0.6,               // ğŸ’§ é›ªèŠ±åŸºç¡€é€æ˜åº¦(0.2-0.8) - é›ªèŠ±åŸºç¡€æ˜åº¦
                                                    // 0.2: å¾ˆé€æ˜ï¼Œè½»æŸ”æ„Ÿ
                                                    // 0.6: é€‚ä¸­é€æ˜åº¦ï¼Œè‡ªç„¶æ•ˆæœ(âœ¨æ¨è)
                                                    // 0.8: è¾ƒä¸é€æ˜ï¼Œæ˜æ˜¾æ„Ÿå¼º
                OPACITY_VARIATION: 0.2,          // ğŸŒŠ é›ªèŠ±é€æ˜åº¦å˜åŒ–å¹…åº¦(0.05-0.4) - é€æ˜åº¦å˜åŒ–èŒƒå›´
                                                    // 0.05: å˜åŒ–å°ï¼Œç¨³å®šæ„Ÿ
                                                    // 0.2: é€‚ä¸­å˜åŒ–ï¼Œç”ŸåŠ¨æ„Ÿ(âœ¨æ¨è)
                                                    // 0.4: å˜åŒ–å¤§ï¼Œé—ªçƒæ„Ÿå¼º
                OPACITY_FREQUENCY: 0.3,          // ğŸ­ é›ªèŠ±é€æ˜åº¦å˜åŒ–é¢‘ç‡(0.1-0.8) - é€æ˜åº¦å˜åŒ–é€Ÿåº¦
                                                    // 0.1: å˜åŒ–æ…¢ï¼Œç¨³å®šæ„Ÿ
                                                    // 0.3: é€‚ä¸­å˜åŒ–ï¼Œè‡ªç„¶é—ªçƒ(âœ¨æ¨è)
                                                    // 0.8: å˜åŒ–å¿«ï¼Œé—ªçƒæ˜æ˜¾
                
                // ğŸŒ¨ï¸ åˆ†æ®µå¼é€Ÿåº¦è¿‡æ¸¡å¸¸é‡ - æ…¢é€Ÿâ†’ä¸­é€Ÿâ†’æ­£å¸¸é€Ÿåº¦ï¼ˆä¼˜åŒ–å¹³ç¼“åº¦ï¼‰
            SLOW_PHASE_DURATION: 2.5,        // ğŸŒ æ…¢é€Ÿé˜¶æ®µæŒç»­æ—¶é—´(0.5-3.0ç§’) - åˆå§‹ææ…¢é£˜è½æ—¶é—´
                                                                 // 1.5ç§’: é€‚ä¸­ï¼Œæœ‰æ˜æ˜¾çš„å¼€å§‹æ…¢æ„Ÿ
                                                                 // 2.5ç§’: æ›´é•¿ï¼Œè¥é€ ç¼“ç¼“é£˜è½çš„æ„Ÿè§‰(âœ¨å·²ä¼˜åŒ–)
                                                                 // 3.0ç§’: å¾ˆé•¿ï¼Œè¥é€ ç¼“ç¼“é£˜è½çš„æ„Ÿè§‰
            MEDIUM_PHASE_DURATION: 4.0,      // ğŸš¶ ä¸­é€Ÿé˜¶æ®µæŒç»­æ—¶é—´(1.0-4.0ç§’) - ä¸­ç­‰é€Ÿåº¦é£˜è½æ—¶é—´  
                                                                 // 3.0ç§’: é€‚ä¸­ï¼Œè¿‡æ¸¡è‡ªç„¶
                                                                 // 4.0ç§’: æ¼«é•¿è¿‡æ¸¡ï¼Œä¿æŒä¸­é€Ÿæ›´ä¹…(âœ¨å·²ä¼˜åŒ–)
            INITIAL_SPEED_FACTOR: 0.03,      // ğŸŒŸ ææ…¢é€Ÿåº¦å› å­(0.02-0.1) - åˆå§‹é£˜è½é€Ÿåº¦
                                                                 // 0.02: å‡ ä¹é™æ­¢ï¼Œåƒæ‚¬æµ®åœ¨ç©ºä¸­
                                                                 // 0.03: ææ…¢é£˜è½ï¼Œæ›´è‡ªç„¶çš„å¼€å§‹(âœ¨å·²ä¼˜åŒ–)
                                                                 // 0.05: ææ…¢é£˜è½ï¼Œæœ‰é£˜åŠ¨æ„Ÿ
            MEDIUM_SPEED_FACTOR: 0.15,       // ğŸŒ¤ï¸ ä¸­é€Ÿé€Ÿåº¦å› å­(0.1-0.4) - ä¸­æœŸé£˜è½é€Ÿåº¦
                                                                 // 0.15: æ›´å¹³ç¼“çš„ä¸­é€Ÿè¿‡æ¸¡(âœ¨å·²ä¼˜åŒ–)
                                                                 // 0.2: é€‚ä¸­ï¼Œæœ‰æ˜æ˜¾é€Ÿåº¦å˜åŒ–
                                                                 // 0.4: åå¿«ï¼Œæ¥è¿‘æ­£å¸¸é€Ÿåº¦
            SLOW_EASING_EXPONENT: 3.0,       // ğŸ“ˆ æ…¢â†’ä¸­é€Ÿç¼“åŠ¨æŒ‡æ•°(1.0-3.0) - ç¬¬ä¸€é˜¶æ®µåŠ é€Ÿæ›²çº¿å½¢çŠ¶
                                                                 // 2.0: å¹³æ»‘åŠ é€Ÿ - å¼€å§‹å¾ˆæ…¢ï¼Œåæ¥å˜å¿«
                                                                 // 3.0: æ›´å¹³ç¼“çš„åŠ é€Ÿæ›²çº¿(âœ¨å·²ä¼˜åŒ–)
                                                                 // 4.0: æ€¥å‰§åŠ é€Ÿ - é•¿æ—¶é—´æ…¢é€Ÿï¼Œçªç„¶å˜å¿«
            MEDIUM_EASING_EXPONENT: 3.5      // ğŸ“Š ä¸­â†’æ­£å¸¸é€Ÿç¼“åŠ¨æŒ‡æ•°(1.0-4.0) - ç¬¬äºŒé˜¶æ®µåŠ é€Ÿæ›²çº¿å½¢çŠ¶
                                                                 // 2.5: å¹³æ»‘åŠ é€Ÿ - è‡ªç„¶è¿‡æ¸¡
                                                                 // 3.5: æ›´å¹³ç¼“çš„æœ€ç»ˆè¿‡æ¸¡(âœ¨å·²ä¼˜åŒ–)
                                                                 // 4.0: æ€¥å‰§åŠ é€Ÿ - é•¿æ—¶é—´ä¸­é€Ÿï¼Œçªç„¶æ­£å¸¸
            },
            
            // åŠ¨ç”»æ—¶åºå¸¸é‡ - â° æ§åˆ¶æ¯ä¸ªåŠ¨ç”»é˜¶æ®µçš„å¼€å§‹æ—¶é—´å’ŒæŒç»­æ—¶é—´
            ANIMATION_PHASES: {
                // é˜¶æ®µ1ï¼šç²’å­å‡ºç°é˜¶æ®µ - ä»åŠ¨ç”»å¼€å§‹åˆ°æ‰€æœ‰ç²’å­å¯è§
                PARTICLES_APPEAR_START: 0,                    // ğŸ“… ç²’å­å¼€å§‹å‡ºç°æ—¶é—´(msï¼Œç›¸å¯¹åŠ¨ç”»å¼€å§‹) - é€šå¸¸ä¸º0
                ALL_PARTICLES_VISIBLE_DELAY: 500,           // â³ å…¨éƒ¨ç²’å­å¯è§åé¢å¤–å»¶è¿Ÿ(ms) - ç­‰å¾…æ‰€æœ‰ç²’å­æ˜¾ç¤ºå®Œçš„æ—¶é—´
                                                                 // 0: æ— å»¶è¿Ÿï¼Œç«‹å³è¿›å…¥ä¸‹ä¸€é˜¶æ®µ
                                                                 // 500: é€‚ä¸­å»¶è¿Ÿï¼Œè®©è§‚ä¼—æ¬£èµæ˜Ÿå½¢(âœ¨æ¨è)
                                                                 // 2000: é•¿å»¶è¿Ÿï¼Œå»¶é•¿æ˜Ÿå½¢å±•ç¤º
                
                // é˜¶æ®µ2ï¼šæ˜Ÿå½¢é—ªè€€é˜¶æ®µ - ç²’å­ä»¥æ˜Ÿå½¢æ¨¡å¼é—ªçƒ
                SPARKLE_DURATION: 3000,                    // âœ¨ æ˜Ÿå½¢é—ªè€€æŒç»­æ—¶é—´(ms) - æ˜Ÿå½¢é—ªçƒçš„æ—¶é—´é•¿åº¦
                                                                 // 2000: çŸ­æš‚é—ªè€€ï¼Œå¿«é€Ÿè¿‡æ¸¡
                                                                 // 4000: é€‚ä¸­æ—¶é•¿ï¼Œå……åˆ†å±•ç¤ºæ˜Ÿå½¢(âœ¨æ¨è)
                                                                 // 8000: é•¿æ—¶é—´é—ªè€€ï¼Œå»¶é•¿æ˜Ÿå½¢é˜¶æ®µ
                SPARKLE_DELAY_BETWEEN_BATCHES: 0,          // â¸ï¸ æ‰¹æ¬¡é—´é—ªè€€å»¶è¿Ÿ(ms) - æ‰¹æ¬¡é—´çš„é¢å¤–å»¶è¿Ÿ
                
                // é˜¶æ®µ3ï¼šè¿‡æ¸¡æ±‡èšé˜¶æ®µ - ç²’å­ä»æ˜Ÿå½¢æ±‡èšæˆæ ‘å½¢
                TRANSITION_DURATION: 3500,                  // ğŸŒŠ æ˜Ÿå½¢åˆ°æ ‘å½¢è¿‡æ¸¡æ—¶é—´(ms) - æ±‡èšè¿‡ç¨‹çš„å¿«æ…¢
                                                                 // ğŸ¯ æ±‡èšé€Ÿåº¦ä¸æ—¶é•¿å®Œå…¨å…³è”ï¼Œç»“æŸæ—¶åˆšå¥½æ±‡èšå®Œæˆ
                                                                 // 1000: 1ç§’å¿«é€Ÿæ±‡èšï¼Œç¬å˜æ•ˆæœ
                                                                 // 3500: 3.5ç§’å¿«é€Ÿæ±‡èšï¼Œæµ‹è¯•ç”¨(ğŸ¯å½“å‰è®¾ç½®)
                                                                 // 4000: 4ç§’é€‚ä¸­é€Ÿåº¦ï¼Œè‡ªç„¶è¿‡æ¸¡(âœ¨æ¨è)  
                                                                 // 20000: 20ç§’æ…¢é€Ÿæ±‡èšï¼Œä¾¿äºè§‚å¯Ÿç»†èŠ‚
                TRANSITION_START_DELAY: 0,                  // â¸ï¸ è¿‡æ¸¡å¼€å§‹å»¶è¿Ÿ(ms) - æ˜Ÿå½¢é˜¶æ®µç»“æŸåé¢å¤–ç­‰å¾…
                                                                 // 0: æ— å»¶è¿Ÿï¼Œç«‹å³å¼€å§‹æ±‡èš
                                                                 // 500: çŸ­å»¶è¿Ÿï¼Œç»™è§‚ä¼—ååº”æ—¶é—´
                                                                 // 2000: é•¿å»¶è¿Ÿï¼Œå»¶é•¿æ˜Ÿå½¢å±•ç¤º
                
                // é˜¶æ®µ4ï¼šæœ€ç»ˆæˆå‹é˜¶æ®µ - æ ‘å®Œå…¨å½¢æˆå¹¶å¼€å§‹æ—‹è½¬
                TREE_FORMED_DURATION: 0,               // ğŸ„ æ ‘æˆå‹åç¨³å®šæŒç»­æ—¶é—´(ms) - æˆæ ‘ååˆ°å¼€å§‹é›ªèŠ±çš„æ—¶é—´
                                                                 // 0: ç«‹å³å¼€å§‹é›ªèŠ±
                                                                 // 8000: é€‚ä¸­æ—¶é•¿ï¼Œè®©è§‚ä¼—æ¬£èµæˆæ ‘(âœ¨æ¨è)
                                                                 // 15000: é•¿æ—¶é•¿ï¼Œå……åˆ†å±•ç¤ºæˆå‹æ•ˆæœ
                ROTATION_SPEED_NORMAL: -0.002,             // ğŸ”„ æ ‘æ­£å¸¸æ—‹è½¬é€Ÿåº¦(å¼§åº¦/å¸§) - æˆæ ‘åçš„æ—‹è½¬å¿«æ…¢
                                                                 // -0.001: å¾ˆæ…¢æ—‹è½¬ï¼Œå‡ ä¹é™æ­¢
                                                                 // -0.002: ç¼“æ…¢æ—‹è½¬ï¼Œä¼˜é›…è‡ªç„¶(âœ¨æ¨è)
                                                                 // -0.005: å¿«é€Ÿæ—‹è½¬ï¼ŒåŠ¨æ„Ÿå¼º
                ROTATION_SPEED_ACCELERATED: -0.004,        // ğŸš€ è¿‡æ¸¡é˜¶æ®µåŠ é€Ÿæ—‹è½¬é€Ÿåº¦(å¼§åº¦/å¸§) - æ±‡èšæ—¶çš„æ—‹è½¬å¿«æ…¢
                                                                 // -0.002: ä¸æ­£å¸¸é€Ÿåº¦ç›¸åŒ
                                                                 // -0.004: é€‚ä¸­åŠ é€Ÿï¼Œå¢åŠ åŠ¨æ„Ÿ(âœ¨æ¨è)
                                                                 // -0.008: å¿«é€ŸåŠ é€Ÿï¼ŒåŠ¨æ„Ÿå¼ºçƒˆ
                
                // é˜¶æ®µ5ï¼šé›ªèŠ±åŠ¨ç”»é˜¶æ®µ - ç‹¬ç«‹æ§åˆ¶é›ªèŠ±å‡ºç°æ—¶é—´
                SNOW_START_DELAY_ABSOLUTE: 4000,         // â„ï¸ é›ªèŠ±ç»å¯¹å¼€å§‹æ—¶é—´(msï¼Œç›¸å¯¹åŠ¨ç”»å¼€å§‹) - ç»å¯¹æ—¶é—´æ§åˆ¶
                                                                 // 1500: æ—©æœŸå¼€å§‹ï¼Œä¸æ ‘å½¢æˆé‡å 
                                                                 // 4000: é€‚ä¸­æ—¶é—´ï¼Œæ ‘åŸºæœ¬æˆå‹åå¼€å§‹(âœ¨æ¨è)
                                                                 // 8000: æ™šæœŸå¼€å§‹ï¼Œç­‰æ ‘å®Œå…¨ç¨³å®šåå†ä¸‹é›ª
                SNOW_START_DELAY_RELATIVE: 0,              // ğŸ„ é›ªèŠ±ç›¸å¯¹æ ‘æˆå‹å»¶è¿Ÿ(msï¼Œå¤‡ç”¨é€‰é¡¹) - ç›¸å¯¹æ—¶é—´æ§åˆ¶
                                                                 // 0: æ ‘æˆå‹åç«‹å³å¼€å§‹
                                                                 // 2000: æ ‘æˆå‹å2ç§’å¼€å§‹
                SNOW_DURATION: 30000,                     // ğŸ’¨ é›ªèŠ±åŠ¨ç”»æŒç»­æ—¶é—´(msï¼Œ0è¡¨ç¤ºæŒç»­) - é›ªèŠ±æŒç»­å¤šä¹…
                                                                 // 0: æŒç»­ä¸‹é›ªï¼Œæ— é™æ—¶
                                                                 // 30000: 30ç§’ï¼Œé€‚åˆæ¼”ç¤º
                                                                 // 60000: 1åˆ†é’Ÿï¼Œé•¿æ—¶é—´æ¬£èµ
                USE_ABSOLUTE_SNOW_TIMING: true,            // â° æ˜¯å¦ä½¿ç”¨ç»å¯¹æ—¶é—´æ§åˆ¶é›ªèŠ±(å¦åˆ™ç”¨ç›¸å¯¹æ ‘æˆå‹æ—¶é—´)
                                                                 // true: ä½¿ç”¨SNOW_START_DELAY_ABSOLUTE(âœ¨æ¨è)
                                                                 // false: ä½¿ç”¨SNOW_START_DELAY_RELATIVE
                
                // ğŸŒŸ æ ‘ç²’å­æ±‡èšåŠ¨ç”»å¸¸é‡ - æ§åˆ¶ä»æ˜Ÿå½¢åˆ°æ ‘å½¢çš„è¿‡æ¸¡æ•ˆæœ
                TRANSITION_EASING_TYPE: "LINEAR",  // ğŸ“ˆ è¿‡æ¸¡ç¼“åŠ¨ç±»å‹ - æ§åˆ¶ç²’å­ç§»åŠ¨çš„åŠ é€Ÿåº¦æ„Ÿè§‰
                                                                 // "SMOOTH_ACCELERATE": å¼€å§‹æ…¢åæ¥å¿«(âœ¨æ¨è) - è¥é€ è‡ªç„¶æ±‡èšæ„Ÿ
                                                                 // "LINEAR": åŒ€é€Ÿè¿‡æ¸¡ - æœºæ¢°æ„Ÿå¼ºï¼Œåƒå¼€å…³é—¨
                                                                 // "EASE_IN_OUT": æ…¢-å¿«-æ…¢ - å…ˆåŠ é€Ÿåå‡é€Ÿï¼Œåƒæ±½è½¦å¯åœ
                INITIAL_RADIUS: 15.0,                       // ğŸŒŸ åˆå§‹æ˜Ÿå½¢åŠå¾„(5.0-20.0) - æ˜Ÿå½¢é˜¶æ®µç²’å­åˆ†å¸ƒèŒƒå›´ (ä¸´æ—¶å¢å¤§ä»¥ä¾¿è§‚å¯Ÿ)
                                                                 // 5.0: å°èŒƒå›´ï¼Œç²’å­é›†ä¸­
                                                                 // 10.0: é€‚ä¸­èŒƒå›´ï¼Œè‡ªç„¶åˆ†å¸ƒ(âœ¨æ¨è)
                                                                 // 20.0: å¤§èŒƒå›´ï¼Œç²’å­åˆ†æ•£
                INITIAL_SIZE_MULTIPLIER: 3.0,               // ğŸŒŸ åˆå§‹æ˜Ÿå½¢å¤§å°å€æ•°(2.0-5.0) - æ˜Ÿå½¢é˜¶æ®µç²’å­å¤§å°
                                                                 // 2.0: å°æ˜Ÿå½¢ï¼Œè¿‡æ¸¡ä¸æ˜æ˜¾
                                                                 // 3.0: ä¸­ç­‰æ˜Ÿå½¢ï¼Œè¿‡æ¸¡æ•ˆæœæ¸…æ™°(âœ¨æ¨è) 
                                                                 // 5.0: å¤§æ˜Ÿå½¢ï¼Œè§†è§‰æ•ˆæœéœ‡æ’¼ä½†è¿‡æ¸¡çªå…€
                FINAL_SIZE_MULTIPLIER: 1.0,                 // ğŸ„ æœ€ç»ˆå¤§å°å€æ•°(0.8-1.2) - æˆæ ‘åç²’å­çš„æ•´ä½“å¤§å°
                                                                 // 0.8: å°ç²’å­ï¼Œæ ‘æ›´ç²¾è‡´
                                                                 // 1.0: æ­£å¸¸å¤§å°(âœ¨æ¨è)
                                                                 // 1.2: å¤§ç²’å­ï¼Œæ ‘æ›´é¥±æ»¡èŒ‚å¯†
                SIZE_TRANSITION_SYNC: true,                  // ğŸ”„ å¤§å°è¿‡æ¸¡ä¸ä½ç½®è¿‡æ¸¡æ˜¯å¦åŒæ­¥
                                                                 // true: å¤§å°å’Œä½ç½®åŒæ­¥å˜åŒ– - è¿‡æ¸¡æ›´è¿è´¯è‡ªç„¶(âœ¨æ¨è)
                                                                 // false: å¤§å°çº¿æ€§å˜åŒ–ï¼Œä½ç½®ç¼“åŠ¨å˜åŒ– - äº§ç”Ÿä¸åŒçš„åŠ¨ç”»å±‚æ¬¡
                
                // è®¡ç®—è¾…åŠ©å¸¸é‡ - è¿™äº›å€¼ç”±ä¸Šè¿°å¸¸é‡è®¡ç®—å¾—å‡º
                BATCH_PROCESSING_INTERVAL: 120,              // âš™ï¸ æ‰¹æ¬¡å¤„ç†é—´éš”(msï¼ŒåŸBATCH_INTERVAL)
                ROTATION_ACCELERATION_START_OFFSET: 0,     // ğŸš€ å¼€å§‹åŠ é€Ÿæ—‹è½¬çš„æ—¶æœºåç§»(ms)
                ROTATION_ACCELERATION_END_OFFSET: 0         // ğŸ ç»“æŸåŠ é€Ÿæ—‹è½¬çš„æ—¶æœºåç§»(ms)
            }
        }; // CONFIGå¯¹è±¡ç»“æŸ

        // å…¨å±€å˜é‡æ§åˆ¶ç²’å­ç³»ç»ŸçŠ¶æ€
        let particlesStarted = false;
        let animationParams = null;
        let scene, camera, renderer;
        


        /**
         * è®¡ç®—æ‰¹æ¬¡æ—¶é—´ç›¸å…³çš„å…¬å…±å‡½æ•° - é¿å…é‡å¤è®¡ç®—
         * @returns {Object} åŒ…å«æ€»æ‰¹æ¬¡æ•°å’Œå‡ºç°æŒç»­æ—¶é—´çš„å¯¹è±¡
         */
        function calculateBatchTiming() {
            const totalBatches = Math.ceil(CONFIG.TREE.PARTICLE_COUNT / CONFIG.TREE.BATCH_SIZE);
            const appearDuration = CONFIG.ANIMATION_PHASES.BATCH_PROCESSING_INTERVAL * totalBatches + 
                                   CONFIG.TIMING.APPEAR_DURATION + 
                                   CONFIG.ANIMATION_PHASES.ALL_PARTICLES_VISIBLE_DELAY;
            return { totalBatches, appearDuration };
        }

        /**
         * åˆ›å»ºCanvasèƒŒæ™¯çš„é€šç”¨å‡½æ•° - é¿å…é‡å¤ä»£ç 
         * @param {number} width - Canvaså®½åº¦
         * @param {number} height - Canvasé«˜åº¦
         * @param {Function} fillCallback - å¡«å……Canvasçš„å›è°ƒå‡½æ•°ï¼Œæ¥æ”¶ctxä½œä¸ºå‚æ•°
         * @returns {THREE.CanvasTexture} è¿”å›Three.jsçº¹ç†å¯¹è±¡
         */
        function createCanvasBackground(width, height, fillCallback) {
            const canvas = document.createElement('canvas');
            canvas.width = width;
            canvas.height = height;
            const ctx = canvas.getContext('2d');
            
            // è°ƒç”¨å›è°ƒå‡½æ•°æ¥å¡«å……canvas
            fillCallback(ctx, canvas);
            
            return ThreeFactory.CanvasTexture(canvas);
        }


        

        
        /**
         * ğŸš€ å¯åŠ¨å•ä¸ªé˜¶æ®µåŠ¨ç”»ï¼ˆè¿”å›Promiseï¼‰
         * @param {string} stageId - é˜¶æ®µID
         * @returns {Promise} - é˜¶æ®µå®Œæˆçš„Promise
         */
        function startStageWithPromise(stageId) {
            return new Promise((resolve) => {
                // å®šä¹‰é˜¶æ®µé…ç½®
                const stageConfig = {
                    'particles-appear': { name: 'ğŸŒŸ ç²’å­å‡ºç°', duration: calculateBatchTiming().appearDuration },
                    'sparkle': { name: 'âœ¨ æ˜Ÿå½¢é—ªè€€', duration: CONFIG.ANIMATION_PHASES.SPARKLE_DURATION },
                    'transition': { name: 'ğŸŒŠ è¿‡æ¸¡æ±‡èš', duration: CONFIG.ANIMATION_PHASES.TRANSITION_DURATION },
                    'tree-formed': { name: 'ğŸ„ æ ‘å½¢æˆ', duration: CONFIG.ANIMATION_PHASES.TREE_FORMED_DURATION },
                    'snow': { name: 'â„ï¸ é›ªèŠ±é£˜è½', duration: CONFIG.ANIMATION_PHASES.SNOW_DURATION || 0 }
                };
                
                const stage = stageConfig[stageId];
                if (!stage) {
                    console.error(`âŒ æœªæ‰¾åˆ°é˜¶æ®µ: ${stageId}`);
                    resolve();
                    return;
                }
                
                console.log(`ğŸš€ å¯åŠ¨é˜¶æ®µ: ${stage.name} (${stage.duration}ms)`);
                
                // å¦‚æœæ˜¯é›ªèŠ±é˜¶æ®µï¼Œç‰¹æ®Šå¤„ç†
                if (stageId === 'snow') {
                    // ğŸ¯ å…³é”®ä¿®å¤ï¼šPromiseé“¾ä¸­ä¸ç«‹å³å¯åŠ¨é›ªèŠ±ï¼Œè®©ç»å¯¹æ—¶é—´æ§åˆ¶ç”Ÿæ•ˆ
                    console.log('â„ï¸ é›ªèŠ±é˜¶æ®µå‡†å¤‡å°±ç»ªï¼Œç­‰å¾…ç»å¯¹æ—¶é—´è§¦å‘å¯åŠ¨');
                    
                    // é›ªèŠ±æ˜¯æŒç»­åŠ¨ç”»ï¼Œç›´æ¥resolve
                    resolve();
                } else {
                    // ä½¿ç”¨setTimeoutç­‰å¾…é˜¶æ®µå®Œæˆ
                    setTimeout(() => {
                        console.log(`âœ… ${stage.name} é˜¶æ®µå®Œæˆ`);
                        resolve(); // é˜¶æ®µå®Œæˆï¼Œè§¦å‘ä¸‹ä¸€ä¸ªPromise
                    }, stage.duration);
                }
            });
        }
        
        /**
         * ğŸ¬ æ‰§è¡Œå®Œæ•´åŠ¨ç”»æµç¨‹ï¼ˆPromiseé“¾å¼è°ƒç”¨ï¼‰
         */
        async function runAnimationSequence() {
            console.log('ğŸ¬ å¼€å§‹æ‰§è¡ŒåŠ¨ç”»åºåˆ—');
            
            try {
                // ä¸¥æ ¼ä¸²è¡Œæ‰§è¡Œæ¯ä¸ªé˜¶æ®µ
                await startStageWithPromise('particles-appear'); // ç­‰å¾…ç²’å­å‡ºç°å®Œæˆ
                await startStageWithPromise('sparkle'); // ç­‰å¾…æ˜Ÿå½¢é—ªè€€å®Œæˆ
                await startStageWithPromise('transition'); // ç­‰å¾…è¿‡æ¸¡æ±‡èšå®Œæˆ
                await startStageWithPromise('tree-formed'); // ç­‰å¾…æ ‘å½¢æˆå®Œæˆ
                await startStageWithPromise('snow'); // å¯åŠ¨é›ªèŠ±é£˜è½
                
                console.log('ğŸ‰ æ‰€æœ‰åŠ¨ç”»é˜¶æ®µæ‰§è¡Œå®Œæˆ');
            } catch (error) {
                console.error('âŒ åŠ¨ç”»æ‰§è¡Œå‡ºé”™:', error);
            }
        }



        // é¡µé¢åŠ è½½å®Œæˆåç«‹å³åˆå§‹åŒ–Three.jsï¼ˆå…ˆåŠ è½½èƒŒæ™¯ï¼‰
        window.addEventListener('DOMContentLoaded', () => {
            initThreeJs();
        }); // DOMåŠ è½½å®Œæˆäº‹ä»¶ç›‘å¬å™¨
        
        /**
         * èƒŒæ™¯åŠ è½½å®Œæˆåæ˜¾ç¤ºå¯åŠ¨ç•Œé¢
         */
        function showStartScreen() {
            const start = document.getElementById('start');
            
            // æ˜¾ç¤ºå¯åŠ¨ç•Œé¢
            start.style.display = 'flex';
            console.log('ğŸ–±ï¸ å¯åŠ¨ç•Œé¢å·²æ˜¾ç¤ºï¼Œç­‰å¾…ç”¨æˆ·ç‚¹å‡»');
            
            start.addEventListener('click', () => {
                // æ’­æ”¾éŸ³ä¹
                const audio = document.getElementById('christmasAudio');
                audio.loop = true;
                audio.volume = 0.5;
                audio.play().then(() => {
                    console.log('ğŸµ èƒŒæ™¯éŸ³ä¹å¼€å§‹æ’­æ”¾');
                }).catch(error => {
                    console.error('âŒ æ’­æ”¾éŸ³ä¹å¤±è´¥:', error);
                });
                
                // ç§»é™¤å¯åŠ¨ç•Œé¢
                start.remove();
                
                // å¯åŠ¨ç²’å­ç³»ç»Ÿå’Œå®Œæ•´åŠ¨ç”»
                setTimeout(() => {
                    console.log('ğŸŒŸ å¼€å§‹åˆå§‹åŒ–ç²’å­ç³»ç»Ÿ...');
                    // ç›´æ¥å¯åŠ¨åŠ¨ç”»åºåˆ—
                    runAnimationSequence();
                    initParticles();
                    particlesStarted = true;
                }, CONFIG.TIMING.PARTICLE_INIT_DELAY);
            });
        }
        
        /**
         * Three.jsåˆå§‹åŒ–ä¸»å‡½æ•°
         */
        function initThreeJs() { // Three.jsåˆå§‹åŒ–å‡½æ•°å¼€å§‹
            // åˆ›å»ºThree.jsåœºæ™¯å¯¹è±¡
            scene = new THREE.Scene(); // åˆ›å»º3Dåœºæ™¯å®¹å™¨
            
            // ä¼˜å…ˆä½¿ç”¨æ¸å˜èƒŒæ™¯ï¼Œé¿å…å›¾ç‰‡åŠ è½½é—®é¢˜
            useFallbackBackground(scene);
            
            // æ·»åŠ å…¨å±€å…‰æº - ğŸ’¡ æå‡æ•´ä½“åœºæ™¯äº®åº¦
            // 1. ç¯å¢ƒå…‰ï¼šæä¾›åŸºç¡€ç…§æ˜ï¼Œæ¶ˆé™¤å®Œå…¨é»‘æš—åŒºåŸŸ
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.8); // ç™½è‰²ç¯å¢ƒå…‰ï¼Œé€‚ä¸­å¼ºåº¦
            scene.add(ambientLight);
            
            // 2. æ–¹å‘å…‰ï¼šæ¨¡æ‹Ÿå¤ªé˜³å…‰ï¼Œæä¾›ä¸»è¦æ–¹å‘æ€§ç…§æ˜ï¼Œå¢åŠ ç«‹ä½“æ„Ÿ
            const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8); // ç™½è‰²æ–¹å‘å…‰ï¼Œå¼ºåº¦0.8
            directionalLight.position.set(10, 20, 10); // å…‰æºä½ç½®ï¼šå³ä¸Šæ–¹
            directionalLight.castShadow = false; // ç¦ç”¨é˜´å½±ä»¥æé«˜æ€§èƒ½
            scene.add(directionalLight);
            
            // 3. è¡¥å…‰ï¼šå¢å¼ºé˜´å½±åŒºåŸŸçš„äº®åº¦
            const fillLight = new THREE.DirectionalLight(0xffffff, 0.3); // ç™½è‰²è¡¥å…‰ï¼Œå¼ºåº¦0.3
            fillLight.position.set(-10, 10, -10); // è¡¥å…‰ä½ç½®ï¼šå·¦ä¸‹æ–¹
            scene.add(fillLight);
            
            // åˆå§‹åŒ–ç›¸æœº
            camera = createCamera(); // è°ƒç”¨ç›¸æœºåˆ›å»ºå‡½æ•°
            
            // åˆå§‹åŒ–æ¸²æŸ“å™¨
            renderer = createRenderer(); // è°ƒç”¨æ¸²æŸ“å™¨åˆ›å»ºå‡½æ•°
            
            // æ·»åŠ çª—å£å¤§å°è°ƒæ•´äº‹ä»¶ç›‘å¬
            window.addEventListener('resize', () => onWindowResize(camera, renderer)); // ç›‘å¬çª—å£å¤§å°å˜åŒ–
            
            // å°è¯•åŠ è½½èƒŒæ™¯å›¾ç‰‡ï¼ŒåŠ è½½å®Œæˆåæ˜¾ç¤ºå¯åŠ¨ç•Œé¢
            tryLoadBackgroundImage(scene, renderer, camera, () => {
                // èƒŒæ™¯åŠ è½½å®Œæˆï¼Œæ¸²æŸ“ç¬¬ä¸€å¸§
                renderer.render(scene, camera);
                console.log('ğŸ¬ èƒŒæ™¯å‡†å¤‡å°±ç»ªï¼Œå¼€å§‹ç®€å•åŠ¨ç”»å¾ªç¯');
                
                // å¼€å§‹ç®€å•çš„åŠ¨ç”»å¾ªç¯ï¼ˆåªæ¸²æŸ“èƒŒæ™¯ï¼‰
                animate();
                
                // èƒŒæ™¯åŠ è½½å®Œæˆåï¼Œæ˜¾ç¤ºå¯åŠ¨ç•Œé¢
                console.log('ğŸ–±ï¸ èƒŒæ™¯åŠ è½½å®Œæˆï¼Œæ˜¾ç¤ºå¯åŠ¨ç•Œé¢');
                showStartScreen();
            });
        } // initThreeJså‡½æ•°ç»“æŸ
        
        /**
         * åˆå§‹åŒ–ç²’å­ç³»ç»Ÿï¼ˆå»¶è¿Ÿæ‰§è¡Œï¼‰
         */
        function initParticles() {
            // åˆ›å»ºé›ªèŠ±ç²’å­ç³»ç»Ÿï¼ˆåˆå§‹éšè—ï¼‰
            const snowSystem = createSnowParticles(scene); // è°ƒç”¨é›ªèŠ±ç³»ç»Ÿåˆ›å»ºå‡½æ•°
            snowSystem.snowParticles.visible = false; // åˆå§‹éšè—é›ªç²’å­
            
            // åˆ›å»ºåœ£è¯æ ‘
            const { // è§£æ„èµ‹å€¼ï¼Œè·å–åˆ›å»ºåœ£è¯æ ‘è¿”å›çš„å¤šä¸ªå¯¹è±¡
                treeGroup, // æ ‘çš„ç»„å¯¹è±¡
                particleBatches, // ç²’å­æ‰¹æ¬¡æ•°ç»„
                coloredLightObjects, // å½©è‰²ç¯å…‰å¯¹è±¡æ•°ç»„
                animationState // åŠ¨ç”»çŠ¶æ€å¯¹è±¡
            } = createChristmasTree(scene); // è°ƒç”¨åœ£è¯æ ‘åˆ›å»ºå‡½æ•°
            
            // åˆå§‹åŒ–ç›¸æœºæ§åˆ¶å‚æ•°
            const cameraControls = initCameraControls(camera); // è°ƒç”¨ç›¸æœºæ§åˆ¶åˆå§‹åŒ–å‡½æ•°
            
            // ä¿å­˜åŠ¨ç”»å‚æ•°åˆ°å…¨å±€å˜é‡
            animationParams = {
                scene, // 3Dåœºæ™¯
                camera, // ç›¸æœº
                renderer, // æ¸²æŸ“å™¨
                snowSystem, // é›ªèŠ±ç³»ç»Ÿ
                treeGroup, // æ ‘ç»„
                particleBatches, // ç²’å­æ‰¹æ¬¡
                coloredLightObjects, // å½©è‰²ç¯å…‰
                cameraControls, // ç›¸æœºæ§åˆ¶
                animationState // åŠ¨ç”»çŠ¶æ€
            };
            
            console.log('âœ… ç²’å­ç³»ç»Ÿåˆå§‹åŒ–å®Œæˆ');
        }
        
        /**
         * åˆ›å»ºé€è§†ç›¸æœº
         */
        function createCamera() { // ç›¸æœºåˆ›å»ºå‡½æ•°å¼€å§‹
            const camera = new THREE.PerspectiveCamera( // åˆ›å»ºé€è§†ç›¸æœºå¯¹è±¡
                CONFIG.CAMERA.FOV, // è§†åœºè§’åº¦
                window.innerWidth / window.innerHeight, // å®½é«˜æ¯”
                CONFIG.CAMERA.NEAR, // è¿‘è£å‰ªé¢
                CONFIG.CAMERA.FAR // è¿œè£å‰ªé¢
            ); // PerspectiveCameraåˆ›å»ºç»“æŸ
            
            camera.position.copy(CONFIG.CAMERA.INITIAL_POSITION); // è®¾ç½®ç›¸æœºåˆå§‹ä½ç½®
            camera.lookAt(CONFIG.CAMERA.TARGET); // è®¾ç½®ç›¸æœºè§‚å¯Ÿç›®æ ‡
            
            return camera; // è¿”å›ç›¸æœºå¯¹è±¡
        } // createCameraå‡½æ•°ç»“æŸ
        
        /**
         * åˆ›å»ºWebGLæ¸²æŸ“å™¨
         */
        function createRenderer() { // æ¸²æŸ“å™¨åˆ›å»ºå‡½æ•°å¼€å§‹
            const renderer = new THREE.WebGLRenderer({ antialias: true }); // åˆ›å»ºWebGLæ¸²æŸ“å™¨ï¼Œå¯ç”¨æŠ—é”¯é½¿
            renderer.setSize(window.innerWidth, window.innerHeight); // è®¾ç½®æ¸²æŸ“å™¨å°ºå¯¸ä¸ºçª—å£å¤§å°
            renderer.shadowMap.enabled = false; // ç¦ç”¨é˜´å½±æ˜ å°„æé«˜æ€§èƒ½
            
            // å¯ç”¨gammaæ ¡æ­£ï¼Œæå‡é¢œè‰²äº®åº¦å’Œå¯¹æ¯”åº¦
            renderer.gammaFactor = 2.2;
            renderer.outputEncoding = THREE.sRGBEncoding;
            
            document.body.appendChild(renderer.domElement); // å°†æ¸²æŸ“å™¨DOMå…ƒç´ æ·»åŠ åˆ°é¡µé¢
            
            return renderer; // è¿”å›æ¸²æŸ“å™¨å¯¹è±¡
        } // createRendererå‡½æ•°ç»“æŸ
        
        /**
         * å°è¯•åŠ è½½èƒŒæ™¯å›¾ç‰‡ï¼ˆå¼‚æ­¥ï¼Œéé˜»å¡ï¼‰
         */
        function tryLoadBackgroundImage(scene, renderer, camera, onComplete) {
            console.log('ğŸ” å°è¯•å¼‚æ­¥åŠ è½½èƒŒæ™¯å›¾ç‰‡...');
            
            const img = new Image();
            
            img.onload = function() {
                console.log('âœ… èƒŒæ™¯å›¾ç‰‡åŠ è½½æˆåŠŸ');
                try {
                    // ä½¿ç”¨é€šç”¨Canvasåˆ›å»ºå‡½æ•°å¤„ç†å›¾ç‰‡
                    const texture = createCanvasBackground(img.width, img.height, (ctx, canvas) => {
                        // ç»˜åˆ¶åŸå›¾
                        ctx.drawImage(img, 0, 0);
                        
                        // åº”ç”¨æš—åŒ–æ»¤é•œ
                        ctx.globalCompositeOperation = 'multiply';
                        ctx.fillStyle = `rgba(0, 0, 50, ${CONFIG.BRIGHTNESS.BACKGROUND_MULTIPLY_ALPHA})`;
                        ctx.fillRect(0, 0, canvas.width, canvas.height);
                        
                        // é‡ç½®æ··åˆæ¨¡å¼
                        ctx.globalCompositeOperation = 'source-over';
                        
                        // ç¨å¾®å¢åŠ å¯¹æ¯”åº¦
                        ctx.globalAlpha = CONFIG.BRIGHTNESS.BACKGROUND_OVERLAY_ALPHA;
                        ctx.fillStyle = '#000000';
                        ctx.fillRect(0, 0, canvas.width, canvas.height);
                        ctx.globalAlpha = 1.0;
                    });
                    texture.colorSpace = THREE.SRGBColorSpace;
                    texture.minFilter = THREE.LinearFilter;
                    texture.magFilter = THREE.LinearFilter;
                    texture.wrapS = THREE.ClampToEdgeWrapping;
                    texture.wrapT = THREE.ClampToEdgeWrapping;
                    texture.generateMipmaps = false;
                    
                    scene.background = texture;
                    
                    // å¼ºåˆ¶æ¸²æŸ“
                    setTimeout(() => {
                        renderer.render(scene, camera);
                        console.log('è°ƒæš—çš„èƒŒæ™¯å›¾ç‰‡å·²åº”ç”¨');
                        // èƒŒæ™¯åŠ è½½å®Œæˆï¼Œè°ƒç”¨å›è°ƒå¼€å§‹åŠ¨ç”»
                        onComplete();
                    }, CONFIG.TIMING.BACKGROUND_RENDER_DELAY);
                } catch (error) {
                    console.error('âŒ çº¹ç†åˆ›å»ºå¤±è´¥:', error);
                    // å³ä½¿çº¹ç†åˆ›å»ºå¤±è´¥ï¼Œä¹Ÿè¦ç»§ç»­å¯åŠ¨åŠ¨ç”»
                    onComplete();
                }
            };
            
            img.onerror = function() {
                console.log('âš ï¸ èƒŒæ™¯å›¾ç‰‡åŠ è½½å¤±è´¥ï¼Œç»§ç»­ä½¿ç”¨æ¸å˜èƒŒæ™¯');
                // å›¾ç‰‡åŠ è½½å¤±è´¥ï¼Œä½¿ç”¨æ¸å˜èƒŒæ™¯ï¼Œè°ƒç”¨å›è°ƒå¼€å§‹åŠ¨ç”»
                onComplete();
            };
            
            // å°è¯•åŠ è½½å›¾ç‰‡ï¼Œä½†ä¸é˜»å¡ä¸»ç¨‹åº
            img.src = './christmas_tree.jpg';
        }
        
        /**
         * ä½¿ç”¨æ¸å˜èƒŒæ™¯
         */
        function useFallbackBackground(scene) {
            console.log('ğŸ¨ ä½¿ç”¨æ¸å˜èƒŒæ™¯');
            
            // ä½¿ç”¨é€šç”¨Canvasåˆ›å»ºå‡½æ•°
            const texture = createCanvasBackground(512, 512, (ctx, canvas) => {
                // åˆ›å»ºæ›´æš—çš„æ¸å˜èƒŒæ™¯
                const gradient = ctx.createLinearGradient(0, 0, 0, 512);
                gradient.addColorStop(0, '#000511');    // ææ·±çš„æ·±è“è‰²
                gradient.addColorStop(0.3, '#000822');  // æ·±è“è‰²
                gradient.addColorStop(0.6, '#000b33');  // ç¨äº®çš„æ·±è“
                gradient.addColorStop(0.8, '#000e44');  // ä¸­ç­‰æ·±è“
                gradient.addColorStop(1, '#001155');    // åº•éƒ¨æ·±è“
                
                ctx.fillStyle = gradient;
                ctx.fillRect(0, 0, 512, 512);
                
                // æ·»åŠ æ›´ç¨€ç–ã€æ›´æš—çš„æ˜Ÿæ˜Ÿæ•ˆæœ
                for (let i = 0; i < 60; i++) {
                    // é™ä½æ˜Ÿæ˜Ÿçš„äº®åº¦å’Œå¯†åº¦
                    const opacity = Math.random() * 0.4;  // æœ€å¤§é€æ˜åº¦0.4
                    ctx.fillStyle = `rgba(255, 255, 255, ${opacity})`;
                    ctx.fillRect(
                        Math.random() * 512,
                        Math.random() * 512,
                        1, 1
                    );
                }
            });
            
            scene.background = texture;
            
            console.log('âœ… æ›´æš—çš„æ¸å˜èƒŒæ™¯å·²è®¾ç½®');
        }
        
        /**
         * åˆ›å»ºé›ªèŠ±ç²’å­ç³»ç»Ÿï¼ˆæ¸è¿›å¼ï¼‰
         */
        function createSnowParticles(scene) { // é›ªèŠ±ç²’å­ç³»ç»Ÿåˆ›å»ºå‡½æ•°å¼€å§‹
            const { COUNT, MAX_HEIGHT, RANGE, BASE_SPEED, SPEED_VARIANCE } = CONFIG.SNOW; // è§£æ„è·å–é›ªèŠ±é…ç½®
            
            // åˆ›å»ºå‡ ä½•ä½“
            const snowGeometry = new THREE.BufferGeometry(); // åˆ›å»ºç¼“å†²å‡ ä½•ä½“
            
            // åˆ›å»ºå±æ€§æ•°ç»„
            const snowPositions = new Float32Array(COUNT * 3); // ä½ç½®æ•°ç»„ï¼ˆX,Y,Zåæ ‡ï¼‰
            const snowColors = new Float32Array(COUNT * 3); // é¢œè‰²æ•°ç»„ï¼ˆR,G,Bå€¼ï¼‰
            const snowSizes = new Float32Array(COUNT); // å¤§å°æ•°ç»„
            const snowSpeeds = new Float32Array(COUNT); // é€Ÿåº¦æ•°ç»„
            const snowActive = new Float32Array(COUNT); // æ¿€æ´»çŠ¶æ€æ•°ç»„ï¼ˆæ§åˆ¶æ¯ä¸ªç²’å­æ˜¯å¦æ´»è·ƒï¼‰
            
            // ç™½è‰²é›ªèŠ±
            const whiteColor = new THREE.Color(0xffffff); // åˆ›å»ºç™½è‰²é¢œè‰²å¯¹è±¡
            const whiteColorArray = [whiteColor.r, whiteColor.g, whiteColor.b]; // è·å–é¢œè‰²RGBå€¼æ•°ç»„
            
            // åˆå§‹åŒ–é›ªèŠ±ç²’å­ï¼ˆåˆå§‹éƒ½ä¸æ´»è·ƒï¼‰
            for (let i = 0; i < COUNT; i++) { // éå†æ‰€æœ‰é›ªèŠ±ç²’å­
                const i3 = i * 3; // è®¡ç®—ä½ç½®æ•°ç»„ç´¢å¼•ï¼ˆæ¯ä¸ªç²’å­3ä¸ªåæ ‡å€¼ï¼‰
                
                // éšæœºä½ç½®ï¼ˆåˆå§‹åœ¨å¾ˆé«˜çš„åœ°æ–¹ï¼‰
                snowPositions[i3] = (Math.random() - 0.5) * RANGE; // Xåæ ‡éšæœº
                snowPositions[i3 + 1] = MAX_HEIGHT + Math.random() * 10; // Yåæ ‡ï¼ˆæ›´é«˜å¤„ï¼‰
                snowPositions[i3 + 2] = (Math.random() - 0.5) * RANGE; // Zåæ ‡éšæœº
                
                // ç™½è‰²
                snowColors.set(whiteColorArray, i3); // è®¾ç½®ç²’å­é¢œè‰²ä¸ºç™½è‰²
                
                // éšæœºå¤§å°
                snowSizes[i] = 0.05 + Math.random() * 0.2; // éšæœºå¤§å°èŒƒå›´0.05-0.25
                
                // éšæœºé€Ÿåº¦
                snowSpeeds[i] = BASE_SPEED + Math.random() * SPEED_VARIANCE; // åŸºç¡€é€Ÿåº¦åŠ éšæœºå˜åŒ–
                
                // åˆå§‹ä¸æ´»è·ƒ
                snowActive[i] = 0; // è®¾ç½®ä¸ºä¸æ´»è·ƒçŠ¶æ€
            } // é›ªèŠ±ç²’å­åˆå§‹åŒ–å¾ªç¯ç»“æŸ
            
            // è®¾ç½®å‡ ä½•ä½“å±æ€§
            snowGeometry.setAttribute('position', new THREE.BufferAttribute(snowPositions, 3));
            snowGeometry.setAttribute('color', new THREE.BufferAttribute(snowColors, 3));
            snowGeometry.setAttribute('size', new THREE.BufferAttribute(snowSizes, 1));
            snowGeometry.setAttribute('active', new THREE.BufferAttribute(snowActive, 1));
            
            // åˆ›å»ºæè´¨
            const snowMaterial = new THREE.PointsMaterial({
                size: 0.1,
                vertexColors: true,
                transparent: true,
                opacity: 0.8,
                blending: THREE.AdditiveBlending,
                sizeAttenuation: true
            });
            
            // åˆ›å»ºç²’å­ç³»ç»Ÿ
            const snowParticles = new THREE.Points(snowGeometry, snowMaterial);
            scene.add(snowParticles);
            
            // è¿”å›åŠ¨ç”»æ›´æ–°å‡½æ•°
            return {
                snowParticles,
                updateSnowAnimation: (time, fadeInComplete, snowStartTime) => updateSnowAnimation(snowParticles, COUNT, snowSpeeds, time, fadeInComplete, snowStartTime)
            };
        }
        
        /**
         * æ›´æ–°é›ªèŠ±åŠ¨ç”»ï¼ˆæ¸è¿›å¼æ¿€æ´»ï¼‰
         */
        function updateSnowAnimation(snowParticles, particleCount, snowSpeeds, time, fadeInComplete, snowStartTime) {
            const { MAX_HEIGHT, MIN_HEIGHT, RANGE, WIND_DIRECTION, BASE_SPEED, SPEED_VARIANCE } = CONFIG.SNOW;
            const positionsArray = snowParticles.geometry.attributes.position.array;
            const activeArray = snowParticles.geometry.attributes.active.array;
            
            const elapsedSinceSnowStart = snowStartTime ? (Date.now() - snowStartTime) / 1000 : 0;
            
            // ğŸŒ¨ï¸ è®¡ç®—ä¸‰é˜¶æ®µé€Ÿåº¦å› å­ - æ…¢é€Ÿâ†’ä¸­é€Ÿâ†’æ­£å¸¸é€Ÿåº¦ï¼ˆä¼˜åŒ–ç‰ˆï¼‰
            let currentSpeedFactor = CONFIG.SNOW_ANIMATION.FALL_SPEED_FACTOR;
            
            if (elapsedSinceSnowStart > 0) {
                const totalTransitionTime = CONFIG.SNOW_ANIMATION.SLOW_PHASE_DURATION + CONFIG.SNOW_ANIMATION.MEDIUM_PHASE_DURATION;
                
                if (elapsedSinceSnowStart <= CONFIG.SNOW_ANIMATION.SLOW_PHASE_DURATION) {
                    // ğŸŒ ç¬¬ä¸€é˜¶æ®µï¼šææ…¢é€Ÿåº¦ - ä½¿ç”¨æ›´å¹³æ»‘çš„ç¼“åŠ¨å‡½æ•°
                    const progress = elapsedSinceSnowStart / CONFIG.SNOW_ANIMATION.SLOW_PHASE_DURATION;
                    // ä½¿ç”¨smoothstepå‡½æ•°è·å¾—æ›´å¹³æ»‘çš„è¿‡æ¸¡
                    const smoothProgress = progress * progress * (3.0 - 2.0 * progress);
                    // ç»“åˆå¹‚å‡½æ•°å’Œsmoothstepï¼Œåˆ›é€ æ›´è‡ªç„¶çš„åŠ é€Ÿæ„Ÿ
                    const easedProgress = smoothProgress * Math.pow(progress, CONFIG.SNOW_ANIMATION.SLOW_EASING_EXPONENT * 0.5);
                    currentSpeedFactor = CONFIG.SNOW_ANIMATION.INITIAL_SPEED_FACTOR + 
                                       (CONFIG.SNOW_ANIMATION.MEDIUM_SPEED_FACTOR - CONFIG.SNOW_ANIMATION.INITIAL_SPEED_FACTOR) * easedProgress;
                } else if (elapsedSinceSnowStart <= totalTransitionTime) {
                    // ğŸš¶ ç¬¬äºŒé˜¶æ®µï¼šä¸­é€Ÿè¿‡æ¸¡åˆ°æ­£å¸¸é€Ÿåº¦ - æ›´å¹³ç¼“çš„è¿‡æ¸¡
                    const phaseProgress = (elapsedSinceSnowStart - CONFIG.SNOW_ANIMATION.SLOW_PHASE_DURATION) / CONFIG.SNOW_ANIMATION.MEDIUM_PHASE_DURATION;
                    // ä½¿ç”¨æ›´å¹³æ»‘çš„ç¼“åŠ¨å‡½æ•°ç»„åˆ
                    const smoothProgress = phaseProgress * phaseProgress * (3.0 - 2.0 * phaseProgress);
                    const easedProgress = smoothProgress * Math.pow(phaseProgress, CONFIG.SNOW_ANIMATION.MEDIUM_EASING_EXPONENT * 0.4);
                    currentSpeedFactor = CONFIG.SNOW_ANIMATION.MEDIUM_SPEED_FACTOR + 
                                       (CONFIG.SNOW_ANIMATION.FALL_SPEED_FACTOR - CONFIG.SNOW_ANIMATION.MEDIUM_SPEED_FACTOR) * easedProgress;
                }
                // ğŸƒ ç¬¬ä¸‰é˜¶æ®µï¼šå·²ç»è¾¾åˆ°æ­£å¸¸é€Ÿåº¦ï¼Œä¿æŒä¸å˜
                
                // ğŸŒŠ æ·»åŠ å¾®å°çš„å¹³æ»‘è¿‡æ¸¡ï¼Œé¿å…çªç„¶çš„é€Ÿåº¦è·³è·ƒ
                if (elapsedSinceSnowStart > totalTransitionTime && elapsedSinceSnowStart <= totalTransitionTime + 0.5) {
                    // åœ¨è¿‡æ¸¡å®Œæˆåçš„0.5ç§’å†…ï¼Œç»§ç»­å¹³æ»‘åˆ°æœ€ç»ˆé€Ÿåº¦
                    const smoothingProgress = (elapsedSinceSnowStart - totalTransitionTime) / 0.5;
                    const smoothFactor = 0.9 + 0.1 * smoothingProgress; // ä»0.9å¹³æ»‘åˆ°1.0
                    currentSpeedFactor *= smoothFactor;
                }
            }
            
            for (let i = 0; i < particleCount; i++) {
                const i3 = i * 3;
                const speed = snowSpeeds[i];
                
                // æ¸è¿›å¼æ¿€æ´»é›ªèŠ±ï¼ˆ0.8ç§’å†…é€æ¸æ¿€æ´»æ‰€æœ‰é›ªèŠ±ï¼‰
                if (activeArray[i] === 0 && elapsedSinceSnowStart > 0) {
                    const activationDelay = (i / particleCount) * CONFIG.SNOW_ANIMATION.ACTIVATION_DURATION;
                    if (elapsedSinceSnowStart >= activationDelay) {
                        activeArray[i] = 1;
                        // å°†æ´»è·ƒç²’å­ä»é«˜å¤„å¼€å§‹ä¸‹è½
                        positionsArray[i3 + 1] = MAX_HEIGHT + Math.random() * 5;
                    }
                }
                
                // åªæœ‰æ´»è·ƒçš„é›ªèŠ±æ‰å‚ä¸åŠ¨ç”»
                if (activeArray[i] === 1) {
                    // ğŸŒ¨ï¸ é›ªèŠ±ä¸‹è½ - ä½¿ç”¨éšæ—¶é—´é€æ¸åŠ é€Ÿçš„é€Ÿåº¦
                    positionsArray[i3 + 1] -= speed * currentSpeedFactor;
                    
                    // ğŸŒ¨ï¸ é£çš„å½±å“ - åˆå§‹é˜¶æ®µä¹Ÿæ›´è½»å¾®ï¼Œé€æ¸å¢å¼º
                    const windEffectFactor = CONFIG.SNOW_ANIMATION.WIND_EFFECT_FACTOR;
                    positionsArray[i3] += WIND_DIRECTION.x * windEffectFactor;
                    positionsArray[i3 + 2] += WIND_DIRECTION.z * windEffectFactor;
                    
                    // ğŸŒ¨ï¸ å·¦å³æ‘‡æ‘† - é…åˆä¸‰é˜¶æ®µé€Ÿåº¦è¿‡æ¸¡çš„æ‘‡æ‘†æ•ˆæœï¼ˆä¼˜åŒ–ç‰ˆï¼‰
                    let swayFactor = 1.0;
                    if (elapsedSinceSnowStart <= CONFIG.SNOW_ANIMATION.SLOW_PHASE_DURATION) {
                        // ææ…¢é˜¶æ®µï¼šæœ€å°æ‘‡æ‘† - ä½¿ç”¨å¹³æ»‘è¿‡æ¸¡
                        const progress = elapsedSinceSnowStart / CONFIG.SNOW_ANIMATION.SLOW_PHASE_DURATION;
                        const smoothProgress = progress * progress * (3.0 - 2.0 * progress);
                        swayFactor = 0.05 + 0.35 * smoothProgress; // ä»0.05å¹³æ»‘åˆ°0.4
                    } else if (elapsedSinceSnowStart <= CONFIG.SNOW_ANIMATION.SLOW_PHASE_DURATION + CONFIG.SNOW_ANIMATION.MEDIUM_PHASE_DURATION) {
                        // ä¸­é€Ÿé˜¶æ®µï¼šé€æ¸å¢åŠ æ‘‡æ‘†åˆ°æ­£å¸¸ - æ›´å¹³æ»‘çš„è¿‡æ¸¡
                        const mediumProgress = (elapsedSinceSnowStart - CONFIG.SNOW_ANIMATION.SLOW_PHASE_DURATION) / CONFIG.SNOW_ANIMATION.MEDIUM_PHASE_DURATION;
                        const smoothProgress = mediumProgress * mediumProgress * (3.0 - 2.0 * mediumProgress);
                        swayFactor = 0.4 + 0.6 * smoothProgress; // ä»0.4å¹³æ»‘åˆ°1.0
                    }
                    // æ­£å¸¸é˜¶æ®µï¼šä¿æŒå®Œæ•´æ‘‡æ‘†
                    
                    const swayXAmplitude = CONFIG.SNOW_ANIMATION.SWAY_X_AMPLITUDE * swayFactor;
                    const swayZAmplitude = CONFIG.SNOW_ANIMATION.SWAY_Z_AMPLITUDE * swayFactor;
                    const swayXFrequency = CONFIG.SNOW_ANIMATION.SWAY_X_FREQUENCY * swayFactor;
                    const swayZFrequency = CONFIG.SNOW_ANIMATION.SWAY_Z_FREQUENCY * swayFactor;
                    
                    positionsArray[i3] += Math.sin(time * swayXFrequency + i * 0.1) * swayXAmplitude;
                    positionsArray[i3 + 2] += Math.cos(time * swayZFrequency + i * 0.15) * swayZAmplitude;
                    
                    // é›ªèŠ±é‡æ–°ç”Ÿæˆ
                    if (positionsArray[i3 + 1] < MIN_HEIGHT) {
                        positionsArray[i3 + 1] = MAX_HEIGHT + Math.random() * 10;
                        positionsArray[i3] = (Math.random() - 0.5) * RANGE;
                        positionsArray[i3 + 2] = (Math.random() - 0.5) * RANGE;
                    }
                }
            }
            
            snowParticles.geometry.attributes.position.needsUpdate = true;
            snowParticles.geometry.attributes.active.needsUpdate = true;
            
            // é›ªèŠ±é€æ˜åº¦å˜åŒ– - åªåœ¨æ·¡å…¥å®Œæˆåæ‰åº”ç”¨åŠ¨æ€å˜åŒ–
            if (fadeInComplete && snowParticles.material) {
                snowParticles.material.opacity = CONFIG.SNOW_ANIMATION.OPACITY_BASE + 
                                         Math.sin(time * CONFIG.SNOW_ANIMATION.OPACITY_FREQUENCY) * 
                                         CONFIG.SNOW_ANIMATION.OPACITY_VARIATION;
            }
        }
        
        /**
         * åˆ›å»ºæ ‘ç²’å­ç³»ç»Ÿï¼ˆæ‰¹å¤„ç†ç‰ˆæœ¬ï¼‰
         */
        function createTreeParticlesBatched() {
            const batches = [];
            const { PARTICLE_COUNT, BATCH_SIZE } = CONFIG.TREE;
            
            // å°†ç²’å­åˆ†ç»„ä¸ºæ‰¹æ¬¡ï¼Œæ¯ä¸ªæ‰¹æ¬¡æ˜¯ä¸€ç»„"æ˜Ÿå½¢ç²’å­"
            const BATCH_PARTICLE_COUNT = CONFIG.TREE.BATCH_SIZE; // æ¯ä¸ªæ˜Ÿå½¢ç²’å­åŒ…å«çš„åŸå§‹ç²’å­æ•°
            const batchCount = Math.floor(PARTICLE_COUNT / BATCH_PARTICLE_COUNT);
            
            // å­˜å‚¨æ‰€æœ‰ç²’å­çš„ç›®æ ‡ä½ç½®ã€é¢œè‰²å’Œå¤§å°
            const particleData = [];
            
            // å…ˆç”Ÿæˆæ‰€æœ‰ç²’å­çš„ç›®æ ‡ä½ç½®ã€é¢œè‰²å’Œå¤§å°
            for (let i = 0; i < PARTICLE_COUNT; i++) {
                const i3 = i * 3;
                
                // éšæœºé€‰æ‹©ç²’å­ç±»å‹ï¼ˆæ ‘å¹²æˆ–æ ‘å¶ï¼‰
                const isTrunk = Math.random() < CONFIG.TREE.TRUNK_RATIO;
                
                const data = {
                    index: i,
                    isTrunk: isTrunk,
                    targetPosition: new THREE.Vector3(),
                    color: new THREE.Color(),
                    size: 0
                };
                
                // ç”Ÿæˆç²’å­åœ¨æ ‘ä¸­çš„ä½ç½®å’Œå±æ€§
                if (isTrunk) {
                    generateTrunkParticleData(data);
                } else {
                    generateLeafParticleData(data);
                }
                
                particleData.push(data);
            }
            
            // åˆ›å»ºæ‰¹æ¬¡
            for (let batchIndex = 0; batchIndex < batchCount; batchIndex++) {
                // ä¸ºå½“å‰æ‰¹æ¬¡åˆ›å»ºå•ä¸ªå‡ ä½•ä½“ï¼ŒåŒ…å«æ‰€æœ‰ç²’å­
                const clusterPositions = new Float32Array(BATCH_PARTICLE_COUNT * 3);
                const targetPositions = new Float32Array(BATCH_PARTICLE_COUNT * 3);
                const colors = new Float32Array(BATCH_PARTICLE_COUNT * 3);
                const sizes = new Float32Array(BATCH_PARTICLE_COUNT);
                const baseSizes = new Float32Array(BATCH_PARTICLE_COUNT);
                
                for (let i = 0; i < BATCH_PARTICLE_COUNT; i++) {
                    const particleIndex = batchIndex * BATCH_PARTICLE_COUNT + i;
                    if (particleIndex >= PARTICLE_COUNT) break;
                    
                    const data = particleData[particleIndex];
                    const i3 = i * 3;
                    
                    // å°†ç²’å­éšæœºåˆ†å¸ƒåœ¨ç©ºé—´ä¸­ï¼Œå½¢æˆæ˜Ÿå½¢æ•ˆæœ
                    const randomRadius = CONFIG.ANIMATION_PHASES.INITIAL_RADIUS;
                    clusterPositions[i3] = (Math.random() - 0.5) * randomRadius * 2;
                    clusterPositions[i3 + 1] = (Math.random() - 0.5) * randomRadius * 1.5 + randomRadius * 0.2;
                    // ä¿®æ”¹Zè½´èŒƒå›´ï¼šæœ€å¤§å€¼3ï¼Œæœ€å°å€¼-12
                    clusterPositions[i3 + 2] = Math.random() * 15 - 12;
                    
                    // ç›®æ ‡ä½ç½®
                    targetPositions[i3] = data.targetPosition.x;
                    targetPositions[i3 + 1] = data.targetPosition.y;
                    targetPositions[i3 + 2] = data.targetPosition.z;
                    
                    // é¢œè‰²
                    colors[i3] = data.color.r;
                    colors[i3 + 1] = data.color.g;
                    colors[i3 + 2] = data.color.b;
                    
                    // ğŸŒŸ å¤§å° - ä½¿ç”¨é…ç½®çš„åˆå§‹æ˜Ÿå½¢å¤§å°å€æ•°
                    sizes[i] = data.size * CONFIG.ANIMATION_PHASES.INITIAL_SIZE_MULTIPLIER;
                    baseSizes[i] = data.size;
                }
                
                // åˆ›å»ºå‡ ä½•ä½“
                const geometry = new THREE.BufferGeometry();
                geometry.setAttribute('position', new THREE.BufferAttribute(clusterPositions, 3));
                geometry.setAttribute('targetPosition', new THREE.BufferAttribute(targetPositions, 3));
                geometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));
                geometry.setAttribute('size', new THREE.BufferAttribute(sizes, 1));
                geometry.setAttribute('baseSize', new THREE.BufferAttribute(baseSizes, 1));
                // ğŸŒŸ æ˜Ÿæ˜Ÿé˜¶æ®µçš„å¤§å°å€ç‡ - ä½¿ç”¨é…ç½®å¸¸é‡
                const starSizes = new Float32Array(BATCH_PARTICLE_COUNT).fill(CONFIG.ANIMATION_PHASES.INITIAL_SIZE_MULTIPLIER);
                geometry.setAttribute('starSize', new THREE.BufferAttribute(starSizes, 1));
                
                // åˆ›å»ºæè´¨
                const material = new THREE.PointsMaterial({
                    size: 0.25,
                    vertexColors: true,
                    transparent: true,
                    opacity: 1,
                    blending: THREE.AdditiveBlending
                });
                
                const points = new THREE.Points(geometry, material);
                points.visible = false; // ä¸€å¼€å§‹ä¸å¯è§
                
                // ä¿å­˜æ‰¹æ¬¡æ•°æ®
                points.userData.originalPositions = clusterPositions;
                points.userData.targetPositions = targetPositions;
                points.userData.batchIndex = batchIndex;
                points.userData.starPhase = 0; // 0: æ˜Ÿå½¢é˜¶æ®µ, 1: è¿‡æ¸¡é˜¶æ®µ, 2: æœ€ç»ˆä½ç½®
                
                // å°†æ˜Ÿå½¢ç²’å­ç»„æ·»åŠ åˆ°æ‰¹æ¬¡æ•°ç»„
                batches.push(points);
            }
            
            return batches;
        }
        
        /**
         * ç”Ÿæˆæ ‘å¹²ç²’å­æ•°æ®
         */
        function generateTrunkParticleData(data) {
            const { TRUNK_HEIGHT, TRUNK_BASE_RADIUS, TRUNK_TOP_RADIUS } = CONFIG.TREE;
            
            // æ ‘å¹²é«˜åº¦
            const height = Math.random() * TRUNK_HEIGHT;
            
            // æ ‘å¹²åŠå¾„éšé«˜åº¦å˜åŒ–
            const radiusRatio = height / TRUNK_HEIGHT;
            const radius = TRUNK_BASE_RADIUS - (TRUNK_BASE_RADIUS - TRUNK_TOP_RADIUS) * radiusRatio;
            const angle = Math.random() * Math.PI * 2;
            
            // è®¾ç½®ä½ç½®
            data.targetPosition.set(
                Math.cos(angle) * radius,
                height,
                Math.sin(angle) * radius
            );
            
            // è®¾ç½®é¢œè‰²
            const trunkColor = CONFIG.COLORS.TREE[9];
            data.color.set(trunkColor.r, trunkColor.g, trunkColor.b);
            
            // è®¾ç½®å¤§å° - å¢å¤§æ ‘å¹²ç²’å­
            data.size = CONFIG.SIZES.TRUNK_BASE + Math.random() * CONFIG.SIZES.TRUNK_VARIANCE;
        }
        
        /**
         * ç”Ÿæˆæ ‘å¶ç²’å­æ•°æ®
         */
        function generateLeafParticleData(data) {
            const { 
                LEAF_HEIGHT_RANGE, LEAF_BASE_HEIGHT, LEAF_BASE_RADIUS, 
                RIBBON_PROBABILITY, RIBBON_COUNT, RIBBON_SPIRAL_TURNS 
            } = CONFIG.TREE;
            
            // éšæœºé«˜åº¦
            let randomHeight = Math.random() * LEAF_HEIGHT_RANGE + LEAF_BASE_HEIGHT;
            
            // åœ†é”¥å½¢çŠ¶è®¡ç®—
            const heightRatio = (randomHeight - LEAF_BASE_HEIGHT) / LEAF_HEIGHT_RANGE;
            const maxRadius = LEAF_BASE_RADIUS * (1 - heightRatio);
            
            // æ˜¯å¦ç”Ÿæˆå½©å¸¦ç²’å­
            const isRibbon = Math.random() < RIBBON_PROBABILITY;
            
            let radius, angle;
            let ribbonColorIndex = -1;
            
            if (isRibbon) {
                // å½©å¸¦ç²’å­ï¼šèºæ—‹åˆ†å¸ƒ
                const ribbonIndex = Math.floor(Math.random() * RIBBON_COUNT);
                const ribbonColors = CONFIG.COLORS.RIBBON;
                ribbonColorIndex = ribbonColors[Math.floor(Math.random() * ribbonColors.length)];
                
                // å½©å¸¦èµ·å§‹é«˜åº¦è®¾ç½®ä¸ºæ¥è¿‘æ ‘å¹²é¡¶éƒ¨çš„ä½ç½®
                const ribbonStartHeight = LEAF_BASE_HEIGHT + 0.3;
                
                // ç¡®ä¿å½©å¸¦é«˜åº¦åœ¨åˆç†èŒƒå›´å†…ï¼Œä¸è¶…å‡ºæ ‘çš„åº•éƒ¨å’Œé¡¶éƒ¨
                const minRibbonHeight = Math.max(0, ribbonStartHeight);
                const maxRibbonHeight = LEAF_BASE_HEIGHT + LEAF_HEIGHT_RANGE;
                
                // å¦‚æœéšæœºé«˜åº¦ä¸åœ¨åˆç†èŒƒå›´å†…ï¼Œè°ƒæ•´åˆ°åˆç†èŒƒå›´å†…
                if (randomHeight < minRibbonHeight || randomHeight > maxRibbonHeight) {
                    randomHeight = minRibbonHeight + Math.random() * (maxRibbonHeight - minRibbonHeight);
                }
                
                // é‡æ–°è®¡ç®—é«˜åº¦æ¯”å’Œæœ€å¤§åŠå¾„ï¼Œç¡®ä¿å½©å¸¦åœ¨æ­£ç¡®ä½ç½®
                const adjustedHeightRatio = (randomHeight - LEAF_BASE_HEIGHT) / LEAF_HEIGHT_RANGE;
                const adjustedMaxRadius = LEAF_BASE_RADIUS * (1 - adjustedHeightRatio);
                
                const spiralOffset = (ribbonIndex / RIBBON_COUNT) * 2 * Math.PI;
                const spiralAngle = spiralOffset + (randomHeight - LEAF_BASE_HEIGHT) * 
                    (2 * Math.PI * RIBBON_SPIRAL_TURNS / LEAF_HEIGHT_RANGE);
                
                // æ”¹è¿›å½©å¸¦çš„èºæ—‹åˆ†å¸ƒï¼Œæ·»åŠ è½»å¾®çš„æ³¢åŠ¨ä½¿å½©å¸¦æ›´è‡ªç„¶
                const waveEffect = Math.sin(randomHeight * 0.5) * 0.05; // æ·»åŠ æ³¢æµªæ•ˆæœ
                
                // å½©å¸¦ç²’å­åªåœ¨æ ‘çš„æœ€å¤–å±‚ç”Ÿæˆï¼Œç¨å¾®å¢åŠ å®½åº¦å˜åŒ–
                radius = (adjustedMaxRadius - 0.09 + waveEffect) * (0.9 + Math.random() * 0.1);
                angle = spiralAngle + (Math.random() - 0.5) * 0.05; // å‡å°‘è§’åº¦éšæœºæ€§ï¼Œä½¿å½©å¸¦æ›´æ•´é½
                
                // è®¾ç½®å½©å¸¦ç²’å­ä½ç½®
                data.targetPosition.set(
                    Math.cos(angle) * radius,
                    randomHeight,
                    Math.sin(angle) * radius
                );
            } else {
                // æ™®é€šæ ‘å¶ç²’å­ï¼šæ›´å‡åŒ€çš„éšæœºåˆ†å¸ƒ
                // ä½¿ç”¨å‡åŒ€åˆ†å¸ƒç®—æ³•ç”ŸæˆåŠå¾„ï¼Œé¿å…ä¸­å¿ƒè¿‡äºå¯†é›†
                radius = maxRadius * Math.sqrt(Math.random());
                // ä½¿ç”¨å‡åŒ€åˆ†å¸ƒç®—æ³•ç”Ÿæˆè§’åº¦ï¼Œç¡®ä¿åœ†å‘¨åˆ†å¸ƒå‡åŒ€
                angle = Math.random() * Math.PI * 2;
                
                // æŒ‰é«˜åº¦è°ƒæ•´å¯†åº¦ - å®ç°ä¸‹å¯†ä¸Šç–æ•ˆæœï¼ˆåº•éƒ¨æ›´å¯†ï¼Œé¡¶éƒ¨æ›´ç–ï¼‰
                // åº•éƒ¨(æ¥è¿‘0)çš„å¯†åº¦å› å­æ›´å°ï¼Œé¡¶éƒ¨(æ¥è¿‘1)çš„å¯†åº¦å› å­æ›´å¤§
                const densityFactor = 0.5 + heightRatio * 1.5;
                
                // å¯†åº¦ç³»æ•°æ§åˆ¶ç²’å­ç”Ÿæˆæ¦‚ç‡ - ä½¿ç”¨ç”¨æˆ·æä¾›çš„ä»£ç æ¨¡å¼
                if (Math.random() > 0.2 * densityFactor) {
                    // ä¿ç•™ç²’å­ï¼Œè®¾ç½®ä½ç½®
                    data.targetPosition.set(
                        Math.cos(angle) * radius,
                        randomHeight,
                        Math.sin(angle) * radius
                    );
                } else {
                    // è·³è¿‡åˆ›å»ºè¯¥ç²’å­
                    data.targetPosition.set(0, 0, 0);
                    data.color.setRGB(0, 0, 0);
                    data.size = 0;
                    return;
                }
            }
            
            // è®¾ç½®é¢œè‰²
            const colorIndex = determineLeafColorIndex(isRibbon, ribbonColorIndex, heightRatio);
            const color = CONFIG.COLORS.TREE[colorIndex];
            
            // åº”ç”¨é˜´å½±æ•ˆæœï¼ˆä»…æ™®é€šæ ‘å¶ï¼‰- è°ƒäº®
            if (!isRibbon) {
                const shadowFactor = CONFIG.BRIGHTNESS.TRUNK_SHADOW_BASE + heightRatio * CONFIG.BRIGHTNESS.TRUNK_SHADOW_HEIGHT_FACTOR;
                data.color.setRGB(color.r * shadowFactor, color.g * shadowFactor, color.b * shadowFactor);
            } else {
                // å½©å¸¦ä¹Ÿç¨å¾®è°ƒäº®
                const brightness = CONFIG.BRIGHTNESS.RIBBON_BRIGHTNESS_MULTIPLIER;
                data.color.setRGB(color.r * brightness, color.g * brightness, color.b * brightness);
            }
            
            // è®¾ç½®å¤§å° - å¢å¤§æ ‘å¶ç²’å­
            const sizeFactor = heightRatio > 0.8 ? CONFIG.SIZES.TOP_SIZE_FACTOR : CONFIG.SIZES.NORMAL_SIZE_FACTOR;
            const ribbonSizeFactor = isRibbon ? CONFIG.SIZES.RIBBON_MULTIPLIER : 1.0;
            data.size = (CONFIG.SIZES.LEAF_BASE + Math.random() * CONFIG.SIZES.LEAF_VARIANCE) * 
                       sizeFactor * ribbonSizeFactor * 
                       (CONFIG.SIZES.SIZE_VARIANCE_BASE + Math.random() * CONFIG.SIZES.SIZE_VARIANCE_RANGE);
        }
        
        /**
         * åˆ›å»ºåœ£è¯æ ‘
         */
        function createChristmasTree(scene) { // åœ£è¯æ ‘åˆ›å»ºå‡½æ•°å¼€å§‹
            
            // åˆ›å»ºç²’å­ç³»ç»Ÿï¼ˆæ‰¹å¤„ç†ç‰ˆæœ¬ï¼‰
            const particleBatches = createTreeParticlesBatched(); // è°ƒç”¨æ‰¹æ¬¡ç²’å­åˆ›å»ºå‡½æ•°
            
            // åˆ›å»ºæ ‘çš„æ ¹å®¹å™¨
            const treeGroup = new THREE.Group(); // åˆ›å»º3Dç»„å¯¹è±¡ä½œä¸ºæ ‘çš„æ ¹å®¹å™¨
            
            // æ·»åŠ æ‰€æœ‰æ‰¹æ¬¡åˆ°æ ‘ç»„ï¼ˆæ¯ä¸ªæ‰¹æ¬¡æ˜¯ä¸€ä¸ªPointså¯¹è±¡ï¼‰
            particleBatches.forEach(batch => { // éå†æ‰€æœ‰ç²’å­æ‰¹æ¬¡
                treeGroup.add(batch); // å°†æ‰¹æ¬¡æ·»åŠ åˆ°æ ‘ç»„ä¸­
            }); // éå†ç»“æŸ
            scene.add(treeGroup); // å°†æ ‘ç»„æ·»åŠ åˆ°åœºæ™¯ä¸­
            
            // æ·»åŠ å½©è‰²è£…é¥°ç¯
            const coloredLightObjects = addColoredLights(treeGroup); // è°ƒç”¨å½©è‰²ç¯å…‰æ·»åŠ å‡½æ•°
            
            // è®¾ç½®æ ‘çš„ä½ç½®å’Œç¼©æ”¾
            treeGroup.position.copy(CONFIG.TREE.POSITION_OFFSET); // è®¾ç½®æ ‘çš„ä½ç½®åç§»
            treeGroup.scale.copy(CONFIG.TREE.SCALE); // è®¾ç½®æ ‘çš„ç¼©æ”¾æ¯”ä¾‹
            treeGroup.updateMatrixWorld(true); // æ›´æ–°ä¸–ç•ŒçŸ©é˜µ
            
            // åˆå§‹åŒ–åŠ¨ç”»çŠ¶æ€
            const animationState = { // åˆ›å»ºåŠ¨ç”»çŠ¶æ€å¯¹è±¡
                startTime: Date.now(), // è®°å½•å¼€å§‹æ—¶é—´
                completed: false, // åŠ¨ç”»æ˜¯å¦å®Œæˆæ ‡è®°
                isRotating: false, // æ—‹è½¬çŠ¶æ€æ ‡è®°
                snowStarted: false, // é›ªèŠ±æ˜¯å¦å¼€å§‹æ ‡è®°
                snowStartTime: 0, // é›ªèŠ±å¼€å§‹æ—¶é—´æˆ³
                treeCompleted: false // æ ‘æ˜¯å¦å®Œå…¨æˆå‹æ ‡è®°
            }; // animationStateå¯¹è±¡å®šä¹‰ç»“æŸ
            
            return { // è¿”å›åˆ›å»ºçš„åœ£è¯æ ‘ç›¸å…³å¯¹è±¡
                treeGroup, // æ ‘ç»„
                particleBatches, // ç²’å­æ‰¹æ¬¡
                coloredLightObjects, // å½©è‰²ç¯å…‰
                animationState // åŠ¨ç”»çŠ¶æ€
            }; // returnè¯­å¥ç»“æŸ
        } // createChristmasTreeå‡½æ•°ç»“æŸ
        
        

        
        
        /**
         * ç¡®å®šæ ‘å¶é¢œè‰²ç´¢å¼•
         */
        function determineLeafColorIndex(isRibbon, ribbonColorIndex, heightRatio) {
            if (isRibbon && ribbonColorIndex !== -1) {
                return ribbonColorIndex;
            }
            
            // æ™®é€šæ ‘å¶ç²’å­é¢œè‰²
            const rand = Math.random();
            if (rand < 0.97) {
                return Math.floor(Math.random() * 4); // é€‰æ‹©å‰4ç§æ·±ç»¿/å†·ç»¿é¢œè‰²
            } else {
                return 7 + Math.floor(Math.random() * 2); // é€‰æ‹©é«˜å…‰é¢œè‰²
            }
        }
        
        /**
         * æ·»åŠ å½©è‰²è£…é¥°ç¯
         */
        function addColoredLights(treeGroup) {
            const coloredLightObjects = [];
            
            CONFIG.LIGHTS.forEach((lightConfig, index) => {
                const coloredLight = new THREE.PointLight(
                    lightConfig.color, 
                    lightConfig.intensity, 
                    lightConfig.distance
                );
                
                // éšæœºä½ç½®
                const angle = (index / CONFIG.LIGHTS.length) * Math.PI * 2;
                const radius = 3 + Math.random() * 2;
                coloredLight.position.set(
                    Math.cos(angle) * radius,
                    5 + Math.random() * 5,
                    Math.sin(angle) * radius
                );
                
                treeGroup.add(coloredLight);
                coloredLightObjects.push(coloredLight);
            });
            
            return coloredLightObjects;
        }
        
        /**
         * åˆå§‹åŒ–ç›¸æœºæ§åˆ¶å‚æ•°
         */
        function initCameraControls(camera) {
            const cameraDistance = camera.position.distanceTo(CONFIG.CAMERA.TARGET);
            
            return {
                rotationX: THREE.MathUtils.degToRad(0),
                rotationY: THREE.MathUtils.degToRad(0),
                distance: cameraDistance
            };
        }
        
        /**
         * æ›´æ–°æ‰¹æ¬¡å¯è§æ€§
         */
        function updateBatchVisibility(batches, startTime) {
            const elapsed = Date.now() - startTime;
            const interval = CONFIG.ANIMATION_PHASES.BATCH_PROCESSING_INTERVAL;
            const visibleCount = Math.floor(elapsed / interval);
            
            for (let i = 0; i < batches.length; i++) {
                if (i <= visibleCount && !batches[i].userData.startTime) {
                    batches[i].visible = true;
                    batches[i].userData.startTime = Date.now();
                }
            }
        }
        


        /**
         * æ£€æŸ¥æ ‘æ˜¯å¦å®Œå…¨æ±‡èšå®Œæˆ
         */
        function checkTreeCompletion(batches, animationState) {
            const allBatchesCompleted = batches.every(batch => 
                batch.visible && batch.userData.starPhase >= 2
            );
            if (allBatchesCompleted && !animationState.treeCompleted) {
                animationState.treeCompleted = true;
                console.log('ğŸ‰ æ‰€æœ‰ç²’å­å·²å®Œæˆæ±‡èšï¼æ ‘å½¢æˆé˜¶æ®µå¼€å§‹ï¼');
                return true;
            }
            return false;
        }

        /**
         * æ›´æ–°æ‰¹æ¬¡ç§»åŠ¨åŠ¨ç”» - ä½¿ç”¨ç»Ÿä¸€çš„æ—¶åºè®¡ç®—
         */
        function updateBatchMovement(batches, animationStartTime, animationState) {
            const now = Date.now();
            const elapsed = now - animationStartTime; // ç›¸å¯¹äºåŠ¨ç”»å¼€å§‹çš„è€—æ—¶
            
            // ğŸ”„ å¸§è®¡æ•°å™¨è°ƒè¯•
            if (!updateBatchMovement.frameCount) {
                updateBatchMovement.frameCount = 0;
            }
            updateBatchMovement.frameCount++;
            
            // æ¯100å¸§æ‰“å°ä¸€æ¬¡
            if (updateBatchMovement.frameCount % 100 === 0) {
                console.log(`ğŸ”„ ç¬¬${updateBatchMovement.frameCount}å¸§ï¼Œè€—æ—¶${(elapsed/1000).toFixed(2)}s`);
            }
            
            // è®¡ç®—å…³é”®æ—¶é—´ç‚¹ - ä»…ç”¨äºç²’å­å‡ºç°å’Œæ˜Ÿå½¢é—ªè€€é˜¶æ®µçš„æ—¶é—´æ§åˆ¶
            const { totalBatches, appearDuration } = calculateBatchTiming();
    
    const particlesAppearEnd = appearDuration;
    const sparkleEnd = particlesAppearEnd + CONFIG.ANIMATION_PHASES.SPARKLE_DURATION;
    
    // æ£€æŸ¥æ ‘æ˜¯å¦å®Œå…¨æ±‡èšå®Œæˆ
    checkTreeCompletion(batches, animationParams?.animationState);
            
            // ğŸ” çŠ¶æ€è°ƒè¯• - æ‰“å°å…³é”®çŠ¶æ€ä¿¡æ¯
            if (Math.random() < 0.001) { // 0.1%æ¦‚ç‡æ‰“å°ï¼Œé¿å…åˆ·å±
                console.log(`â±ï¸ çŠ¶æ€è¯¦æƒ…:`);
                console.log(`   å½“å‰æ€»è€—æ—¶: ${(elapsed/1000).toFixed(2)}s`);
                console.log(`   ç²’å­å‡ºç°ç»“æŸ: ${(particlesAppearEnd/1000).toFixed(2)}s`);
                console.log(`   æ˜Ÿå½¢é—ªè€€ç»“æŸ: ${(sparkleEnd/1000).toFixed(2)}s`);
                console.log(`   æ ‘æ±‡èšå®Œæˆ: ${animationParams?.animationState?.treeCompleted ? 'âœ… æ˜¯' : 'âŒ å¦'}`);
                
                const currentPhase = elapsed < particlesAppearEnd ? 'ç²’å­å‡ºç°' :
                                   elapsed < sparkleEnd ? 'æ˜Ÿå½¢é—ªè€€' :
                                   animationParams?.animationState?.treeCompleted ? 'æ ‘å½¢æˆ' : 'è¿‡æ¸¡æ±‡èš';
                console.log(`   å½“å‰åº”è¯¥å¤„äº: ${currentPhase}`);
            }
            
            // ğŸ•’ å…¨å±€çŠ¶æ€ç›‘æ§ - æ¯ç§’æ˜¾ç¤ºä¸€æ¬¡è¿›åº¦
            const currentSecond = Math.floor(elapsed / 1000);
            if (elapsed < 1000 || currentSecond !== Math.floor((elapsed - 16.67) / 1000)) {
                console.log(`â° ã€${currentSecond}ç§’ã€‘å…¨å±€çŠ¶æ€:`);
                console.log(`   æ€»è€—æ—¶: ${elapsed}ms`);
                console.log(`   sparkleEnd: ${sparkleEnd}ms`);
                console.log(`   æ ‘æ±‡èšå®Œæˆ: ${animationParams?.animationState?.treeCompleted ? 'âœ… æ˜¯' : 'âŒ å¦'}`);
                console.log(`   å½“å‰é˜¶æ®µ: ${elapsed < sparkleEnd ? 'æ˜Ÿå½¢é—ªè€€' : animationParams?.animationState?.treeCompleted ? 'æ ‘å½¢æˆ' : 'è¿‡æ¸¡æ±‡èš'}`);
                console.log('---');
            }
            
            batches.forEach((points, batchIndex) => {
                const time = Date.now() * 0.001;
                const batchAppearTime = animationStartTime + batchIndex * CONFIG.ANIMATION_PHASES.BATCH_PROCESSING_INTERVAL;
                const elapsedSinceAppear = now - batchAppearTime;
                
                if (elapsedSinceAppear <= 0) {
                    // æ‰¹æ¬¡è¿˜æœªå‡ºç°ï¼Œä¿æŒé€æ˜
                    points.material.opacity = 0;
                    return;
                }
                
                // ğŸ” æ‰¹æ¬¡çº§åˆ«çš„çŠ¶æ€åˆ¤æ–­
                const batchPhase = elapsed < particlesAppearEnd ? 'ç²’å­å‡ºç°' :
                                 elapsed < sparkleEnd ? 'æ˜Ÿå½¢é—ªè€€' :
                                 animationParams?.animationState?.treeCompleted ? 'æ ‘å½¢æˆ' : 'è¿‡æ¸¡æ±‡èš';
                
                if (batchPhase === 'è¿‡æ¸¡æ±‡èš' && Math.random() < 0.01) {
                    console.log(`ğŸ¯ æ‰¹æ¬¡${batchIndex}è¿›å…¥è¿‡æ¸¡æ±‡èšé˜¶æ®µ`);
                }
                

                
                const geometry = points.geometry;
                const positions = geometry.attributes.position.array;
                const targetPositions = geometry.attributes.targetPosition.array;
                
                // ğŸŒŸ æ ¹æ®å½“å‰æ—¶é—´æ‰§è¡Œç›¸åº”çš„åŠ¨ç”»é˜¶æ®µ
                if (elapsed < particlesAppearEnd) {
                    // é˜¶æ®µ0ï¼šç²’å­å‡ºç°é˜¶æ®µ
                    for (let i = 0; i < positions.length; i += 3) {
                        // ç›´æ¥ä½¿ç”¨åŸå§‹ä½ç½®ï¼Œä¿æŒé™æ€
                        positions[i] = points.userData.originalPositions[i];
                        positions[i + 1] = points.userData.originalPositions[i + 1];
                        positions[i + 2] = points.userData.originalPositions[i + 2];
                    }
                    geometry.attributes.position.needsUpdate = true;
                    
                    // â­ ç²’å­å‡ºç°é˜¶æ®µçš„å¤§å°æ§åˆ¶
                    const sizes = geometry.attributes.size.array;
                    const baseSizes = geometry.attributes.baseSize.array;
                    const starSizes = geometry.attributes.starSize.array;
                    
                    // ç²’å­å‡ºç°é˜¶æ®µä½¿ç”¨è¾ƒä½çš„é¢‘ç‡å’Œå¹…åº¦ï¼Œä¿æŒå¹³æ»‘æ•ˆæœ
                    const sparkle = 1 + Math.sin(time * 3.0 + batchIndex) * 0.3;
                    const convergeBrightness = THREE.MathUtils.clamp(elapsedSinceAppear / CONFIG.TIMING.APPEAR_DURATION, 0, 1);
                    
                    for (let i = 0; i < sizes.length; i++) {
                        sizes[i] = baseSizes[i] * starSizes[i] * sparkle;
                    }
                    geometry.attributes.size.needsUpdate = true;
                    
                    // æœ€ç»ˆé€æ˜åº¦è®¾ç½®
                    points.material.opacity = sparkle * convergeBrightness;
                    return; // æå‰è¿”å›ï¼Œé¿å…åç»­ä»£ç è¦†ç›–
                    
                } else if (elapsed < sparkleEnd) {
                    // é˜¶æ®µ1ï¼šæ˜Ÿå½¢é—ªè€€é˜¶æ®µ
                    if (batchIndex === 0 && Math.random() < 0.01) {
                        console.log(`â­ é˜¶æ®µ1: æ˜Ÿå½¢é—ªè€€ - æ‰¹æ¬¡${batchIndex}, ${elapsed}ms < ${sparkleEnd}ms`);
                    }
                    for (let i = 0; i < positions.length; i += 3) {
                        // ç›´æ¥ä½¿ç”¨åŸå§‹ä½ç½®ï¼Œä¿æŒé™æ€
                        positions[i] = points.userData.originalPositions[i];
                        positions[i + 1] = points.userData.originalPositions[i + 1];
                        positions[i + 2] = points.userData.originalPositions[i + 2];
                    }
                    geometry.attributes.position.needsUpdate = true;
                    
                    // â­ æ˜Ÿå½¢é—ªè€€é˜¶æ®µçš„å¤§å°æ§åˆ¶
                    const sizes = geometry.attributes.size.array;
                    const baseSizes = geometry.attributes.baseSize.array;
                    const starSizes = geometry.attributes.starSize.array;
                    
                    // ä½¿ç”¨é˜¶è·ƒå‡½æ•°åˆ›å»ºå¼ºçƒˆçš„é¢‘é—ªæ•ˆæœ
                    const sineValue = Math.sin(time * CONFIG.BRIGHTNESS.SPARKLE_FREQUENCY_INITIAL + batchIndex);
                    const isBright = sineValue > 0;
                    const sparkle = isBright ? (CONFIG.BRIGHTNESS.SPARKLE_BASE_INITIAL + CONFIG.BRIGHTNESS.SPARKLE_AMPLITUDE_INITIAL) : 0.4;
                    
                    for (let i = 0; i < sizes.length; i++) {
                        sizes[i] = baseSizes[i] * starSizes[i] * sparkle;
                    }
                    geometry.attributes.size.needsUpdate = true;
                    
                    // æœ€ç»ˆé€æ˜åº¦è®¾ç½® - å¢å¼ºäº®åº¦
                    points.material.opacity = sparkle * 1.2;
                    return; // æå‰è¿”å›ï¼Œé¿å…åç»­ä»£ç è¦†ç›–
                    
                } else if (!animationState.treeCompleted) {
                    // é˜¶æ®µ2ï¼šè¿‡æ¸¡æ±‡èšé˜¶æ®µ - è¿™æ˜¯ä»æ˜Ÿå½¢åˆ°æ ‘å½¢çš„å…³é”®åŠ¨ç”»ï¼
                    
                    // ğŸ” æ±‡èšé˜¶æ®µå¼€å§‹æ—¥å¿—
                    if (batchIndex === 0 && Math.random() < 0.2) {
                        console.log(`ğŸ¯ âœ¨âœ¨âœ¨ è¿›å…¥è¿‡æ¸¡æ±‡èšé˜¶æ®µï¼ âœ¨âœ¨âœ¨`);
                        console.log(`   å½“å‰æ€»è€—æ—¶: ${elapsed}ms`);
                        console.log(`   sparkleEnd: ${sparkleEnd}ms`);
                    }
                    
                    const waveAmplitude = 0.1; // è½¨è¿¹æ³¢åŠ¨å¹…åº¦
                    const waveFrequency = 2.0; // è½¨è¿¹æ³¢åŠ¨é¢‘ç‡
                    let totalDistance = 0;
                    let maxDistance = 0;
                    let allParticlesNearTarget = true;
                    
                    // è®¡ç®—å½“å‰ç²’å­åˆ°ç›®æ ‡çš„è·ç¦»ï¼Œç”¨äºè¿›åº¦è®¡ç®—
                    for (let i = 0; i < positions.length; i += 3) {
                        const distance = Math.sqrt(
                            Math.pow(positions[i] - targetPositions[i], 2) +
                            Math.pow(positions[i + 1] - targetPositions[i + 1], 2) +
                            Math.pow(positions[i + 2] - targetPositions[i + 2], 2)
                        );
                        totalDistance += distance;
                        if (distance > maxDistance) maxDistance = distance;
                        if (distance > 0.01) allParticlesNearTarget = false;
                    }
                    
                    // è®¡ç®—å¹³å‡è·ç¦»å’Œè¿›åº¦ï¼ˆç”¨äºè§†è§‰æ•ˆæœï¼‰
                    const avgDistance = totalDistance / (positions.length / 3);
                    let progress = 1.0;
                    
                    if (maxDistance > 0.01) {
                        // åŸºäºæœ€å¤§è·ç¦»è®¡ç®—è¿›åº¦ï¼ˆ0=å¼€å§‹ï¼Œ1=å®Œæˆï¼‰
                        progress = 1.0 - (avgDistance / maxDistance);
                        if (progress < 0) progress = 0;
                    }
                    
                    // ğŸ”¥ å…³é”®ï¼šåŸºäºè¿›åº¦çš„åŠ¨æ€é€Ÿåº¦æ§åˆ¶ - å®ç°ä»æ…¢åˆ°å¿«çš„æ±‡èšæ•ˆæœ
                    // æ³¨æ„ï¼šè¿™æ®µä»£ç å¿…é¡»æ”¾åœ¨progresså˜é‡è®¡ç®—ä¹‹å
                    const baseSpeed = 0.004; // åˆå§‹æœ€å°é€Ÿåº¦
                    const maxSpeed = 0.02; // æœ€å¤§é€Ÿåº¦
                    // ä½¿ç”¨easeInQuadç¼“åŠ¨å‡½æ•°ï¼Œä½¿é€Ÿåº¦ä»æ…¢åˆ°å¿«å¹³æ»‘å¢åŠ 
                    const speedProgress = progress * progress; // easeInQuadæ•ˆæœ
                    // åŠ¨æ€è®¡ç®—æ¯å¸§ç§»åŠ¨é€Ÿåº¦
                    const moveSpeedPerFrame = baseSpeed + (maxSpeed - baseSpeed) * speedProgress;
                    
                    // ğŸŒŠ åŸºäºé€Ÿåº¦çš„ç§»åŠ¨ - æ·»åŠ ç¼“åŠ¨å’Œè½¨è¿¹å˜åŒ–
                    for (let i = 0; i < positions.length; i += 3) {
                        const targetX = targetPositions[i]; // æ ‘å½¢ç›®æ ‡ä½ç½®
                        const targetY = targetPositions[i + 1];
                        const targetZ = targetPositions[i + 2];
                        
                        // è®¡ç®—ç²’å­åˆ°ç›®æ ‡çš„å‘é‡
                        const dx = targetX - positions[i];
                        const dy = targetY - positions[i + 1];
                        const dz = targetZ - positions[i + 2];
                        
                        // è®¡ç®—å½“å‰ç²’å­çš„è·ç¦»
                        const currentDistance = Math.sqrt(dx * dx + dy * dy + dz * dz);
                        
                        // æ·»åŠ ç¼“åŠ¨æ•ˆæœ - ä½¿ç”¨easeOutCubicæ›²çº¿
                        const easeProgress = 1 - Math.pow(1 - progress, 3);
                        
                        // åŸºäºç²’å­ç´¢å¼•æ·»åŠ å¾®å°çš„æ³¢åŠ¨æ•ˆæœï¼Œä½¿è½¨è¿¹æ›´ä¸°å¯Œ
                        const waveOffset = Math.sin(i * 0.01 + time * waveFrequency) * waveAmplitude;
                        
                        // è®¡ç®—ç§»åŠ¨å‘é‡ï¼Œæ·»åŠ æ³¢åŠ¨æ•ˆæœ
                        const moveX = dx * moveSpeedPerFrame + waveOffset * dz * 0.1;
                        const moveY = dy * moveSpeedPerFrame * (0.8 + 0.2 * easeProgress); // Yè½´ç¨å¿«
                        const moveZ = dz * moveSpeedPerFrame + waveOffset * dx * 0.1;
                        
                        // åº”ç”¨ç§»åŠ¨
                        positions[i] += moveX;
                        positions[i + 1] += moveY;
                        positions[i + 2] += moveZ;
                    }
                    
                    
                    // ğŸ” æ±‡èšå®ŒæˆéªŒè¯ï¼šå½“æ‰€æœ‰ç²’å­æ¥è¿‘ç›®æ ‡æ—¶æ ‡è®°å®Œæˆ
                    if (allParticlesNearTarget) {
                        points.userData.starPhase = 2; // æ ‡è®°æ‰¹æ¬¡å®Œæˆ
                        if (batchIndex === 0) {
                            console.log('âœ… è¯¥æ‰¹æ¬¡ç²’å­å·²å®Œæˆæ±‡èšï¼');
                        }
                    }
                    
                    // ğŸ” ä½ç½®è°ƒè¯•ï¼šæ£€æŸ¥ç¬¬ä¸€ä¸ªç²’å­çš„å®é™…ä½ç½®å˜åŒ–  
                    if (batchIndex === 0) { // æ€»æ˜¯æ£€æŸ¥ç¬¬ä¸€æ‰¹ç²’å­ï¼Œä¾¿äºè§‚å¯Ÿ
                        const start = {
                            x: points.userData.originalPositions[0],
                            y: points.userData.originalPositions[1], 
                            z: points.userData.originalPositions[2]
                        };
                        const target = {
                            x: targetPositions[0],
                            y: targetPositions[1],
                            z: targetPositions[2]
                        };
                        const current = {
                            x: positions[0],
                            y: positions[1],
                            z: positions[2]
                        };
                        console.log(`ğŸ¯ ç²’å­ä½ç½®è¿½è¸ª:`);
                        console.log(`   èµ·å§‹(æ˜Ÿå½¢): (${start.x.toFixed(2)}, ${start.y.toFixed(2)}, ${start.z.toFixed(2)})`);
                        console.log(`   ç›®æ ‡(æ ‘å½¢): (${target.x.toFixed(2)}, ${target.y.toFixed(2)}, ${target.z.toFixed(2)})`);
                        console.log(`   å½“å‰ä½ç½®:   (${current.x.toFixed(2)}, ${current.y.toFixed(2)}, ${current.z.toFixed(2)})`);
                        console.log(`   æ±‡èšè¿›åº¦: ${progress.toFixed(3)} (${(progress*100).toFixed(1)}%)`);
                    }
                    
                    geometry.attributes.position.needsUpdate = true;
                    
                    // â­ è¿‡æ¸¡é˜¶æ®µçš„å¤§å°å˜åŒ–ï¼šä»æ˜Ÿå½¢å¤§å°è¿‡æ¸¡åˆ°æ ‘å½¢å¤§å° - æ”¹è¿›ç¼“åŠ¨æ•ˆæœ
                    const sizes = geometry.attributes.size.array;
                    const baseSizes = geometry.attributes.baseSize.array;
                    
                    // ä½¿ç”¨easeOutElasticç¼“åŠ¨å‡½æ•°ï¼Œåˆ›å»ºå¼¹æ€§æ•ˆæœ
                    const elasticProgress = 1 - Math.pow(2, -10 * progress) * Math.sin((progress * 10 - 0.75) * (2 * Math.PI) / 3);
                    
                    // ç»“åˆå¤šç§ç¼“åŠ¨æ•ˆæœï¼Œä½¿å¤§å°å˜åŒ–æ›´è‡ªç„¶
                    const combinedProgress = THREE.MathUtils.lerp(progress, elasticProgress, 0.3);
                    
                    const scale = THREE.MathUtils.lerp(
                        CONFIG.ANIMATION_PHASES.INITIAL_SIZE_MULTIPLIER, // åˆå§‹æ˜Ÿå½¢å¤§å°å€æ•°
                        CONFIG.ANIMATION_PHASES.FINAL_SIZE_MULTIPLIER,    // æœ€ç»ˆæ ‘å½¢å¤§å°å€æ•°
                        combinedProgress // åŸºäºæ”¹è¿›çš„è¿›åº¦ç¼“åŠ¨
                    );
                    
                    // ä¸ºæ¯ä¸ªç²’å­æ·»åŠ ç‹¬ç‰¹çš„è„‰åŠ¨æ•ˆæœï¼Œå¢å¼ºèˆåŠ¨æ„Ÿ
                    for (let i = 0; i < sizes.length; i++) {
                        const particleId = i;
                        // ä¸ºæ¯ä¸ªç²’å­åˆ›å»ºç‹¬ç‰¹çš„è„‰åŠ¨é¢‘ç‡å’Œå¹…åº¦
                        const particlePulse = 1 + Math.sin(time * 8 + particleId * 0.1) * 0.1 * (1 - progress);
                        // ç»“åˆç»Ÿä¸€è„‰åŠ¨å’Œç²’å­ç‹¬ç‰¹è„‰åŠ¨
                        const combinedPulse = 1 + Math.sin(time * 8) * 0.05 * (1 - progress) * particlePulse;
                        sizes[i] = baseSizes[i] * scale * combinedPulse;
                    }
                    geometry.attributes.size.needsUpdate = true;
                    
                    // ğŸŠ å¢å¼ºè¿‡æ¸¡é˜¶æ®µçš„é—ªçƒæ•ˆæœï¼Œä¸ºæ¯ä¸ªæ‰¹æ¬¡æ·»åŠ ç‹¬ç‰¹çš„èˆåŠ¨å…‰æ•ˆ
                    const baseSparkle = CONFIG.BRIGHTNESS.SPARKLE_BASE_INITIAL;
                    const batchSparkle = Math.sin(time * CONFIG.BRIGHTNESS.SPARKLE_FREQUENCY_INITIAL + batchIndex) * CONFIG.BRIGHTNESS.SPARKLE_AMPLITUDE_INITIAL;
                    // æ·»åŠ é¢å¤–çš„èˆåŠ¨å…‰æ•ˆï¼Œå¢å¼ºèŠ‚å¥æ„Ÿ
                    const danceSparkle = Math.cos(time * 5 + batchIndex * 2) * 0.2 * (1 - progress);
                    const sparkle = baseSparkle + batchSparkle + danceSparkle;
                    
 // ä»…åœ¨è¿‡æ¸¡ä¸­æ›´æ–°ä¸ºè¿›åº¦å€¼
                    
                    // ğŸ“º çŠ¶æ€æ˜¾ç¤ºï¼šæ¯1ç§’æ˜¾ç¤ºä¸€æ¬¡å½“å‰çŠ¶æ€ï¼ˆä»…åœ¨ç¬¬ä¸€ç»„ç²’å­ï¼‰
                    if (batchIndex === 0 && Math.floor(elapsed / 1000) !== Math.floor((elapsed - 16.67) / 1000)) {
                        console.log(`ğŸ¯ ã€${Math.floor(elapsed/1000)}ç§’ã€‘æ±‡èšè¯¦æƒ…:`);
                        console.log(`   æ€»è€—æ—¶: ${(elapsed/1000).toFixed(2)}s`);
                        console.log(`   å¹³å‡è·ç¦»: ${avgDistance.toFixed(3)}`);
                        console.log(`   æœ€å¤§è·ç¦»: ${maxDistance.toFixed(3)}`);
                        console.log(`   æ±‡èšè¿›åº¦: ${(progress*100).toFixed(1)}%`);
                        console.log(`   æ‰€æœ‰ç²’å­æ¥è¿‘ç›®æ ‡: ${allParticlesNearTarget}`);
                    }
                    
                    // æœ€ç»ˆé€æ˜åº¦è®¾ç½®ï¼Œä½¿é—ªçƒæ›´å…·åŠ¨æ„Ÿ
                    points.material.opacity = sparkle * 1.0;
                    return; // æå‰è¿”å›ï¼Œé¿å…åç»­ä»£ç è¦†ç›–
                    
                } else if (animationState.treeCompleted) {
                    // é˜¶æ®µ3ï¼šæ ‘å½¢æˆå®Œæˆ - è¿‡æ¸¡é˜¶æ®µå·²å®Œæˆï¼Œç²’å­åº”è¯¥åœ¨ç›®æ ‡ä½ç½®
                    // ğŸš¨ é‡è¦ï¼šä¸è¦å¼ºåˆ¶ç§»åŠ¨ä½ç½®ï¼Œä¿æŒè¿‡æ¸¡é˜¶æ®µçš„ç»“æœ
                    if (batchIndex === 0) {
                        console.log(`ğŸŒ³ è¿›å…¥æ ‘å½¢æˆé˜¶æ®µ - ä¿æŒå½“å‰ç²’å­ä½ç½®`);
                        
                        // æ£€æŸ¥ç²’å­æ˜¯å¦æ¥è¿‘ç›®æ ‡ä½ç½®
                        const avgDistance = (() => {
                            let totalDistance = 0;
                            let count = 0;
                            for (let i = 0; i < Math.min(30, positions.length); i += 3) { // åªæ£€æŸ¥å‰10ä¸ªç²’å­
                                const distance = Math.sqrt(
                                    Math.pow(positions[i] - targetPositions[i], 2) +
                                    Math.pow(positions[i + 1] - targetPositions[i + 1], 2) +
                                    Math.pow(positions[i + 2] - targetPositions[i + 2], 2)
                                );
                                totalDistance += distance;
                                count++;
                            }
                            return totalDistance / count;
                        })();
                        
                        console.log(`   ç²’å­å¹³å‡è·ç¦»ç›®æ ‡: ${avgDistance.toFixed(3)} å•ä½`);
                        if (avgDistance < 0.1) {
                            console.log(`   âœ… æ±‡èšæ•ˆæœè‰¯å¥½ï¼Œç²’å­å·²æ¥è¿‘ç›®æ ‡ä½ç½®`);
                        } else {
                            console.log(`   âš ï¸ ç²’å­è·ç¦»ç›®æ ‡è¾ƒè¿œï¼Œå¯èƒ½éœ€è¦æ›´å¤šæ—¶é—´æ±‡èš`);
                        }
                    }
                    
                    // ğŸš¨ ä¸å¼ºåˆ¶ä¿®æ”¹ä½ç½®ï¼ä¿æŒè¿‡æ¸¡é˜¶æ®µçš„æœ€ç»ˆç»“æœ
                    
                    // â­ æœ€ç»ˆé˜¶æ®µçš„å¤§å°æ§åˆ¶ï¼šæ¢å¤åˆ°æ­£å¸¸çš„æ ‘å½¢å¤§å°
                    const sizes = geometry.attributes.size.array;
                    const baseSizes = geometry.attributes.baseSize.array;
                    
                    for (let i = 0; i < sizes.length; i++) {
                        sizes[i] = baseSizes[i]; // ä½¿ç”¨åŸºç¡€å¤§å°ï¼Œä¸å†æ”¾å¤§
                    }
                    geometry.attributes.size.needsUpdate = true;
                    
                    // ğŸ„ æ ‘å½¢æˆé˜¶æ®µçš„é—ªçƒæ•ˆæœï¼šä½¿ç”¨æœ€ç»ˆé—ªçƒå‚æ•°
                    const sparkle = CONFIG.BRIGHTNESS.SPARKLE_BASE_FINAL + Math.sin(time * CONFIG.BRIGHTNESS.SPARKLE_FREQUENCY_FINAL + batchIndex) * CONFIG.BRIGHTNESS.SPARKLE_AMPLITUDE_FINAL;
                    
                    points.userData.starPhase = 2; // æ ‡è®°ä¸ºå®Œå…¨å½¢æˆçš„æ ‘
                    
                    // æ ‘å½¢æˆé˜¶æ®µä¿æŒç²’å­åŸå§‹é¢œè‰²ï¼ˆæ ‘è®¾è®¡çš„é¢œè‰²ï¼‰
                    
                    // æœ€ç»ˆé€æ˜åº¦è®¾ç½®
                    points.material.opacity = sparkle * 1.0;
                }
            });
        }
        
        /**
         * åŠ¨ç”»å¾ªç¯
         */
        function animate() { // åŠ¨ç”»ä¸»å¾ªç¯å‡½æ•°
            
            requestAnimationFrame(animate);
            
            if (particlesStarted && animationParams) {
                const { // è§£æ„è·å–åŠ¨ç”»å‚æ•°å¯¹è±¡ä¸­çš„æ‰€æœ‰å¿…è¦ç»„ä»¶
                    scene, // 3Dåœºæ™¯
                    camera, // ç›¸æœº
                    renderer, // æ¸²æŸ“å™¨
                    snowSystem, // é›ªèŠ±ç³»ç»Ÿ
                    treeGroup, // æ ‘ç»„
                    particleBatches, // ç²’å­æ‰¹æ¬¡
                    coloredLightObjects, // å½©è‰²ç¯å…‰
                    cameraControls, // ç›¸æœºæ§åˆ¶
                    animationState // åŠ¨ç”»çŠ¶æ€
                } = animationParams; // è§£æ„èµ‹å€¼ç»“æŸ
                
                // è·å–å½“å‰æ—¶é—´
                const time = Date.now() * 0.001; // è·å–å½“å‰æ—¶é—´ï¼ˆè½¬æ¢ä¸ºç§’ï¼‰
                
                // æ›´æ–°æ‰¹æ¬¡å¯è§æ€§
                updateBatchVisibility(particleBatches, animationState.startTime); // æ›´æ–°ç²’å­æ‰¹æ¬¡æ˜¾ç¤ºçŠ¶æ€
                updateBatchMovement(particleBatches, animationState.startTime, animationState); // æ›´æ–°ç²’å­ç§»åŠ¨åŠ¨ç”»
                
                // åº”ç”¨æ ‘çš„å€¾æ–œï¼ˆå§‹ç»ˆåº”ç”¨ï¼‰
                treeGroup.rotation.x = CONFIG.TREE.TILT_X;
                
                // åœ£è¯æ ‘æ—‹è½¬é€»è¾‘ - åŸºäºç²’å­æ±‡èšçŠ¶æ€
                const now = Date.now();
                const elapsed = now - animationState.startTime;
                
                // è®¡ç®—å…³é”®æ—¶é—´ç‚¹ - ç”¨äºåˆå§‹é˜¶æ®µåˆ¤æ–­
                const { totalBatches, appearDuration } = calculateBatchTiming();
                
                const particlesAppearEnd = appearDuration;
                const sparkleEnd = particlesAppearEnd + CONFIG.ANIMATION_PHASES.SPARKLE_DURATION;
                
                // ğŸ„ ç»Ÿä¸€æ—‹è½¬é€Ÿåº¦ï¼šåœ¨æ•´ä¸ªåŠ¨ç”»è¿‡ç¨‹ä¸­ä½¿ç”¨æ­£å¸¸æ—‹è½¬é€Ÿåº¦
                if (elapsed >= sparkleEnd) {
                    // ä»æ˜Ÿå½¢é—ªè€€é˜¶æ®µç»“æŸåå¼€å§‹æ—‹è½¬ï¼Œä¸€ç›´ä¿æŒæ­£å¸¸æ—‹è½¬é€Ÿåº¦
                    treeGroup.rotation.y += CONFIG.ANIMATION_PHASES.ROTATION_SPEED_NORMAL;
                    if (!animationState.isRotating) {
                        animationState.isRotating = true;
                    }
                }
                
                // ğŸ„ éçº¿æ€§å‘¼å¸æ•ˆæœ - åªå¯¹æ ‘å† è¿›è¡Œå‘¼å¸
                if (animationState.treeCompleted && elapsed >= sparkleEnd + CONFIG.ANIMATION_PHASES.TREE_FORMED_DURATION) {
                    // éçº¿æ€§å‘¼å¸å‡½æ•°ï¼šå¸å¿«ã€å‘¼æ…¢
                    const breathe = (t) => {
                        const s = Math.sin(t);
                        return s > 0
                            ? Math.pow(s, 1.6)   // å¸æ°”æ›´ç”¨åŠ›
                            : -Math.pow(-s, 2); // å‘¼æ°”æ›´æ…¢
                    };
                    
                    const b = breathe(time * 0.8);
                    const breathScale = 1 + b * 0.045; // å®‰å…¨ä½†æ˜æ˜¾çš„å‘¼å¸å¹…åº¦
                    
                    // ğŸŒŸ åªå¯¹æ ‘å† ï¼ˆä¸ŠåŠéƒ¨åˆ†ï¼‰è¿›è¡Œå‘¼å¸ç¼©æ”¾
                    particleBatches.forEach((points, batchIndex) => {
                        const geometry = points.geometry;
                        const positions = geometry.attributes.position.array;
                        const targetPositions = geometry.attributes.targetPosition.array;
                        
                        // ä¸ºæ¯ä¸ªç²’å­è®¡ç®—åŸºäºé«˜åº¦çš„å‘¼å¸ç¼©æ”¾
                        for (let i = 0; i < positions.length; i += 3) {
                            const treeY = targetPositions[i + 1]; // æ ‘å½¢ä¸­çš„Yåæ ‡ä½ç½®
                            const treeHeight = 12; // æ ‘çš„æ€»é«˜åº¦å‚è€ƒå€¼
                            
                            // è®¡ç®—è¯¥ç²’å­åœ¨æ ‘ä¸­çš„ç›¸å¯¹é«˜åº¦ï¼ˆ0=åº•éƒ¨ï¼Œ1=é¡¶éƒ¨ï¼‰
                            const relativeHeight = (treeY + CONFIG.TREE.POSITION_OFFSET.y + treeHeight/2) / treeHeight;
                            
                            // åªå¯¹ä¸ŠåŠéƒ¨åˆ†ï¼ˆæ ‘å† ï¼‰è¿›è¡Œå‘¼å¸ï¼Œåº•éƒ¨0.4ä»¥ä¸‹ä¸å‚ä¸
                            const breatheFactor = relativeHeight > 0.4 ? 
                                THREE.MathUtils.smoothstep(0.4, 0.6, relativeHeight) : 0;
                            
                            // åº”ç”¨åŸºäºé«˜åº¦çš„å‘¼å¸ç¼©æ”¾
                            if (breatheFactor > 0) {
                                const scaleForThisParticle = 1 + (breathScale - 1) * breatheFactor;
                                
                                // ä»¥æ ‘çš„ä¸­å¿ƒä¸ºåŸºå‡†è¿›è¡Œç¼©æ”¾
                                const centerY = CONFIG.TREE.POSITION_OFFSET.y;
                                const yDistance = positions[i + 1] - centerY;
                                
                                positions[i + 1] = centerY + yDistance * scaleForThisParticle;
                                
                                // XZå¹³é¢ä¹Ÿç›¸åº”ç¼©æ”¾ï¼Œä¿æŒæ ‘çš„è‡ªç„¶å½¢çŠ¶
                                positions[i] = positions[i] * scaleForThisParticle;
                                positions[i + 2] = positions[i + 2] * scaleForThisParticle;
                            }
                        }
                        
                        geometry.attributes.position.needsUpdate = true;
                    });
                }
                
                // æ›´æ–°ç›¸æœºä½ç½®
                updateCameraPosition(camera, cameraControls);
                
                // ğŸ¯ å…³é”®ä¿®å¤ï¼šæ£€æŸ¥é›ªèŠ±å¯åŠ¨æ¡ä»¶ï¼ˆç»å¯¹æ—¶é—´æ§åˆ¶ï¼‰
                if (!animationState.snowStarted) {
                    let shouldStartSnow = false;
                    
                    if (CONFIG.ANIMATION_PHASES.USE_ABSOLUTE_SNOW_TIMING) {
                        // ğŸ”¥ å…³é”®ï¼šç»å¯¹æ—¶é—´æ§åˆ¶
                        const elapsedSinceAnimationStart = now - animationState.startTime;
                        shouldStartSnow = elapsedSinceAnimationStart >= CONFIG.ANIMATION_PHASES.SNOW_START_DELAY_ABSOLUTE; // 4000ms
                        console.log(`ğŸ• é›ªèŠ±å¯åŠ¨æ£€æŸ¥: å·²ç»è¿‡æ—¶é—´ ${elapsedSinceAnimationStart}ms, éœ€è¦æ—¶é—´ ${CONFIG.ANIMATION_PHASES.SNOW_START_DELAY_ABSOLUTE}ms`);
                    } else {
                        // ğŸ”¥ å…³é”®ï¼šç›¸å¯¹æ—¶é—´æ§åˆ¶
                        shouldStartSnow = animationState.treeCompleted;
                    }
                    
                    if (shouldStartSnow) {
                        console.log('â„ï¸ å¯åŠ¨é›ªèŠ±åŠ¨ç”»ï¼');
                        snowSystem.snowParticles.visible = true;
                        snowSystem.snowParticles.material.opacity = 0;
                        animationState.snowStarted = true;
                        animationState.snowStartTime = now;
                    }
                }
                
                // åªæœ‰åœ¨é›ªèŠ±å¼€å§‹åæ‰æ›´æ–°é›ªèŠ±åŠ¨ç”»
                if (animationState.snowStarted) {
                    // æ·»åŠ æ·¡å…¥æ•ˆæœ
                    let fadeInComplete = false;
                    if (animationState.snowStartTime > 0) {
                        const snowFadeInDuration = CONFIG.TIMING.SNOW_FADE_IN_DURATION;
                        const elapsedSinceSnowStart = now - animationState.snowStartTime;
                        const fadeInProgress = THREE.MathUtils.clamp(elapsedSinceSnowStart / snowFadeInDuration, 0, 1);
                        snowSystem.snowParticles.material.opacity = fadeInProgress * CONFIG.TIMING.SNOW_OPACITY_TARGET;
                        fadeInComplete = fadeInProgress >= CONFIG.TIMING.FADE_IN_PROGRESS_CLAMP;
                    }
                    
                    snowSystem.updateSnowAnimation(time, fadeInComplete, animationState.snowStartTime);
                }
                
                // ç¦ç”¨æ­¤å‡½æ•°ï¼Œé¿å…ç ´åsizeçš„ç¨³å®šæ€§
                // updateParticlesAnimation(particleBatches, time, animationState);
                
                // æ›´æ–°å½©è‰²è£…é¥°ç¯
                updateColoredLights(coloredLightObjects, time);
            }
            
            // æ¸²æŸ“åœºæ™¯
            renderer.render(scene, camera); // æ¸²æŸ“å½“å‰å¸§
        } // animateå‡½æ•°ç»“æŸ
        
        /**
         * æ›´æ–°ç›¸æœºä½ç½®
         */
        function updateCameraPosition(camera, cameraControls) {
            const spherical = new THREE.Spherical();
            spherical.radius = cameraControls.distance;
            spherical.theta = cameraControls.rotationY;
            spherical.phi = cameraControls.rotationX + Math.PI / 2;
            
            camera.position.setFromSpherical(spherical);
            camera.position.add(CONFIG.CAMERA.TARGET);
            camera.lookAt(CONFIG.CAMERA.TARGET);
        }
        
        

        
        /**
         * æ›´æ–°ç²’å­åŠ¨ç”»
         */
        function updateParticlesAnimation(particleBatches, time, animationState) {
            // æ£€æŸ¥æ‰€æœ‰ç²’å­æ˜¯å¦å·²å®Œæˆæ˜Ÿå½¢åˆ°æ ‘å½¢æ€çš„è¿‡æ¸¡
            const allParticlesTransitioned = particleBatches.every(points => 
                points.userData.starPhase >= 2
            );
            
            if (!allParticlesTransitioned) return;
            
            // åœ¨æ‰€æœ‰ç²’å­å®Œæˆè¿‡æ¸¡åï¼Œæ·»åŠ å¾®å¦™çš„åŠ¨æ€æ•ˆæœ
            particleBatches.forEach(points => {
                const geometry = points.geometry;
                const colors = geometry.attributes.color.array;
                const sizes = geometry.attributes.size.array;
                
                // âŒ ä¸å†ä½¿ç”¨ material.size
            });
        }
        
        /**
         * æ›´æ–°å½©è‰²è£…é¥°ç¯
         */
        function updateColoredLights(coloredLightObjects, time) {
            coloredLightObjects.forEach((light, index) => {
                const lightConfig = CONFIG.LIGHTS[index];
                const baseIntensity = lightConfig.intensity;
                const flickerSpeed = lightConfig.flickerSpeed;
                
                // è®¡ç®—é—ªçƒå¼ºåº¦
                const flicker = 0.5 + Math.sin(time * flickerSpeed * Math.PI * 2) * 0.5;
                light.intensity = baseIntensity * flicker;
            });
        }
        
        /**
         * çª—å£å¤§å°è°ƒæ•´äº‹ä»¶å¤„ç†
         */
        function onWindowResize(camera, renderer) { // çª—å£å¤§å°è°ƒæ•´å¤„ç†å‡½æ•°
            camera.aspect = window.innerWidth / window.innerHeight; // æ›´æ–°ç›¸æœºå®½é«˜æ¯”
            camera.updateProjectionMatrix(); // æ›´æ–°ç›¸æœºæŠ•å½±çŸ©é˜µ
            renderer.setSize(window.innerWidth, window.innerHeight); // æ›´æ–°æ¸²æŸ“å™¨å°ºå¯¸
        } // onWindowResizeå‡½æ•°ç»“æŸ
    </script> <!-- JavaScriptä»£ç ç»“æŸ -->
</body> <!-- æ–‡æ¡£ä¸»ä½“ç»“æŸ -->
</html> <!-- HTMLæ–‡æ¡£ç»“æŸ -->
