<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>åœ£è¯æ ‘</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background-color: #000;
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
        }
        canvas {
            display: block;
        }
    </style>
</head>
<body>
    <script src="three.min.js"></script>
    <script>
        // å¸¸é‡å®šä¹‰ï¼šå®šä¹‰æ‰€æœ‰ç³»ç»Ÿå‚æ•°é…ç½®
        const CONFIG = { // åˆ›å»ºå…¨å±€é…ç½®å¯¹è±¡
            // é›ªèŠ±ç³»ç»Ÿé…ç½®
            SNOW: { // é›ªèŠ±ç›¸å…³å‚æ•°
                COUNT: 3000, // é›ªèŠ±ç²’å­æ€»æ•°ï¼Œå‡å°‘æ•°é‡æé«˜æ€§èƒ½
                MAX_HEIGHT: 30, // é›ªèŠ±æœ€å¤§é«˜åº¦ï¼ˆYè½´åæ ‡ä¸Šé™ï¼‰
                MIN_HEIGHT: -5, // é›ªèŠ±æœ€å°é«˜åº¦ï¼ˆYè½´åæ ‡ä¸‹é™ï¼‰
                RANGE: 40, // é›ªèŠ±åˆ†å¸ƒèŒƒå›´ï¼ˆXå’ŒZè½´çš„éšæœºèŒƒå›´ï¼‰
                WIND_DIRECTION: new THREE.Vector3(-0.015, 0, -0.008), // é£çš„æ–¹å‘å‘é‡ï¼ˆXå’ŒZè½´åç§»ï¼‰
                BASE_SPEED: 0.055, // é›ªèŠ±åŸºç¡€ä¸‹è½é€Ÿåº¦ï¼Œå·²æé«˜
                SPEED_VARIANCE: 0.12 // é€Ÿåº¦å˜åŒ–èŒƒå›´ï¼Œå¢åŠ ä½¿ä¸‹è½æ›´è‡ªç„¶
            }, // SNOWé…ç½®ç»“æŸ
            // æ ‘ç³»ç»Ÿé…ç½®
            TREE: { // åœ£è¯æ ‘ç›¸å…³å‚æ•°
                PARTICLE_COUNT: 10000, // æ ‘çš„æ€»ç²’å­æ•°é‡
                TRUNK_RATIO: 0.15, // æ ‘å¹²ç²’å­æ¯”ä¾‹ï¼ˆ15%ï¼‰
                TRUNK_HEIGHT: 2, // æ ‘å¹²é«˜åº¦
                TRUNK_BASE_RADIUS: 0.6, // æ ‘å¹²åº•éƒ¨åŠå¾„
                TRUNK_TOP_RADIUS: 0.2, // æ ‘å¹²é¡¶éƒ¨åŠå¾„
                LEAF_HEIGHT_RANGE: 10, // æ ‘å¶é«˜åº¦èŒƒå›´
                LEAF_BASE_HEIGHT: 1, // æ ‘å¶èµ·å§‹é«˜åº¦
                LEAF_BASE_RADIUS: 4.26, // æ ‘å¶åŸºç¡€åŠå¾„
                RIBBON_PROBABILITY: 0.12, // å½©å¸¦ç²’å­å‡ºç°æ¦‚ç‡ï¼ˆ3%ï¼‰
                RIBBON_COUNT: 3, // å½©å¸¦æ•°é‡
                RIBBON_SPIRAL_TURNS: 3, // å½©å¸¦èºæ—‹åœˆæ•°
                POSITION_OFFSET: new THREE.Vector3(0, -7, 0), // æ ‘çš„ä½ç½®åç§»å‘é‡
                SCALE: new THREE.Vector3(2, 2.2, 2), // æ ‘çš„ç¼©æ”¾æ¯”ä¾‹
                TILT_X: THREE.MathUtils.degToRad(-30), // Xè½´å€¾æ–œè§’åº¦ï¼ˆè½¬æ¢ä¸ºå¼§åº¦ï¼‰
                ROTATION_SPEED: -0.005, // æ ‘çš„æ—‹è½¬é€Ÿåº¦ï¼ˆè´Ÿå€¼è¡¨ç¤ºé€†æ—¶é’ˆï¼‰
                BATCH_SIZE: 600, // æ¯æ‰¹å¤„ç†çš„ç²’å­æ•°é‡
                BATCH_INTERVAL: 120 // æ‰¹æ¬¡é—´éš”æ—¶é—´ï¼ˆæ¯«ç§’ï¼‰ï¼Œæ§åˆ¶æ˜Ÿæ˜Ÿç‚¹äº®é€Ÿåº¦
            }, // TREEé…ç½®ç»“æŸ
            // ç›¸æœºé…ç½®
            CAMERA: { // ç›¸æœºç›¸å…³å‚æ•°
                FOV: 65, // è§†åœºè§’åº¦ï¼ˆåº¦æ•°ï¼‰
                NEAR: 0.1, // è¿‘è£å‰ªé¢è·ç¦»
                FAR: 1000, // è¿œè£å‰ªé¢è·ç¦»
                INITIAL_POSITION: new THREE.Vector3(12, 7, 12), // ç›¸æœºåˆå§‹ä½ç½®
                TARGET: new THREE.Vector3(0, 4, 0) // ç›¸æœºè§‚å¯Ÿç›®æ ‡ç‚¹
            }, // CAMERAé…ç½®ç»“æŸ
            // ç¯å…‰é…ç½®
            LIGHTS: [ // è£…é¥°ç¯å…‰é…ç½®æ•°ç»„
                { color: 0xff0000, intensity: 0.8, distance: 5, flickerSpeed: 1.0 },  // çº¢è‰²ç¯å…‰
                { color: 0x00ff00, intensity: 0.6, distance: 4, flickerSpeed: 1.2 },  // ç»¿è‰²ç¯å…‰
                { color: 0x0000ff, intensity: 0.7, distance: 4.5, flickerSpeed: 2.0 },  // è“è‰²ç¯å…‰
                { color: 0xffff00, intensity: 0.9, distance: 5.5, flickerSpeed: 1.5 }   // é»„è‰²ç¯å…‰
            ], // LIGHTSé…ç½®ç»“æŸ
            // é¢œè‰²é…ç½®
            COLORS: { // é¢œè‰²ç›¸å…³å‚æ•°
                TREE: [ // æ ‘çš„é¢œè‰²æ•°ç»„
                    new THREE.Color(0x008800),  // æ·±ç»¿è‰²ï¼ˆæ ‘ä¸»ä½“ï¼‰
                    new THREE.Color(0x006600),  // æ›´æ·±çš„ç»¿è‰²ï¼ˆæ ‘ä¸»ä½“ï¼‰
                    new THREE.Color(0x009933),  // å†·ç»¿è‰²ï¼ˆæ ‘ä¸»ä½“ï¼‰
                    new THREE.Color(0x005522),  // æœ€å†·çš„ç»¿è‰²ï¼ˆæ ‘ä¸»ä½“ï¼‰
                    new THREE.Color(0xff0000),  // çº¢è‰²ï¼ˆè£…é¥°ï¼‰
                    new THREE.Color(0xffcc00),  // é‡‘è‰²ï¼ˆè£…é¥°ï¼‰
                    new THREE.Color(0x0000cc),  // æ·±è“è‰²ï¼ˆè£…é¥°ï¼‰
                    new THREE.Color(0xffffcc),  // æ·¡é»„è‰²ï¼ˆé«˜å…‰ï¼‰
                    new THREE.Color(0xffffff),  // ç™½è‰²ï¼ˆé«˜å…‰ï¼‰
                    new THREE.Color(0x5D3A00)   // æ·±æ£•è‰²ï¼ˆæ ‘å¹²ï¼‰
                ], // TREEé¢œè‰²æ•°ç»„ç»“æŸ
                RIBBON: [4, 5, 6]  // å½©å¸¦ä½¿ç”¨çš„é¢œè‰²ç´¢å¼•ï¼ˆå¯¹åº”TREEæ•°ç»„ä¸­çš„é¢œè‰²ï¼‰
            }, // COLORSé…ç½®ç»“æŸ
            // åŠ¨ç”»é…ç½®
            ANIMATION: { // åŠ¨ç”»ç›¸å…³å‚æ•°
                PULSE_SPEED: 2.0, // è„‰å†²åŠ¨ç”»é€Ÿåº¦
                PULSE_AMOUNT: 0.1, // è„‰å†²åŠ¨ç”»å¹…åº¦
                DECORATION_FLICKER_SPEED: 5.0, // è£…é¥°ç¯é—ªçƒé€Ÿåº¦
                PARTICLE_ANIMATION: { // ç²’å­åŠ¨ç”»å‚æ•°
                    STAR_PHASE_DURATION: 4000,  // æ˜Ÿå½¢é—ªè€€é˜¶æ®µæŒç»­æ—¶é—´ï¼ˆæ¯«ç§’ï¼‰
                    TRANSITION_DURATION: 8000,   // ä»æ˜Ÿå½¢åˆ°æ ‘å½¢æ€è¿‡æ¸¡æ—¶é—´ï¼ˆæ¯«ç§’ï¼‰
                    START_DELAY: 200,  // å¼€å§‹å»¶è¿Ÿï¼ˆæ¯«ç§’ï¼‰
                    EASE_FACTOR: 1.2,  // ç¼“åŠ¨å› å­ï¼Œæ§åˆ¶è¿‡æ¸¡å¹³æ»‘åº¦
                    INITIAL_RADIUS: 40,  // ç²’å­åˆå§‹éšæœºåˆ†å¸ƒåŠå¾„
                    ALL_PARTICLES_VISIBLE_DELAY: 500   // ç­‰å¾…æ‰€æœ‰ç²’å­å‡ºç°åå†å¼€å§‹ç§»åŠ¨
                } // PARTICLE_ANIMATIONç»“æŸ
            }, // ANIMATIONé…ç½®ç»“æŸ
            
            // ç²’å­äº®åº¦å¸¸é‡ - ğŸ¨ è°ƒæ•´è¿™äº›å€¼å¯ä»¥æ”¹å˜æ•´ä½“çš„æ˜æš—æ•ˆæœ
            BRIGHTNESS: {
                TRUNK_SHADOW_BASE: 10,        // ğŸŒ² æ ‘å¹²åŸºç¡€é˜´å½±å› å­(0.8-1.5) - è¶Šå¤§è¶Šäº®ï¼Œè¶Šå°è¶Šæš—
                TRUNK_SHADOW_HEIGHT_FACTOR: 0.5, // ğŸ“ æ ‘å¹²é«˜åº¦é˜´å½±æ¸å˜å¼ºåº¦(0.0-0.3) - è¶Šå¤§é¡¶éƒ¨è¶Šäº®
                RIBBON_BRIGHTNESS_MULTIPLIER: 1.1, // ğŸ€ å½©å¸¦äº®åº¦å€æ•°(1.0-1.5) - è¶Šå¤§å½©å¸¦è¶Šçªå‡º
                SPARKLE_BASE_INITIAL: 1.15,       // âœ¨ åˆå§‹é—ªè€€åŸºç¡€äº®åº¦(0.5-1.5) - æ˜Ÿå½¢é˜¶æ®µåŸºç¡€æ˜åº¦
                SPARKLE_AMPLITUDE_INITIAL: 0.5,   // ğŸŒŸ åˆå§‹é—ªè€€å¹…åº¦(0.1-0.8) - é—ªçƒå˜åŒ–å¼ºåº¦
                SPARKLE_BASE_FINAL: 1.15,          // ğŸ„ æœ€ç»ˆé—ªè€€åŸºç¡€äº®åº¦(0.7-1.2) - æˆæ ‘ååŸºç¡€æ˜åº¦
                SPARKLE_AMPLITUDE_FINAL: 0.15,     // ğŸŠ æœ€ç»ˆé—ªè€€å¹…åº¦(0.05-0.3) - æˆæ ‘åé—ªçƒå¼ºåº¦
                BACKGROUND_OVERLAY_ALPHA: 0.3,       // ğŸŒƒ èƒŒæ™¯æš—åŒ–è¦†ç›–å±‚é€æ˜åº¦(0.0-0.5) - è¶Šå¤§èƒŒæ™¯è¶Šæš—
                BACKGROUND_MULTIPLY_ALPHA: 0.7       // ğŸŒŒ èƒŒæ™¯æš—åŒ–ä¹˜æ³•é€æ˜åº¦(0.3-0.9) - è¶Šå¤§å›¾ç‰‡è¶Šæš—
            },
            
            // ç²’å­å°ºå¯¸å¸¸é‡ - ğŸ“ è°ƒæ•´è¿™äº›å€¼å¯ä»¥æ”¹å˜ç²’å­çš„å¤§å°å’Œåˆ†å¸ƒ
            SIZES: {
                TRUNK_BASE: 2.5,              // ğŸŒ² æ ‘å¹²åŸºç¡€å¤§å°(1.0-4.0) - æ ‘å¹²ç²’å­åŸºç¡€å°ºå¯¸
                TRUNK_VARIANCE: 3.5,          // ğŸ“ æ ‘å¹²å¤§å°å˜åŒ–èŒƒå›´(1.0-5.0) - æ ‘å¹²å°ºå¯¸éšæœºå˜åŒ–é‡
                LEAF_BASE: 1.8,               // ğŸƒ æ ‘å¶åŸºç¡€å¤§å°(1.0-3.0) - æ ‘å¶ç²’å­åŸºç¡€å°ºå¯¸
                LEAF_VARIANCE: 3.5,           // ğŸŒ¿ æ ‘å¶å¤§å°å˜åŒ–èŒƒå›´(1.0-5.0) - æ ‘å¶å°ºå¯¸éšæœºå˜åŒ–é‡
                RIBBON_MULTIPLIER: 2.0,        // ğŸ€ å½©å¸¦å°ºå¯¸å€æ•°(1.5-3.0) - å½©å¸¦ç›¸å¯¹æ™®é€šç²’å­çš„å¤§å°å€æ•°
                TOP_SIZE_FACTOR: 0.9,           // ğŸ„ æ ‘é¡¶éƒ¨ç²’å­å°ºå¯¸å› å­(0.7-1.2) - æ ‘é¡¶éƒ¨ç²’å­å¤§å°è°ƒæ•´
                NORMAL_SIZE_FACTOR: 1.1,         // ğŸŒ² æ™®é€šç²’å­å°ºå¯¸å› å­(0.8-1.5) - æ ‘èº«ç²’å­å¤§å°è°ƒæ•´
                SIZE_VARIANCE_BASE: 0.95,        // ğŸ² å°ºå¯¸éšæœºå˜åŒ–åŸºç¡€(0.8-1.2) - ç²’å­å°ºå¯¸éšæœºåŸºç¡€å€¼
                SIZE_VARIANCE_RANGE: 0.25        // ğŸ° å°ºå¯¸éšæœºå˜åŒ–èŒƒå›´(0.1-0.5) - ç²’å­å°ºå¯¸éšæœºå˜åŒ–èŒƒå›´
            },
            
            // ç³»ç»Ÿæ—¶åºå¸¸é‡ - â±ï¸ è°ƒæ•´è¿™äº›å€¼å¯ä»¥æ”¹å˜åŠ¨ç”»çš„æ—¶é—´èŠ‚å¥
            TIMING: {
                PARTICLE_INIT_DELAY: 500,       // â±ï¸ ç²’å­ç³»ç»Ÿåˆå§‹åŒ–å»¶è¿Ÿ(100-2000) - é¡µé¢åŠ è½½åå¤šä¹…æ˜¾ç¤ºç²’å­(ms)
                BACKGROUND_RENDER_DELAY: 100,     // ğŸ–¼ï¸ èƒŒæ™¯æ¸²æŸ“å»¶è¿Ÿ(50-500) - èƒŒæ™¯å›¾ç‰‡æ¸²æŸ“å»¶è¿Ÿ(ms)
                APPEAR_DURATION: 500,            // ğŸ‘ï¸ ç²’å­å‡ºç°æŒç»­æ—¶é—´(200-1000) - å•æ‰¹ç²’å­æ¸æ˜¾æ—¶é—´(ms)
                SNOW_FADE_IN_DURATION: 500,     // â„ï¸ é›ªèŠ±æ·¡å…¥æŒç»­æ—¶é—´(200-1000) - é›ªèŠ±æ¸æ˜¾æ—¶é—´(ms)
                FADE_IN_PROGRESS_CLAMP: 1.0,     // ğŸ¯ æ·¡å…¥è¿›åº¦æœ€å¤§å€¼(0.8-1.0) - æ·¡å…¥å®Œæˆé˜ˆå€¼
                SNOW_OPACITY_TARGET: 0.8         // ğŸ’¨ é›ªèŠ±æœ€ç»ˆé€æ˜åº¦(0.3-1.0) - é›ªèŠ±æœ€å¤§é€æ˜åº¦
            },
            
            // é›ªèŠ±åŠ¨ç”»å¸¸é‡ - â„ï¸ è°ƒæ•´è¿™äº›å€¼å¯ä»¥æ”¹å˜é›ªèŠ±çš„åŠ¨æ€æ•ˆæœ
            SNOW_ANIMATION: {
                FALL_SPEED_FACTOR: 0.6,          // â¬‡ï¸ é›ªèŠ±ä¸‹è½é€Ÿåº¦å› å­(0.2-1.0) - é›ªèŠ±ä¸‹è½é€Ÿåº¦ï¼Œè¶Šå°è¶Šæ…¢
                WIND_EFFECT_FACTOR: 0.3,         // ğŸ’¨ é£æ•ˆæœå› å­(0.1-0.8) - é£çš„æ¨ªå‘å½±å“å¼ºåº¦
                SWAY_X_FREQUENCY: 0.3,           // ğŸ”„ Xè½´æ‘‡æ‘†é¢‘ç‡(0.1-0.8) - å·¦å³æ‘‡æ‘†é€Ÿåº¦
                SWAY_X_AMPLITUDE: 0.005,         // â†”ï¸ Xè½´æ‘‡æ‘†å¹…åº¦(0.001-0.02) - å·¦å³æ‘‡æ‘†è·ç¦»
                SWAY_Z_FREQUENCY: 0.4,           // ğŸ”„ Zè½´æ‘‡æ‘†é¢‘ç‡(0.1-0.8) - å‰åæ‘‡æ‘†é€Ÿåº¦
                SWAY_Z_AMPLITUDE: 0.004,         // â†•ï¸ Zè½´æ‘‡æ‘†å¹…åº¦(0.001-0.02) - å‰åæ‘‡æ‘†è·ç¦»
                ACTIVATION_DURATION: 0.8,        // â° é›ªèŠ±æ¿€æ´»æŒç»­æ—¶é—´(0.3-2.0) - å…¨éƒ¨é›ªèŠ±æ¿€æ´»å®Œæˆæ—¶é—´(ç§’)
                OPACITY_BASE: 0.6,               // ğŸ’§ é›ªèŠ±åŸºç¡€é€æ˜åº¦(0.2-0.8) - é›ªèŠ±åŸºç¡€æ˜åº¦
                OPACITY_VARIATION: 0.2,          // ğŸŒŠ é›ªèŠ±é€æ˜åº¦å˜åŒ–å¹…åº¦(0.05-0.4) - é€æ˜åº¦å˜åŒ–èŒƒå›´
                OPACITY_FREQUENCY: 0.3            // ğŸ­ é›ªèŠ±é€æ˜åº¦å˜åŒ–é¢‘ç‡(0.1-0.8) - é€æ˜åº¦å˜åŒ–é€Ÿåº¦
            },
            
            // åŠ¨ç”»æ—¶åºå¸¸é‡ - â° æ§åˆ¶æ¯ä¸ªåŠ¨ç”»é˜¶æ®µçš„å¼€å§‹æ—¶é—´å’ŒæŒç»­æ—¶é—´
            ANIMATION_PHASES: {
                // é˜¶æ®µ1ï¼šç²’å­å‡ºç°é˜¶æ®µ - ä»åŠ¨ç”»å¼€å§‹åˆ°æ‰€æœ‰ç²’å­å¯è§
                PARTICLES_APPEAR_START: 0,                    // ğŸ“… ç²’å­å¼€å§‹å‡ºç°æ—¶é—´(msï¼Œç›¸å¯¹åŠ¨ç”»å¼€å§‹)
                ALL_PARTICLES_VISIBLE_DELAY: 500,           // â³ å…¨éƒ¨ç²’å­å¯è§åé¢å¤–å»¶è¿Ÿ(ms)
                
                // é˜¶æ®µ2ï¼šæ˜Ÿå½¢é—ªè€€é˜¶æ®µ - ç²’å­ä»¥æ˜Ÿå½¢æ¨¡å¼é—ªçƒ
                SPARKLE_DURATION: 2000,                    // âœ¨ æ˜Ÿå½¢é—ªè€€æŒç»­æ—¶é—´(ms)
                SPARKLE_DELAY_BETWEEN_BATCHES: 0,          // â¸ï¸ æ‰¹æ¬¡é—´é—ªè€€å»¶è¿Ÿ(ms)
                
                // é˜¶æ®µ3ï¼šè¿‡æ¸¡æ±‡èšé˜¶æ®µ - ç²’å­ä»æ˜Ÿå½¢æ±‡èšæˆæ ‘å½¢
                TRANSITION_DURATION: 6000,                 // ğŸŒŠ æ˜Ÿå½¢åˆ°æ ‘å½¢è¿‡æ¸¡æ—¶é—´(ms)
                TRANSITION_START_DELAY: 0,                  // â¸ï¸ è¿‡æ¸¡å¼€å§‹å»¶è¿Ÿ(ms)
                
                // é˜¶æ®µ4ï¼šæœ€ç»ˆæˆå‹é˜¶æ®µ - æ ‘å®Œå…¨å½¢æˆå¹¶å¼€å§‹æ—‹è½¬
                TREE_FORMED_DURATION: 2000,               // ğŸ„ æ ‘æˆå‹åç¨³å®šæŒç»­æ—¶é—´(ms)
                ROTATION_SPEED_NORMAL: -0.002,             // ğŸ”„ æ ‘æ­£å¸¸æ—‹è½¬é€Ÿåº¦(å¼§åº¦/å¸§)
                ROTATION_SPEED_ACCELERATED: -0.004,        // ğŸš€ è¿‡æ¸¡é˜¶æ®µåŠ é€Ÿæ—‹è½¬é€Ÿåº¦(å¼§åº¦/å¸§)
                
                // é˜¶æ®µ5ï¼šé›ªèŠ±åŠ¨ç”»é˜¶æ®µ - ç‹¬ç«‹æ§åˆ¶é›ªèŠ±å‡ºç°æ—¶é—´
                SNOW_START_DELAY_ABSOLUTE: 4000,           // â„ï¸ é›ªèŠ±ç»å¯¹å¼€å§‹æ—¶é—´(msï¼Œç›¸å¯¹åŠ¨ç”»å¼€å§‹)
                SNOW_START_DELAY_RELATIVE: 0,              // ğŸ„ é›ªèŠ±ç›¸å¯¹æ ‘æˆå‹å»¶è¿Ÿ(msï¼Œå¤‡ç”¨é€‰é¡¹)
                SNOW_DURATION: 30000,                     // ğŸ’¨ é›ªèŠ±åŠ¨ç”»æŒç»­æ—¶é—´(msï¼Œ0è¡¨ç¤ºæŒç»­)
                USE_ABSOLUTE_SNOW_TIMING: true,            // â° æ˜¯å¦ä½¿ç”¨ç»å¯¹æ—¶é—´æ§åˆ¶é›ªèŠ±(å¦åˆ™ç”¨ç›¸å¯¹æ ‘æˆå‹æ—¶é—´)
                
                // è®¡ç®—è¾…åŠ©å¸¸é‡ - è¿™äº›å€¼ç”±ä¸Šè¿°å¸¸é‡è®¡ç®—å¾—å‡º
                BATCH_PROCESSING_INTERVAL: 120,              // âš™ï¸ æ‰¹æ¬¡å¤„ç†é—´éš”(msï¼ŒåŸBATCH_INTERVAL)
                ROTATION_ACCELERATION_START_OFFSET: 0,     // ğŸš€ å¼€å§‹åŠ é€Ÿæ—‹è½¬çš„æ—¶æœºåç§»(ms)
                ROTATION_ACCELERATION_END_OFFSET: 0         // ğŸ ç»“æŸåŠ é€Ÿæ—‹è½¬çš„æ—¶æœºåç§»(ms)
            }
        }; // CONFIGå¯¹è±¡ç»“æŸ

        // å…¨å±€å˜é‡æ§åˆ¶ç²’å­ç³»ç»ŸçŠ¶æ€
        let particlesStarted = false;
        let animationParams = null;
        let scene, camera, renderer;

        // é¡µé¢åŠ è½½å®Œæˆååˆå§‹åŒ–Three.js
        window.addEventListener('DOMContentLoaded', initThreeJs); // DOMåŠ è½½å®Œæˆäº‹ä»¶ç›‘å¬å™¨
        
        /**
         * Three.jsåˆå§‹åŒ–ä¸»å‡½æ•°
         */
        function initThreeJs() { // Three.jsåˆå§‹åŒ–å‡½æ•°å¼€å§‹
            // åˆ›å»ºThree.jsåœºæ™¯å¯¹è±¡
            scene = new THREE.Scene(); // åˆ›å»º3Dåœºæ™¯å®¹å™¨
            
            // ä¼˜å…ˆä½¿ç”¨æ¸å˜èƒŒæ™¯ï¼Œé¿å…å›¾ç‰‡åŠ è½½é—®é¢˜
            useFallbackBackground(scene);
            
            // åˆå§‹åŒ–ç›¸æœº
            camera = createCamera(); // è°ƒç”¨ç›¸æœºåˆ›å»ºå‡½æ•°
            
            // åˆå§‹åŒ–æ¸²æŸ“å™¨
            renderer = createRenderer(); // è°ƒç”¨æ¸²æŸ“å™¨åˆ›å»ºå‡½æ•°
            
            // æ·»åŠ çª—å£å¤§å°è°ƒæ•´äº‹ä»¶ç›‘å¬
            window.addEventListener('resize', () => onWindowResize(camera, renderer)); // ç›‘å¬çª—å£å¤§å°å˜åŒ–
            
            // å°è¯•åŠ è½½èƒŒæ™¯å›¾ç‰‡ï¼ŒåŠ è½½å®Œæˆåå†å¼€å§‹åŠ¨ç”»
            tryLoadBackgroundImage(scene, renderer, camera, () => {
                // èƒŒæ™¯åŠ è½½å®Œæˆï¼Œæ¸²æŸ“ç¬¬ä¸€å¸§
                renderer.render(scene, camera);
                console.log('ğŸ¬ èƒŒæ™¯å‡†å¤‡å°±ç»ªï¼Œå¼€å§‹ç®€å•åŠ¨ç”»å¾ªç¯');
                
                // å¼€å§‹ç®€å•çš„åŠ¨ç”»å¾ªç¯ï¼ˆåªæ¸²æŸ“èƒŒæ™¯ï¼‰
                animate();
                
                // â­ å»¶è¿Ÿåˆå§‹åŒ–ç²’å­ç³»ç»Ÿ
                setTimeout(() => {
                    console.log('ğŸŒŸ å¼€å§‹åˆå§‹åŒ–ç²’å­ç³»ç»Ÿ...');
                    initParticles();
                    particlesStarted = true;
                }, CONFIG.TIMING.PARTICLE_INIT_DELAY);
            });
        } // initThreeJså‡½æ•°ç»“æŸ
        
        /**
         * åˆå§‹åŒ–ç²’å­ç³»ç»Ÿï¼ˆå»¶è¿Ÿæ‰§è¡Œï¼‰
         */
        function initParticles() {
            // åˆ›å»ºé›ªèŠ±ç²’å­ç³»ç»Ÿï¼ˆåˆå§‹éšè—ï¼‰
            const snowSystem = createSnowParticles(scene); // è°ƒç”¨é›ªèŠ±ç³»ç»Ÿåˆ›å»ºå‡½æ•°
            snowSystem.snowParticles.visible = false; // åˆå§‹éšè—é›ªç²’å­
            
            // åˆ›å»ºåœ£è¯æ ‘
            const { // è§£æ„èµ‹å€¼ï¼Œè·å–åˆ›å»ºåœ£è¯æ ‘è¿”å›çš„å¤šä¸ªå¯¹è±¡
                treeGroup, // æ ‘çš„ç»„å¯¹è±¡
                particleBatches, // ç²’å­æ‰¹æ¬¡æ•°ç»„
                coloredLightObjects, // å½©è‰²ç¯å…‰å¯¹è±¡æ•°ç»„
                animationState // åŠ¨ç”»çŠ¶æ€å¯¹è±¡
            } = createChristmasTree(scene); // è°ƒç”¨åœ£è¯æ ‘åˆ›å»ºå‡½æ•°
            
            // åˆå§‹åŒ–ç›¸æœºæ§åˆ¶å‚æ•°
            const cameraControls = initCameraControls(camera); // è°ƒç”¨ç›¸æœºæ§åˆ¶åˆå§‹åŒ–å‡½æ•°
            
            // ä¿å­˜åŠ¨ç”»å‚æ•°åˆ°å…¨å±€å˜é‡
            animationParams = {
                scene, // 3Dåœºæ™¯
                camera, // ç›¸æœº
                renderer, // æ¸²æŸ“å™¨
                snowSystem, // é›ªèŠ±ç³»ç»Ÿ
                treeGroup, // æ ‘ç»„
                particleBatches, // ç²’å­æ‰¹æ¬¡
                coloredLightObjects, // å½©è‰²ç¯å…‰
                cameraControls, // ç›¸æœºæ§åˆ¶
                animationState // åŠ¨ç”»çŠ¶æ€
            };
            
            console.log('âœ… ç²’å­ç³»ç»Ÿåˆå§‹åŒ–å®Œæˆ');
        }
        
        /**
         * åˆ›å»ºé€è§†ç›¸æœº
         */
        function createCamera() { // ç›¸æœºåˆ›å»ºå‡½æ•°å¼€å§‹
            const camera = new THREE.PerspectiveCamera( // åˆ›å»ºé€è§†ç›¸æœºå¯¹è±¡
                CONFIG.CAMERA.FOV, // è§†åœºè§’åº¦
                window.innerWidth / window.innerHeight, // å®½é«˜æ¯”
                CONFIG.CAMERA.NEAR, // è¿‘è£å‰ªé¢
                CONFIG.CAMERA.FAR // è¿œè£å‰ªé¢
            ); // PerspectiveCameraåˆ›å»ºç»“æŸ
            
            camera.position.copy(CONFIG.CAMERA.INITIAL_POSITION); // è®¾ç½®ç›¸æœºåˆå§‹ä½ç½®
            camera.lookAt(CONFIG.CAMERA.TARGET); // è®¾ç½®ç›¸æœºè§‚å¯Ÿç›®æ ‡
            
            return camera; // è¿”å›ç›¸æœºå¯¹è±¡
        } // createCameraå‡½æ•°ç»“æŸ
        
        /**
         * åˆ›å»ºWebGLæ¸²æŸ“å™¨
         */
        function createRenderer() { // æ¸²æŸ“å™¨åˆ›å»ºå‡½æ•°å¼€å§‹
            const renderer = new THREE.WebGLRenderer({ antialias: true }); // åˆ›å»ºWebGLæ¸²æŸ“å™¨ï¼Œå¯ç”¨æŠ—é”¯é½¿
            renderer.setSize(window.innerWidth, window.innerHeight); // è®¾ç½®æ¸²æŸ“å™¨å°ºå¯¸ä¸ºçª—å£å¤§å°
            renderer.shadowMap.enabled = false; // ç¦ç”¨é˜´å½±æ˜ å°„æé«˜æ€§èƒ½
            document.body.appendChild(renderer.domElement); // å°†æ¸²æŸ“å™¨DOMå…ƒç´ æ·»åŠ åˆ°é¡µé¢
            
            return renderer; // è¿”å›æ¸²æŸ“å™¨å¯¹è±¡
        } // createRendererå‡½æ•°ç»“æŸ
        
        /**
         * å°è¯•åŠ è½½èƒŒæ™¯å›¾ç‰‡ï¼ˆå¼‚æ­¥ï¼Œéé˜»å¡ï¼‰
         */
        function tryLoadBackgroundImage(scene, renderer, camera, onComplete) {
            console.log('ğŸ” å°è¯•å¼‚æ­¥åŠ è½½èƒŒæ™¯å›¾ç‰‡...');
            
            const img = new Image();
            
            img.onload = function() {
                console.log('âœ… èƒŒæ™¯å›¾ç‰‡åŠ è½½æˆåŠŸ');
                try {
                    // å…ˆå°†å›¾ç‰‡ç»˜åˆ¶åˆ°canvasä¸Šè¿›è¡Œè°ƒæš—å¤„ç†
                    const canvas = document.createElement('canvas');
                    canvas.width = img.width;
                    canvas.height = img.height;
                    const ctx = canvas.getContext('2d');
                    
                    // ç»˜åˆ¶åŸå›¾
                    ctx.drawImage(img, 0, 0);
                    
                    // åº”ç”¨æš—åŒ–æ»¤é•œ
                    ctx.globalCompositeOperation = 'multiply';
                    ctx.fillStyle = `rgba(0, 0, 50, ${CONFIG.BRIGHTNESS.BACKGROUND_MULTIPLY_ALPHA})`;
                    ctx.fillRect(0, 0, canvas.width, canvas.height);
                    
                    // é‡ç½®æ··åˆæ¨¡å¼
                    ctx.globalCompositeOperation = 'source-over';
                    
                    // ç¨å¾®å¢åŠ å¯¹æ¯”åº¦
                    ctx.globalAlpha = CONFIG.BRIGHTNESS.BACKGROUND_OVERLAY_ALPHA;
                    ctx.fillStyle = '#000000';
                    ctx.fillRect(0, 0, canvas.width, canvas.height);
                    ctx.globalAlpha = 1.0;
                    
                    const texture = new THREE.CanvasTexture(canvas);
                    texture.colorSpace = THREE.SRGBColorSpace;
                    texture.minFilter = THREE.LinearFilter;
                    texture.magFilter = THREE.LinearFilter;
                    texture.wrapS = THREE.ClampToEdgeWrapping;
                    texture.wrapT = THREE.ClampToEdgeWrapping;
                    texture.generateMipmaps = false;
                    
                    scene.background = texture;
                    
                    // å¼ºåˆ¶æ¸²æŸ“
                    setTimeout(() => {
                        renderer.render(scene, camera);
                        console.log('è°ƒæš—çš„èƒŒæ™¯å›¾ç‰‡å·²åº”ç”¨');
                        // èƒŒæ™¯åŠ è½½å®Œæˆï¼Œè°ƒç”¨å›è°ƒå¼€å§‹åŠ¨ç”»
                        onComplete();
                    }, CONFIG.TIMING.BACKGROUND_RENDER_DELAY);
                } catch (error) {
                    console.error('âŒ çº¹ç†åˆ›å»ºå¤±è´¥:', error);
                    // å³ä½¿çº¹ç†åˆ›å»ºå¤±è´¥ï¼Œä¹Ÿè¦ç»§ç»­å¯åŠ¨åŠ¨ç”»
                    onComplete();
                }
            };
            
            img.onerror = function() {
                console.log('âš ï¸ èƒŒæ™¯å›¾ç‰‡åŠ è½½å¤±è´¥ï¼Œç»§ç»­ä½¿ç”¨æ¸å˜èƒŒæ™¯');
                // å›¾ç‰‡åŠ è½½å¤±è´¥ï¼Œä½¿ç”¨æ¸å˜èƒŒæ™¯ï¼Œè°ƒç”¨å›è°ƒå¼€å§‹åŠ¨ç”»
                onComplete();
            };
            
            // å°è¯•åŠ è½½å›¾ç‰‡ï¼Œä½†ä¸é˜»å¡ä¸»ç¨‹åº
            img.src = './christmas_tree.jpg';
        }
        
        /**
         * ä½¿ç”¨æ¸å˜èƒŒæ™¯
         */
        function useFallbackBackground(scene) {
            console.log('ğŸ¨ ä½¿ç”¨æ¸å˜èƒŒæ™¯');
            
            // åˆ›å»ºæ¸å˜èƒŒæ™¯
            const canvas = document.createElement('canvas');
            canvas.width = 512;
            canvas.height = 512;
            const ctx = canvas.getContext('2d');
            
            // åˆ›å»ºæ›´æš—çš„æ¸å˜èƒŒæ™¯
            const gradient = ctx.createLinearGradient(0, 0, 0, 512);
            gradient.addColorStop(0, '#000511');    // ææ·±çš„æ·±è“è‰²
            gradient.addColorStop(0.3, '#000822');  // æ·±è“è‰²
            gradient.addColorStop(0.6, '#000b33');  // ç¨äº®çš„æ·±è“
            gradient.addColorStop(0.8, '#000e44');  // ä¸­ç­‰æ·±è“
            gradient.addColorStop(1, '#001155');    // åº•éƒ¨æ·±è“
            
            ctx.fillStyle = gradient;
            ctx.fillRect(0, 0, 512, 512);
            
            // æ·»åŠ æ›´ç¨€ç–ã€æ›´æš—çš„æ˜Ÿæ˜Ÿæ•ˆæœ
            for (let i = 0; i < 60; i++) {
                // é™ä½æ˜Ÿæ˜Ÿçš„äº®åº¦å’Œå¯†åº¦
                const opacity = Math.random() * 0.4;  // æœ€å¤§é€æ˜åº¦0.4
                ctx.fillStyle = `rgba(255, 255, 255, ${opacity})`;
                ctx.fillRect(
                    Math.random() * 512,
                    Math.random() * 512,
                    1, 1
                );
            }
            
            const texture = new THREE.CanvasTexture(canvas);
            scene.background = texture;
            
            console.log('âœ… æ›´æš—çš„æ¸å˜èƒŒæ™¯å·²è®¾ç½®');
        }
        
        /**
         * åˆ›å»ºé›ªèŠ±ç²’å­ç³»ç»Ÿï¼ˆæ¸è¿›å¼ï¼‰
         */
        function createSnowParticles(scene) { // é›ªèŠ±ç²’å­ç³»ç»Ÿåˆ›å»ºå‡½æ•°å¼€å§‹
            const { COUNT, MAX_HEIGHT, RANGE, BASE_SPEED, SPEED_VARIANCE } = CONFIG.SNOW; // è§£æ„è·å–é›ªèŠ±é…ç½®
            
            // åˆ›å»ºå‡ ä½•ä½“
            const snowGeometry = new THREE.BufferGeometry(); // åˆ›å»ºç¼“å†²å‡ ä½•ä½“
            
            // åˆ›å»ºå±æ€§æ•°ç»„
            const snowPositions = new Float32Array(COUNT * 3); // ä½ç½®æ•°ç»„ï¼ˆX,Y,Zåæ ‡ï¼‰
            const snowColors = new Float32Array(COUNT * 3); // é¢œè‰²æ•°ç»„ï¼ˆR,G,Bå€¼ï¼‰
            const snowSizes = new Float32Array(COUNT); // å¤§å°æ•°ç»„
            const snowSpeeds = new Float32Array(COUNT); // é€Ÿåº¦æ•°ç»„
            const snowActive = new Float32Array(COUNT); // æ¿€æ´»çŠ¶æ€æ•°ç»„ï¼ˆæ§åˆ¶æ¯ä¸ªç²’å­æ˜¯å¦æ´»è·ƒï¼‰
            
            // ç™½è‰²é›ªèŠ±
            const whiteColor = new THREE.Color(0xffffff); // åˆ›å»ºç™½è‰²é¢œè‰²å¯¹è±¡
            const whiteColorArray = [whiteColor.r, whiteColor.g, whiteColor.b]; // è·å–é¢œè‰²RGBå€¼æ•°ç»„
            
            // åˆå§‹åŒ–é›ªèŠ±ç²’å­ï¼ˆåˆå§‹éƒ½ä¸æ´»è·ƒï¼‰
            for (let i = 0; i < COUNT; i++) { // éå†æ‰€æœ‰é›ªèŠ±ç²’å­
                const i3 = i * 3; // è®¡ç®—ä½ç½®æ•°ç»„ç´¢å¼•ï¼ˆæ¯ä¸ªç²’å­3ä¸ªåæ ‡å€¼ï¼‰
                
                // éšæœºä½ç½®ï¼ˆåˆå§‹åœ¨å¾ˆé«˜çš„åœ°æ–¹ï¼‰
                snowPositions[i3] = (Math.random() - 0.5) * RANGE; // Xåæ ‡éšæœº
                snowPositions[i3 + 1] = MAX_HEIGHT + Math.random() * 10; // Yåæ ‡ï¼ˆæ›´é«˜å¤„ï¼‰
                snowPositions[i3 + 2] = (Math.random() - 0.5) * RANGE; // Zåæ ‡éšæœº
                
                // ç™½è‰²
                snowColors.set(whiteColorArray, i3); // è®¾ç½®ç²’å­é¢œè‰²ä¸ºç™½è‰²
                
                // éšæœºå¤§å°
                snowSizes[i] = 0.05 + Math.random() * 0.2; // éšæœºå¤§å°èŒƒå›´0.05-0.25
                
                // éšæœºé€Ÿåº¦
                snowSpeeds[i] = BASE_SPEED + Math.random() * SPEED_VARIANCE; // åŸºç¡€é€Ÿåº¦åŠ éšæœºå˜åŒ–
                
                // åˆå§‹ä¸æ´»è·ƒ
                snowActive[i] = 0; // è®¾ç½®ä¸ºä¸æ´»è·ƒçŠ¶æ€
            } // é›ªèŠ±ç²’å­åˆå§‹åŒ–å¾ªç¯ç»“æŸ
            
            // è®¾ç½®å‡ ä½•ä½“å±æ€§
            snowGeometry.setAttribute('position', new THREE.BufferAttribute(snowPositions, 3));
            snowGeometry.setAttribute('color', new THREE.BufferAttribute(snowColors, 3));
            snowGeometry.setAttribute('size', new THREE.BufferAttribute(snowSizes, 1));
            snowGeometry.setAttribute('active', new THREE.BufferAttribute(snowActive, 1));
            
            // åˆ›å»ºæè´¨
            const snowMaterial = new THREE.PointsMaterial({
                size: 0.1,
                vertexColors: true,
                transparent: true,
                opacity: 0.8,
                blending: THREE.AdditiveBlending,
                sizeAttenuation: true
            });
            
            // åˆ›å»ºç²’å­ç³»ç»Ÿ
            const snowParticles = new THREE.Points(snowGeometry, snowMaterial);
            scene.add(snowParticles);
            
            // è¿”å›åŠ¨ç”»æ›´æ–°å‡½æ•°
            return {
                snowParticles,
                updateSnowAnimation: (time, fadeInComplete, snowStartTime) => updateSnowAnimation(snowParticles, COUNT, snowSpeeds, time, fadeInComplete, snowStartTime)
            };
        }
        
        /**
         * æ›´æ–°é›ªèŠ±åŠ¨ç”»ï¼ˆæ¸è¿›å¼æ¿€æ´»ï¼‰
         */
        function updateSnowAnimation(snowParticles, particleCount, snowSpeeds, time, fadeInComplete, snowStartTime) {
            const { MAX_HEIGHT, MIN_HEIGHT, RANGE, WIND_DIRECTION, BASE_SPEED, SPEED_VARIANCE } = CONFIG.SNOW;
            const positionsArray = snowParticles.geometry.attributes.position.array;
            const activeArray = snowParticles.geometry.attributes.active.array;
            
            const elapsedSinceSnowStart = snowStartTime ? (Date.now() - snowStartTime) / 1000 : 0;
            
            for (let i = 0; i < particleCount; i++) {
                const i3 = i * 3;
                const speed = snowSpeeds[i];
                
                // æ¸è¿›å¼æ¿€æ´»é›ªèŠ±ï¼ˆ0.8ç§’å†…é€æ¸æ¿€æ´»æ‰€æœ‰é›ªèŠ±ï¼‰
                if (activeArray[i] === 0 && elapsedSinceSnowStart > 0) {
                    const activationDelay = (i / particleCount) * CONFIG.SNOW_ANIMATION.ACTIVATION_DURATION;
                    if (elapsedSinceSnowStart >= activationDelay) {
                        activeArray[i] = 1;
                        // å°†æ´»è·ƒç²’å­ä»é«˜å¤„å¼€å§‹ä¸‹è½
                        positionsArray[i3 + 1] = MAX_HEIGHT + Math.random() * 5;
                    }
                }
                
                // åªæœ‰æ´»è·ƒçš„é›ªèŠ±æ‰å‚ä¸åŠ¨ç”»
                if (activeArray[i] === 1) {
                    // é›ªèŠ±ä¸‹è½ - ä½¿ç”¨æ›´è‡ªç„¶çš„é€Ÿåº¦
                    positionsArray[i3 + 1] -= speed * CONFIG.SNOW_ANIMATION.FALL_SPEED_FACTOR;
                    
                    // é£çš„å½±å“ï¼ˆæ›´è½»å¾®ï¼‰
                    positionsArray[i3] += WIND_DIRECTION.x * CONFIG.SNOW_ANIMATION.WIND_EFFECT_FACTOR;
                    positionsArray[i3 + 2] += WIND_DIRECTION.z * CONFIG.SNOW_ANIMATION.WIND_EFFECT_FACTOR;
                    
                    // å·¦å³æ‘‡æ‘†ï¼ˆæ›´ç¼“æ…¢ï¼‰
                    positionsArray[i3] += Math.sin(time * CONFIG.SNOW_ANIMATION.SWAY_X_FREQUENCY + i * 0.1) * CONFIG.SNOW_ANIMATION.SWAY_X_AMPLITUDE;
                    positionsArray[i3 + 2] += Math.cos(time * CONFIG.SNOW_ANIMATION.SWAY_Z_FREQUENCY + i * 0.15) * CONFIG.SNOW_ANIMATION.SWAY_Z_AMPLITUDE;
                    
                    // é›ªèŠ±é‡æ–°ç”Ÿæˆ
                    if (positionsArray[i3 + 1] < MIN_HEIGHT) {
                        positionsArray[i3 + 1] = MAX_HEIGHT + Math.random() * 10;
                        positionsArray[i3] = (Math.random() - 0.5) * RANGE;
                        positionsArray[i3 + 2] = (Math.random() - 0.5) * RANGE;
                    }
                }
            }
            
            snowParticles.geometry.attributes.position.needsUpdate = true;
            snowParticles.geometry.attributes.active.needsUpdate = true;
            
            // é›ªèŠ±é€æ˜åº¦å˜åŒ– - åªåœ¨æ·¡å…¥å®Œæˆåæ‰åº”ç”¨åŠ¨æ€å˜åŒ–
            if (fadeInComplete && snowParticles.material) {
                snowParticles.material.opacity = CONFIG.SNOW_ANIMATION.OPACITY_BASE + 
                                         Math.sin(time * CONFIG.SNOW_ANIMATION.OPACITY_FREQUENCY) * 
                                         CONFIG.SNOW_ANIMATION.OPACITY_VARIATION;
            }
        }
        
        /**
         * åˆ›å»ºæ ‘ç²’å­ç³»ç»Ÿï¼ˆæ‰¹å¤„ç†ç‰ˆæœ¬ï¼‰
         */
        function createTreeParticlesBatched() {
            const batches = [];
            const { PARTICLE_COUNT, BATCH_SIZE } = CONFIG.TREE;
            
            // å°†ç²’å­åˆ†ç»„ä¸ºæ‰¹æ¬¡ï¼Œæ¯ä¸ªæ‰¹æ¬¡æ˜¯ä¸€ç»„"æ˜Ÿå½¢ç²’å­"
            const BATCH_PARTICLE_COUNT = CONFIG.TREE.BATCH_SIZE; // æ¯ä¸ªæ˜Ÿå½¢ç²’å­åŒ…å«çš„åŸå§‹ç²’å­æ•°
            const batchCount = Math.floor(PARTICLE_COUNT / BATCH_PARTICLE_COUNT);
            
            // å­˜å‚¨æ‰€æœ‰ç²’å­çš„ç›®æ ‡ä½ç½®ã€é¢œè‰²å’Œå¤§å°
            const particleData = [];
            
            // å…ˆç”Ÿæˆæ‰€æœ‰ç²’å­çš„ç›®æ ‡ä½ç½®ã€é¢œè‰²å’Œå¤§å°
            for (let i = 0; i < PARTICLE_COUNT; i++) {
                const i3 = i * 3;
                
                // éšæœºé€‰æ‹©ç²’å­ç±»å‹ï¼ˆæ ‘å¹²æˆ–æ ‘å¶ï¼‰
                const isTrunk = Math.random() < CONFIG.TREE.TRUNK_RATIO;
                
                const data = {
                    index: i,
                    isTrunk: isTrunk,
                    targetPosition: new THREE.Vector3(),
                    color: new THREE.Color(),
                    size: 0
                };
                
                // ç”Ÿæˆç²’å­åœ¨æ ‘ä¸­çš„ä½ç½®å’Œå±æ€§
                if (isTrunk) {
                    generateTrunkParticleData(data);
                } else {
                    generateLeafParticleData(data);
                }
                
                particleData.push(data);
            }
            
            // åˆ›å»ºæ‰¹æ¬¡
            for (let batchIndex = 0; batchIndex < batchCount; batchIndex++) {
                // ä¸ºå½“å‰æ‰¹æ¬¡åˆ›å»ºå•ä¸ªå‡ ä½•ä½“ï¼ŒåŒ…å«æ‰€æœ‰ç²’å­
                const clusterPositions = new Float32Array(BATCH_PARTICLE_COUNT * 3);
                const targetPositions = new Float32Array(BATCH_PARTICLE_COUNT * 3);
                const colors = new Float32Array(BATCH_PARTICLE_COUNT * 3);
                const sizes = new Float32Array(BATCH_PARTICLE_COUNT);
                const baseSizes = new Float32Array(BATCH_PARTICLE_COUNT);
                
                for (let i = 0; i < BATCH_PARTICLE_COUNT; i++) {
                    const particleIndex = batchIndex * BATCH_PARTICLE_COUNT + i;
                    if (particleIndex >= PARTICLE_COUNT) break;
                    
                    const data = particleData[particleIndex];
                    const i3 = i * 3;
                    
                    // å°†ç²’å­éšæœºåˆ†å¸ƒåœ¨ç©ºé—´ä¸­ï¼Œå½¢æˆæ˜Ÿå½¢æ•ˆæœ
                    const randomRadius = CONFIG.ANIMATION.PARTICLE_ANIMATION.INITIAL_RADIUS;
                    clusterPositions[i3] = (Math.random() - 0.5) * randomRadius * 2;
                    clusterPositions[i3 + 1] = (Math.random() - 0.5) * randomRadius * 1.5 + randomRadius * 0.2;
                    clusterPositions[i3 + 2] = (Math.random() - 0.5) * randomRadius * 2;
                    
                    // ç›®æ ‡ä½ç½®
                    targetPositions[i3] = data.targetPosition.x;
                    targetPositions[i3 + 1] = data.targetPosition.y;
                    targetPositions[i3 + 2] = data.targetPosition.z;
                    
                    // é¢œè‰²
                    colors[i3] = data.color.r;
                    colors[i3 + 1] = data.color.g;
                    colors[i3 + 2] = data.color.b;
                    
                    // å¤§å° - åˆå§‹è®¾ç½®ä¸ºæ˜Ÿå½¢å¤§å°
                    const starSizeMultiplier = 3.0;
                    sizes[i] = data.size * starSizeMultiplier;
                    baseSizes[i] = data.size;
                }
                
                // åˆ›å»ºå‡ ä½•ä½“
                const geometry = new THREE.BufferGeometry();
                geometry.setAttribute('position', new THREE.BufferAttribute(clusterPositions, 3));
                geometry.setAttribute('targetPosition', new THREE.BufferAttribute(targetPositions, 3));
                geometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));
                geometry.setAttribute('size', new THREE.BufferAttribute(sizes, 1));
                geometry.setAttribute('baseSize', new THREE.BufferAttribute(baseSizes, 1));
                // æ˜Ÿæ˜Ÿé˜¶æ®µçš„å¤§å°å€ç‡
                const starSizes = new Float32Array(BATCH_PARTICLE_COUNT).fill(3.0);
                geometry.setAttribute('starSize', new THREE.BufferAttribute(starSizes, 1));
                
                // åˆ›å»ºæè´¨
                const material = new THREE.PointsMaterial({
                    size: 0.25,
                    vertexColors: true,
                    transparent: true,
                    opacity: 1,
                    blending: THREE.AdditiveBlending
                });
                
                const points = new THREE.Points(geometry, material);
                points.visible = false; // ä¸€å¼€å§‹ä¸å¯è§
                
                // ä¿å­˜æ‰¹æ¬¡æ•°æ®
                points.userData.originalPositions = clusterPositions;
                points.userData.targetPositions = targetPositions;
                points.userData.batchIndex = batchIndex;
                points.userData.starPhase = 0; // 0: æ˜Ÿå½¢é˜¶æ®µ, 1: è¿‡æ¸¡é˜¶æ®µ, 2: æœ€ç»ˆä½ç½®
                
                // å°†æ˜Ÿå½¢ç²’å­ç»„æ·»åŠ åˆ°æ‰¹æ¬¡æ•°ç»„
                batches.push(points);
            }
            
            return batches;
        }
        
        /**
         * ç”Ÿæˆæ ‘å¹²ç²’å­æ•°æ®
         */
        function generateTrunkParticleData(data) {
            const { TRUNK_HEIGHT, TRUNK_BASE_RADIUS, TRUNK_TOP_RADIUS } = CONFIG.TREE;
            
            // æ ‘å¹²é«˜åº¦
            const height = Math.random() * TRUNK_HEIGHT;
            
            // æ ‘å¹²åŠå¾„éšé«˜åº¦å˜åŒ–
            const radiusRatio = height / TRUNK_HEIGHT;
            const radius = TRUNK_BASE_RADIUS - (TRUNK_BASE_RADIUS - TRUNK_TOP_RADIUS) * radiusRatio;
            const angle = Math.random() * Math.PI * 2;
            
            // è®¾ç½®ä½ç½®
            data.targetPosition.set(
                Math.cos(angle) * radius,
                height,
                Math.sin(angle) * radius
            );
            
            // è®¾ç½®é¢œè‰²
            const trunkColor = CONFIG.COLORS.TREE[9];
            data.color.set(trunkColor.r, trunkColor.g, trunkColor.b);
            
            // è®¾ç½®å¤§å° - å¢å¤§æ ‘å¹²ç²’å­
            data.size = CONFIG.SIZES.TRUNK_BASE + Math.random() * CONFIG.SIZES.TRUNK_VARIANCE;
        }
        
        /**
         * ç”Ÿæˆæ ‘å¶ç²’å­æ•°æ®
         */
        function generateLeafParticleData(data) {
            const { 
                LEAF_HEIGHT_RANGE, LEAF_BASE_HEIGHT, LEAF_BASE_RADIUS, 
                RIBBON_PROBABILITY, RIBBON_COUNT, RIBBON_SPIRAL_TURNS 
            } = CONFIG.TREE;
            
            // éšæœºé«˜åº¦
            const randomHeight = Math.random() * LEAF_HEIGHT_RANGE + LEAF_BASE_HEIGHT;
            
            // åœ†é”¥å½¢çŠ¶è®¡ç®—
            const heightRatio = (randomHeight - LEAF_BASE_HEIGHT) / LEAF_HEIGHT_RANGE;
            const maxRadius = LEAF_BASE_RADIUS * (1 - heightRatio);
            
            // æ˜¯å¦ç”Ÿæˆå½©å¸¦ç²’å­
            const isRibbon = Math.random() < RIBBON_PROBABILITY;
            
            let radius, angle;
            let ribbonColorIndex = -1;
            
            if (isRibbon) {
                // å½©å¸¦ç²’å­ï¼šèºæ—‹åˆ†å¸ƒ
                const ribbonIndex = Math.floor(Math.random() * RIBBON_COUNT);
                const ribbonColors = CONFIG.COLORS.RIBBON;
                ribbonColorIndex = ribbonColors[Math.floor(Math.random() * ribbonColors.length)];
                
                const spiralOffset = (ribbonIndex / RIBBON_COUNT) * 2 * Math.PI;
                const spiralAngle = spiralOffset + (randomHeight - LEAF_BASE_HEIGHT) * 
                    (2 * Math.PI * RIBBON_SPIRAL_TURNS / LEAF_HEIGHT_RANGE);
                
                // å½©å¸¦ç²’å­åªåœ¨æ ‘çš„æœ€å¤–å±‚ç”Ÿæˆ
                radius = maxRadius * (0.92 + Math.random() * 0.08);
                angle = spiralAngle + (Math.random() - 0.5) * 0.1;
            } else {
                // æ™®é€šæ ‘å¶ç²’å­ï¼šéšæœºåˆ†å¸ƒ
                radius = Math.sqrt(Math.random()) * maxRadius;
                angle = Math.random() * Math.PI * 2;
                
                // æŒ‰é«˜åº¦è°ƒæ•´å¯†åº¦
                const densityFactor = 1.2 - Math.abs(heightRatio - 0.5) * 0.4;
                
                // è¿™é‡Œä¸å†ç”Ÿæˆè¿œç¦»æ ‘çš„ä¸å¯è§ç²’å­ï¼Œè€Œæ˜¯ç›´æ¥è·³è¿‡åˆ›å»ºï¼Œè¿™æ ·æ›´é«˜æ•ˆ
                if (Math.random() <= 0.2 * densityFactor) {
                    // è·³è¿‡åˆ›å»ºè¯¥ç²’å­ï¼Œå‡å°‘ä¸å¿…è¦çš„æ¸²æŸ“
                    data.targetPosition.set(0, 0, 0);
                    data.color.setRGB(0, 0, 0); // è®¾ç½®ä¸ºé»‘è‰²
                    data.size = 0; // è®¾ç½®ä¸ºä¸å¯è§å¤§å°
                    return;
                }
            }
            
            // è®¾ç½®ä½ç½®
            data.targetPosition.set(
                Math.cos(angle) * radius,
                randomHeight,
                Math.sin(angle) * radius
            );
            
            // è®¾ç½®é¢œè‰²
            const colorIndex = determineLeafColorIndex(isRibbon, ribbonColorIndex, heightRatio);
            const color = CONFIG.COLORS.TREE[colorIndex];
            
            // åº”ç”¨é˜´å½±æ•ˆæœï¼ˆä»…æ™®é€šæ ‘å¶ï¼‰- è°ƒäº®
            if (!isRibbon) {
                const shadowFactor = CONFIG.BRIGHTNESS.TRUNK_SHADOW_BASE + heightRatio * CONFIG.BRIGHTNESS.TRUNK_SHADOW_HEIGHT_FACTOR;
                data.color.setRGB(color.r * shadowFactor, color.g * shadowFactor, color.b * shadowFactor);
            } else {
                // å½©å¸¦ä¹Ÿç¨å¾®è°ƒäº®
                const brightness = CONFIG.BRIGHTNESS.RIBBON_BRIGHTNESS_MULTIPLIER;
                data.color.setRGB(color.r * brightness, color.g * brightness, color.b * brightness);
            }
            
            // è®¾ç½®å¤§å° - å¢å¤§æ ‘å¶ç²’å­
            const sizeFactor = heightRatio > 0.8 ? CONFIG.SIZES.TOP_SIZE_FACTOR : CONFIG.SIZES.NORMAL_SIZE_FACTOR;
            const ribbonSizeFactor = isRibbon ? CONFIG.SIZES.RIBBON_MULTIPLIER : 1.0;
            data.size = (CONFIG.SIZES.LEAF_BASE + Math.random() * CONFIG.SIZES.LEAF_VARIANCE) * 
                       sizeFactor * ribbonSizeFactor * 
                       (CONFIG.SIZES.SIZE_VARIANCE_BASE + Math.random() * CONFIG.SIZES.SIZE_VARIANCE_RANGE);
        }
        
        /**
         * åˆ›å»ºåœ£è¯æ ‘
         */
        function createChristmasTree(scene) { // åœ£è¯æ ‘åˆ›å»ºå‡½æ•°å¼€å§‹
            
            // åˆ›å»ºç²’å­ç³»ç»Ÿï¼ˆæ‰¹å¤„ç†ç‰ˆæœ¬ï¼‰
            const particleBatches = createTreeParticlesBatched(); // è°ƒç”¨æ‰¹æ¬¡ç²’å­åˆ›å»ºå‡½æ•°
            
            // åˆ›å»ºæ ‘çš„æ ¹å®¹å™¨
            const treeGroup = new THREE.Group(); // åˆ›å»º3Dç»„å¯¹è±¡ä½œä¸ºæ ‘çš„æ ¹å®¹å™¨
            
            // æ·»åŠ æ‰€æœ‰æ‰¹æ¬¡åˆ°æ ‘ç»„ï¼ˆæ¯ä¸ªæ‰¹æ¬¡æ˜¯ä¸€ä¸ªPointså¯¹è±¡ï¼‰
            particleBatches.forEach(batch => { // éå†æ‰€æœ‰ç²’å­æ‰¹æ¬¡
                treeGroup.add(batch); // å°†æ‰¹æ¬¡æ·»åŠ åˆ°æ ‘ç»„ä¸­
            }); // éå†ç»“æŸ
            scene.add(treeGroup); // å°†æ ‘ç»„æ·»åŠ åˆ°åœºæ™¯ä¸­
            
            // æ·»åŠ å½©è‰²è£…é¥°ç¯
            const coloredLightObjects = addColoredLights(treeGroup); // è°ƒç”¨å½©è‰²ç¯å…‰æ·»åŠ å‡½æ•°
            
            // è®¾ç½®æ ‘çš„ä½ç½®å’Œç¼©æ”¾
            treeGroup.position.copy(CONFIG.TREE.POSITION_OFFSET); // è®¾ç½®æ ‘çš„ä½ç½®åç§»
            treeGroup.scale.copy(CONFIG.TREE.SCALE); // è®¾ç½®æ ‘çš„ç¼©æ”¾æ¯”ä¾‹
            treeGroup.updateMatrixWorld(true); // æ›´æ–°ä¸–ç•ŒçŸ©é˜µ
            
            // åˆå§‹åŒ–åŠ¨ç”»çŠ¶æ€
            const animationState = { // åˆ›å»ºåŠ¨ç”»çŠ¶æ€å¯¹è±¡
                startTime: Date.now(), // è®°å½•å¼€å§‹æ—¶é—´
                completed: false, // åŠ¨ç”»æ˜¯å¦å®Œæˆæ ‡è®°
                isRotating: false, // æ—‹è½¬çŠ¶æ€æ ‡è®°
                snowStarted: false, // é›ªèŠ±æ˜¯å¦å¼€å§‹æ ‡è®°
                snowStartTime: 0, // é›ªèŠ±å¼€å§‹æ—¶é—´æˆ³
                treeCompleted: false // æ ‘æ˜¯å¦å®Œå…¨æˆå‹æ ‡è®°
            }; // animationStateå¯¹è±¡å®šä¹‰ç»“æŸ
            
            return { // è¿”å›åˆ›å»ºçš„åœ£è¯æ ‘ç›¸å…³å¯¹è±¡
                treeGroup, // æ ‘ç»„
                particleBatches, // ç²’å­æ‰¹æ¬¡
                coloredLightObjects, // å½©è‰²ç¯å…‰
                animationState // åŠ¨ç”»çŠ¶æ€
            }; // returnè¯­å¥ç»“æŸ
        } // createChristmasTreeå‡½æ•°ç»“æŸ
        
        

        
        
        /**
         * ç¡®å®šæ ‘å¶é¢œè‰²ç´¢å¼•
         */
        function determineLeafColorIndex(isRibbon, ribbonColorIndex, heightRatio) {
            if (isRibbon && ribbonColorIndex !== -1) {
                return ribbonColorIndex;
            }
            
            // æ™®é€šæ ‘å¶ç²’å­é¢œè‰²
            const rand = Math.random();
            if (rand < 0.97) {
                return Math.floor(Math.random() * 4); // é€‰æ‹©å‰4ç§æ·±ç»¿/å†·ç»¿é¢œè‰²
            } else {
                return 7 + Math.floor(Math.random() * 2); // é€‰æ‹©é«˜å…‰é¢œè‰²
            }
        }
        
        /**
         * æ·»åŠ å½©è‰²è£…é¥°ç¯
         */
        function addColoredLights(treeGroup) {
            const coloredLightObjects = [];
            
            CONFIG.LIGHTS.forEach((lightConfig, index) => {
                const coloredLight = new THREE.PointLight(
                    lightConfig.color, 
                    lightConfig.intensity, 
                    lightConfig.distance
                );
                
                // éšæœºä½ç½®
                const angle = (index / CONFIG.LIGHTS.length) * Math.PI * 2;
                const radius = 3 + Math.random() * 2;
                coloredLight.position.set(
                    Math.cos(angle) * radius,
                    5 + Math.random() * 5,
                    Math.sin(angle) * radius
                );
                
                treeGroup.add(coloredLight);
                coloredLightObjects.push(coloredLight);
            });
            
            return coloredLightObjects;
        }
        
        /**
         * åˆå§‹åŒ–ç›¸æœºæ§åˆ¶å‚æ•°
         */
        function initCameraControls(camera) {
            const cameraDistance = camera.position.distanceTo(CONFIG.CAMERA.TARGET);
            
            return {
                rotationX: THREE.MathUtils.degToRad(0),
                rotationY: THREE.MathUtils.degToRad(0),
                distance: cameraDistance
            };
        }
        
        /**
         * æ›´æ–°æ‰¹æ¬¡å¯è§æ€§
         */
        function updateBatchVisibility(batches, startTime) {
            const elapsed = Date.now() - startTime;
            const interval = CONFIG.ANIMATION_PHASES.BATCH_PROCESSING_INTERVAL;
            const visibleCount = Math.floor(elapsed / interval);
            
            for (let i = 0; i < batches.length; i++) {
                if (i <= visibleCount && !batches[i].userData.startTime) {
                    batches[i].visible = true;
                    batches[i].userData.startTime = Date.now();
                }
            }
        }
        
        /**
         * æ£€æŸ¥æ ‘æ˜¯å¦å®Œå…¨æˆå‹
         */
        function checkTreeCompletion(batches, animationState) {
            // æ£€æŸ¥æ‰€æœ‰æ‰¹æ¬¡æ˜¯å¦éƒ½åˆ°è¾¾æœ€ç»ˆä½ç½®ï¼ˆstarPhase = 2ï¼‰
            const allBatchesCompleted = batches.every(batch => 
                batch.visible && batch.userData.starPhase >= 2
            );
            
            if (allBatchesCompleted && !animationState.treeCompleted) {
                animationState.treeCompleted = true;
                return true; // æ ‘åˆšå®Œæˆ
            }
            
            return false; // æ ‘æœªå®Œæˆæˆ–å·²ç»å®Œæˆ
        }

        /**
         * æ›´æ–°æ‰¹æ¬¡ç§»åŠ¨åŠ¨ç”»
         */
        function updateBatchMovement(batches, startTime) {
            const now = Date.now();
            const starPhaseDuration = CONFIG.ANIMATION_PHASES.SPARKLE_DURATION;
            const transitionDuration = CONFIG.ANIMATION_PHASES.TRANSITION_DURATION;
            
            // è®¡ç®—å…³é”®æ—¶é—´ç‚¹
            const totalBatches = Math.ceil(CONFIG.TREE.PARTICLE_COUNT / CONFIG.TREE.BATCH_SIZE);
            const allParticlesVisibleTime = startTime + 
                CONFIG.ANIMATION_PHASES.BATCH_PROCESSING_INTERVAL * totalBatches + 
                CONFIG.ANIMATION_PHASES.ALL_PARTICLES_VISIBLE_DELAY;
            const starPhaseEndTime = allParticlesVisibleTime + CONFIG.ANIMATION_PHASES.SPARKLE_DURATION;
            const transitionEndTime = starPhaseEndTime + CONFIG.ANIMATION_PHASES.TRANSITION_DURATION;
            
            batches.forEach((points, batchIndex) => {
                const time = Date.now() * 0.001;
                const batchAppearTime = startTime + batchIndex * CONFIG.ANIMATION_PHASES.BATCH_PROCESSING_INTERVAL;
                const elapsedSinceAppear = now - batchAppearTime;
                
                if (elapsedSinceAppear <= 0) {
                    // æ‰¹æ¬¡è¿˜æœªå‡ºç°ï¼Œä¿æŒé€æ˜
                    points.material.opacity = 0;
                    return;
                }
                
                // æ ¹æ®å½“å‰æ—¶é—´ç¡®å®šåŠ¨ç”»é˜¶æ®µ
                let sparkle, convergeBrightness;
                
                if (now < allParticlesVisibleTime) {
                    // é˜¶æ®µ0ï¼šç²’å­å‡ºç°é˜¶æ®µï¼Œé€æ¸æ˜¾ç¤º
                    const appearProgress = THREE.MathUtils.clamp(elapsedSinceAppear / CONFIG.TIMING.APPEAR_DURATION, 0, 1);
                    sparkle = CONFIG.BRIGHTNESS.SPARKLE_BASE_INITIAL + Math.sin(time * 6 + batchIndex) * CONFIG.BRIGHTNESS.SPARKLE_AMPLITUDE_INITIAL;
                    convergeBrightness = appearProgress;
                } else if (now < starPhaseEndTime) {
                    // é˜¶æ®µ1ï¼šæ˜Ÿå½¢é—ªè€€é˜¶æ®µ
                    sparkle = CONFIG.BRIGHTNESS.SPARKLE_BASE_INITIAL + Math.sin(time * 6 + batchIndex) * CONFIG.BRIGHTNESS.SPARKLE_AMPLITUDE_INITIAL;
                    convergeBrightness = 1.0;
                } else if (now < transitionEndTime) {
                    // é˜¶æ®µ2ï¼šè¿‡æ¸¡æ±‡èšé˜¶æ®µ
                    const transitionProgress = THREE.MathUtils.clamp((now - starPhaseEndTime) / transitionDuration, 0, 1);
                    sparkle = CONFIG.BRIGHTNESS.SPARKLE_BASE_INITIAL + Math.sin(time * 6 + batchIndex) * CONFIG.BRIGHTNESS.SPARKLE_AMPLITUDE_INITIAL;
                    convergeBrightness = 1.0;
                } else {
                    // é˜¶æ®µ3ï¼šæœ€ç»ˆå½¢æˆæ ‘
                    sparkle = CONFIG.BRIGHTNESS.SPARKLE_BASE_FINAL + Math.sin(time * 3 + batchIndex) * CONFIG.BRIGHTNESS.SPARKLE_AMPLITUDE_FINAL;
                    convergeBrightness = 1.0;
                }
                
                // æœ€ç»ˆé€æ˜åº¦
                points.material.opacity = sparkle * convergeBrightness;
                
                const geometry = points.geometry;
                const positions = geometry.attributes.position.array;
                const targetPositions = geometry.attributes.targetPosition.array;
                
                // é˜¶æ®µ0å’Œ1ï¼šç²’å­å‡ºç°å’Œæ˜Ÿå½¢é—ªè€€é˜¶æ®µ
                if (now < starPhaseEndTime) {
                    // é™æ€æ˜¾ç¤ºï¼Œæ— æ¼‚ç§»æ•ˆæœ
                    for (let i = 0; i < positions.length; i += 3) {
                        // ç›´æ¥ä½¿ç”¨åŸå§‹ä½ç½®ï¼Œä¿æŒé™æ€
                        positions[i] = points.userData.originalPositions[i];
                        positions[i + 1] = points.userData.originalPositions[i + 1];
                        positions[i + 2] = points.userData.originalPositions[i + 2];
                    }
                    
                    geometry.attributes.position.needsUpdate = true;
                    
                    // â­ æ˜Ÿå½¢é˜¶æ®µï¼ˆé—ªè€€ï¼‰- æ§åˆ¶size
                    const sizes = geometry.attributes.size.array;
                    const baseSizes = geometry.attributes.baseSize.array;
                    const starSizes = geometry.attributes.starSize.array;
                    
                    const sparkle = 1 + Math.sin(time * 6 + batchIndex) * 0.3;
                    
                    for (let i = 0; i < sizes.length; i++) {
                        sizes[i] = baseSizes[i] * starSizes[i] * sparkle;
                    }
                    
                    geometry.attributes.size.needsUpdate = true;
                } 
                // é˜¶æ®µ2ï¼šè¿‡æ¸¡æ±‡èšé˜¶æ®µ
                else if (now < transitionEndTime) {
                    const elapsedSinceTransition = now - starPhaseEndTime;
                    const t = elapsedSinceTransition / transitionDuration;
                    // ä½¿ç”¨æ›´æ…¢çš„ç¼“åŠ¨å‡½æ•°ï¼Œä½¿è¿‡æ¸¡æ›´å¹³ç¼“
                    const eased = t < 0.5 ? 2 * t * t : 1 - Math.pow(-2 * t + 2, 2) / 2;
                    
                    // é€šè¿‡BufferAttributeæ•°ç»„è¿›è¡Œä½ç½®æ’å€¼
                    for (let i = 0; i < positions.length; i += 3) {
                        const startX = points.userData.originalPositions[i];
                        const startY = points.userData.originalPositions[i + 1];
                        const startZ = points.userData.originalPositions[i + 2];
                        
                        const targetX = targetPositions[i];
                        const targetY = targetPositions[i + 1];
                        const targetZ = targetPositions[i + 2];
                        
                        // ç›´çº¿è½¨è¿¹æ±‡èš
                        positions[i] = startX + (targetX - startX) * eased;
                        positions[i + 1] = startY + (targetY - startY) * eased;
                        positions[i + 2] = startZ + (targetZ - startZ) * eased;
                    }
                    
                    geometry.attributes.position.needsUpdate = true;
                    
                    // â­ è¿‡æ¸¡é˜¶æ®µï¼ˆå¤§ â†’ å°ï¼Œè¿ç»­ç¼©æ”¾ï¼‰- æ§åˆ¶size
                    const sizes = geometry.attributes.size.array;
                    const baseSizes = geometry.attributes.baseSize.array;
                    const starSizes = geometry.attributes.starSize.array;
                    
                    const scale = THREE.MathUtils.lerp(
                        starSizes[0], // æ˜Ÿæ˜Ÿé˜¶æ®µå€ç‡
                        1.0,          // æœ€ç»ˆå€ç‡
                        eased
                    );
                    
                    for (let i = 0; i < sizes.length; i++) {
                        sizes[i] = baseSizes[i] * scale;
                    }
                    
                    geometry.attributes.size.needsUpdate = true;
                    
                    points.userData.starPhase = eased; // è®°å½•è¿‡æ¸¡è¿›åº¦
                } 
                // é˜¶æ®µ3ï¼šå®Œå…¨å½¢æˆæ ‘å½¢æ€
                else {
                    // é€šè¿‡BufferAttributeæ•°ç»„ç¡®ä¿æ‰€æœ‰ç²’å­ä½äºæœ€ç»ˆä½ç½®
                    for (let i = 0; i < positions.length; i += 3) {
                        positions[i] = targetPositions[i];
                        positions[i + 1] = targetPositions[i + 1];
                        positions[i + 2] = targetPositions[i + 2];
                    }
                    
                    geometry.attributes.position.needsUpdate = true;
                    
                    // â­ æœ€ç»ˆé˜¶æ®µï¼ˆç¨³å®šå°ç²’å­ï¼‰- æ§åˆ¶size
                    const sizes = geometry.attributes.size.array;
                    const baseSizes = geometry.attributes.baseSize.array;
                    
                    for (let i = 0; i < sizes.length; i++) {
                        sizes[i] = baseSizes[i];
                    }
                    
                    geometry.attributes.size.needsUpdate = true;
                    
                    points.userData.starPhase = 2;
                }
            });
        }
        
        /**
         * åŠ¨ç”»å¾ªç¯
         */
        function animate() { // åŠ¨ç”»ä¸»å¾ªç¯å‡½æ•°
            
            requestAnimationFrame(animate);
            
            if (particlesStarted && animationParams) {
                const { // è§£æ„è·å–åŠ¨ç”»å‚æ•°å¯¹è±¡ä¸­çš„æ‰€æœ‰å¿…è¦ç»„ä»¶
                    scene, // 3Dåœºæ™¯
                    camera, // ç›¸æœº
                    renderer, // æ¸²æŸ“å™¨
                    snowSystem, // é›ªèŠ±ç³»ç»Ÿ
                    treeGroup, // æ ‘ç»„
                    particleBatches, // ç²’å­æ‰¹æ¬¡
                    coloredLightObjects, // å½©è‰²ç¯å…‰
                    cameraControls, // ç›¸æœºæ§åˆ¶
                    animationState // åŠ¨ç”»çŠ¶æ€
                } = animationParams; // è§£æ„èµ‹å€¼ç»“æŸ
                
                // è·å–å½“å‰æ—¶é—´
                const time = Date.now() * 0.001; // è·å–å½“å‰æ—¶é—´ï¼ˆè½¬æ¢ä¸ºç§’ï¼‰
                
                // æ›´æ–°æ‰¹æ¬¡å¯è§æ€§
                updateBatchVisibility(particleBatches, animationState.startTime); // æ›´æ–°ç²’å­æ‰¹æ¬¡æ˜¾ç¤ºçŠ¶æ€
                updateBatchMovement(particleBatches, animationState.startTime); // æ›´æ–°ç²’å­ç§»åŠ¨åŠ¨ç”»
                
                // åº”ç”¨æ ‘çš„å€¾æ–œï¼ˆå§‹ç»ˆåº”ç”¨ï¼‰
                treeGroup.rotation.x = CONFIG.TREE.TILT_X;
                
                // åœ£è¯æ ‘æ—‹è½¬é€»è¾‘
                const now = Date.now();
            // è®¡ç®—å…³é”®æ—¶é—´ç‚¹
            const totalBatches = Math.ceil(CONFIG.TREE.PARTICLE_COUNT / CONFIG.TREE.BATCH_SIZE);
            const allParticlesVisibleTime = animationState.startTime + 
                CONFIG.ANIMATION_PHASES.BATCH_PROCESSING_INTERVAL * totalBatches + 
                CONFIG.ANIMATION_PHASES.ALL_PARTICLES_VISIBLE_DELAY;
            const starPhaseEndTime = allParticlesVisibleTime + CONFIG.ANIMATION_PHASES.SPARKLE_DURATION;
            const transitionDuration = CONFIG.ANIMATION_PHASES.TRANSITION_DURATION;
            const transitionEndTime = starPhaseEndTime + transitionDuration;
                
                // ä½¿ç”¨ç›‘å¬å™¨æ£€æµ‹æ ‘æ˜¯å¦å®Œå…¨æˆå‹
                const treeJustCompleted = checkTreeCompletion(particleBatches, animationState);
                
                // æ ‘æˆå‹æ£€æŸ¥å’Œé›ªèŠ±å¯åŠ¨ï¼ˆä½¿ç”¨ç›‘å¬å™¨ï¼‰
                if (!animationState.snowStarted && treeJustCompleted) {
                    snowSystem.snowParticles.visible = true;
                    snowSystem.snowParticles.material.opacity = 0;
                    animationState.snowStarted = true;
                    animationState.snowStartTime = now;
                }
                
            // åªæœ‰åœ¨è¿‡æ¸¡æ±‡èšé˜¶æ®µæ‰å¼€å§‹åŠ é€Ÿæ—‹è½¬
            if (now >= starPhaseEndTime && now < transitionEndTime) {
                treeGroup.rotation.y += CONFIG.ANIMATION_PHASES.ROTATION_SPEED_ACCELERATED; // ç§»åŠ¨é˜¶æ®µåŠ é€Ÿæ—‹è½¬
                if (!animationState.isRotating) {
                    animationState.isRotating = true;
                }
            } else if (now >= transitionEndTime) {
                treeGroup.rotation.y += CONFIG.ANIMATION_PHASES.ROTATION_SPEED_NORMAL; // å®Œæˆåæ­£å¸¸æ—‹è½¬
            }
                
                // æ›´æ–°ç›¸æœºä½ç½®
                updateCameraPosition(camera, cameraControls);
                
                // åªæœ‰åœ¨é›ªèŠ±å¼€å§‹åæ‰æ›´æ–°é›ªèŠ±åŠ¨ç”»
                if (animationState.snowStarted) {
                    // æ·»åŠ æ·¡å…¥æ•ˆæœ
                    let fadeInComplete = false;
                    if (animationState.snowStartTime > 0) {
                        const snowFadeInDuration = CONFIG.TIMING.SNOW_FADE_IN_DURATION;
                        const elapsedSinceSnowStart = now - animationState.snowStartTime;
                        const fadeInProgress = THREE.MathUtils.clamp(elapsedSinceSnowStart / snowFadeInDuration, 0, 1);
                        snowSystem.snowParticles.material.opacity = fadeInProgress * CONFIG.TIMING.SNOW_OPACITY_TARGET;
                        fadeInComplete = fadeInProgress >= CONFIG.TIMING.FADE_IN_PROGRESS_CLAMP;
                    }
                    
                    snowSystem.updateSnowAnimation(time, fadeInComplete, animationState.snowStartTime);
                }
                
                // ç¦ç”¨æ­¤å‡½æ•°ï¼Œé¿å…ç ´åsizeçš„ç¨³å®šæ€§
                // updateParticlesAnimation(particleBatches, time, animationState);
                
                // æ›´æ–°å½©è‰²è£…é¥°ç¯
                updateColoredLights(coloredLightObjects, time);
            }
            
            // æ¸²æŸ“åœºæ™¯
            renderer.render(scene, camera); // æ¸²æŸ“å½“å‰å¸§
        } // animateå‡½æ•°ç»“æŸ
        
        /**
         * æ›´æ–°ç›¸æœºä½ç½®
         */
        function updateCameraPosition(camera, cameraControls) {
            const spherical = new THREE.Spherical();
            spherical.radius = cameraControls.distance;
            spherical.theta = cameraControls.rotationY;
            spherical.phi = cameraControls.rotationX + Math.PI / 2;
            
            camera.position.setFromSpherical(spherical);
            camera.position.add(CONFIG.CAMERA.TARGET);
            camera.lookAt(CONFIG.CAMERA.TARGET);
        }
        
        

        
        /**
         * æ›´æ–°ç²’å­åŠ¨ç”»
         */
        function updateParticlesAnimation(particleBatches, time, animationState) {
            // æ£€æŸ¥æ‰€æœ‰ç²’å­æ˜¯å¦å·²å®Œæˆæ˜Ÿå½¢åˆ°æ ‘å½¢æ€çš„è¿‡æ¸¡
            const allParticlesTransitioned = particleBatches.every(points => 
                points.userData.starPhase >= 2
            );
            
            if (!allParticlesTransitioned) return;
            
            // åœ¨æ‰€æœ‰ç²’å­å®Œæˆè¿‡æ¸¡åï¼Œæ·»åŠ å¾®å¦™çš„åŠ¨æ€æ•ˆæœ
            particleBatches.forEach(points => {
                const geometry = points.geometry;
                const colors = geometry.attributes.color.array;
                const sizes = geometry.attributes.size.array;
                
                // âŒ ä¸å†ä½¿ç”¨ material.size
            });
        }
        
        /**
         * æ›´æ–°å½©è‰²è£…é¥°ç¯
         */
        function updateColoredLights(coloredLightObjects, time) {
            coloredLightObjects.forEach((light, index) => {
                const lightConfig = CONFIG.LIGHTS[index];
                const baseIntensity = lightConfig.intensity;
                const flickerSpeed = lightConfig.flickerSpeed;
                
                // è®¡ç®—é—ªçƒå¼ºåº¦
                const flicker = 0.5 + Math.sin(time * flickerSpeed * Math.PI * 2) * 0.5;
                light.intensity = baseIntensity * flicker;
            });
        }
        
        /**
         * çª—å£å¤§å°è°ƒæ•´äº‹ä»¶å¤„ç†
         */
        function onWindowResize(camera, renderer) { // çª—å£å¤§å°è°ƒæ•´å¤„ç†å‡½æ•°
            camera.aspect = window.innerWidth / window.innerHeight; // æ›´æ–°ç›¸æœºå®½é«˜æ¯”
            camera.updateProjectionMatrix(); // æ›´æ–°ç›¸æœºæŠ•å½±çŸ©é˜µ
            renderer.setSize(window.innerWidth, window.innerHeight); // æ›´æ–°æ¸²æŸ“å™¨å°ºå¯¸
        } // onWindowResizeå‡½æ•°ç»“æŸ
    </script> <!-- JavaScriptä»£ç ç»“æŸ -->
</body> <!-- æ–‡æ¡£ä¸»ä½“ç»“æŸ -->
</html> <!-- HTMLæ–‡æ¡£ç»“æŸ -->
