<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>圣诞树</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background-color: #000;
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
        }
        canvas {
            display: block;
        }
    </style>
</head>
<body>
    <script src="three.min.js"></script>
    <script>
        // 常量定义：定义所有系统参数配置
        const CONFIG = { // 创建全局配置对象
            // 雪花系统配置
            SNOW: { // 雪花相关参数
                COUNT: 3000, // 雪花粒子总数，减少数量提高性能
                MAX_HEIGHT: 30, // 雪花最大高度（Y轴坐标上限）
                MIN_HEIGHT: -5, // 雪花最小高度（Y轴坐标下限）
                RANGE: 40, // 雪花分布范围（X和Z轴的随机范围）
                WIND_DIRECTION: new THREE.Vector3(-0.015, 0, -0.008), // 风的方向向量（X和Z轴偏移）
                BASE_SPEED: 0.055, // 雪花基础下落速度，已提高
                SPEED_VARIANCE: 0.12 // 速度变化范围，增加使下落更自然
            }, // SNOW配置结束
            // 树系统配置
            TREE: { // 圣诞树相关参数
                PARTICLE_COUNT: 10000, // 树的总粒子数量
                TRUNK_RATIO: 0.15, // 树干粒子比例（15%）
                TRUNK_HEIGHT: 2, // 树干高度
                TRUNK_BASE_RADIUS: 0.6, // 树干底部半径
                TRUNK_TOP_RADIUS: 0.2, // 树干顶部半径
                LEAF_HEIGHT_RANGE: 10, // 树叶高度范围
                LEAF_BASE_HEIGHT: 1, // 树叶起始高度
                LEAF_BASE_RADIUS: 4.26, // 树叶基础半径
                RIBBON_PROBABILITY: 0.04, // 彩带粒子出现概率（3%）
                RIBBON_COUNT: 3, // 彩带数量
                RIBBON_SPIRAL_TURNS: 3, // 彩带螺旋圈数
                POSITION_OFFSET: new THREE.Vector3(0, -7, 0), // 树的位置偏移向量
                SCALE: new THREE.Vector3(2, 2.2, 2), // 树的缩放比例
                TILT_X: THREE.MathUtils.degToRad(-30), // X轴倾斜角度（转换为弧度）
                ROTATION_SPEED: -0.002, // 树的旋转速度（负值表示逆时针）
                BATCH_SIZE: 600, // 每批处理的粒子数量
                BATCH_INTERVAL: 120 // 批次间隔时间（毫秒），控制星星点亮速度
            }, // TREE配置结束
            // 相机配置
            CAMERA: { // 相机相关参数
                FOV: 65, // 视场角度（度数）
                NEAR: 0.1, // 近裁剪面距离
                FAR: 1000, // 远裁剪面距离
                INITIAL_POSITION: new THREE.Vector3(12, 7, 12), // 相机初始位置
                TARGET: new THREE.Vector3(0, 4, 0) // 相机观察目标点
            }, // CAMERA配置结束
            // 灯光配置
            LIGHTS: [ // 装饰灯光配置数组
                { color: 0xff0000, intensity: 0.8, distance: 5, flickerSpeed: 1.0 },  // 红色灯光
                { color: 0x00ff00, intensity: 0.6, distance: 4, flickerSpeed: 1.2 },  // 绿色灯光
                { color: 0x0000ff, intensity: 0.7, distance: 4.5, flickerSpeed: 2.0 },  // 蓝色灯光
                { color: 0xffff00, intensity: 0.9, distance: 5.5, flickerSpeed: 1.5 }   // 黄色灯光
            ], // LIGHTS配置结束
            // 颜色配置
            COLORS: { // 颜色相关参数
                TREE: [ // 树的颜色数组
                    new THREE.Color(0x008800),  // 深绿色（树主体）
                    new THREE.Color(0x006600),  // 更深的绿色（树主体）
                    new THREE.Color(0x009933),  // 冷绿色（树主体）
                    new THREE.Color(0x005522),  // 最冷的绿色（树主体）
                    new THREE.Color(0xff0000),  // 红色（装饰）
                    new THREE.Color(0xffcc00),  // 金色（装饰）
                    new THREE.Color(0x0000cc),  // 深蓝色（装饰）
                    new THREE.Color(0xffffcc),  // 淡黄色（高光）
                    new THREE.Color(0xffffff),  // 白色（高光）
                    new THREE.Color(0x5D3A00)   // 深棕色（树干）
                ], // TREE颜色数组结束
                RIBBON: [4, 5, 6]  // 彩带使用的颜色索引（对应TREE数组中的颜色）
            }, // COLORS配置结束
            // 动画配置
            ANIMATION: { // 动画相关参数
                PULSE_SPEED: 2.0, // 脉冲动画速度
                PULSE_AMOUNT: 0.1, // 脉冲动画幅度
                DECORATION_FLICKER_SPEED: 5.0, // 装饰灯闪烁速度
                PARTICLE_ANIMATION: { // 粒子动画参数
                    STAR_PHASE_DURATION: 4000,  // 星形闪耀阶段持续时间（毫秒）
                    TRANSITION_DURATION: 8000,   // 从星形到树形态过渡时间（毫秒）
                    START_DELAY: 200,  // 开始延迟（毫秒）
                    EASE_FACTOR: 1.2,  // 缓动因子，控制过渡平滑度
                    INITIAL_RADIUS: 40,  // 粒子初始随机分布半径
                    ALL_PARTICLES_VISIBLE_DELAY: 500   // 等待所有粒子出现后再开始移动
                } // PARTICLE_ANIMATION结束
            } // ANIMATION配置结束
        }; // CONFIG对象结束

        // 页面加载完成后初始化Three.js
        window.addEventListener('DOMContentLoaded', initThreeJs); // DOM加载完成事件监听器
        
        /**
         * Three.js主初始化函数
         * 负责创建和配置3D场景、相机、渲染器等核心组件
         */
        function initThreeJs() { // Three.js初始化函数开始
            // 创建Three.js场景对象
            const scene = new THREE.Scene(); // 创建3D场景容器
            
            // 初始化相机
            const camera = createCamera(); // 调用相机创建函数
            
            // 初始化渲染器
            const renderer = createRenderer(); // 调用渲染器创建函数
            
            // 加载背景图片
            loadBackgroundTexture(scene, renderer, camera); // 调用背景纹理加载函数，传入必要参数
            
            // 创建雪花粒子系统（初始隐藏）
            const snowSystem = createSnowParticles(scene); // 调用雪花系统创建函数
            snowSystem.snowParticles.visible = false; // 初始隐藏雪粒子
            
            // 创建圣诞树
            const { // 解构赋值，获取创建圣诞树返回的多个对象
                treeGroup, // 树的组对象
                particleBatches, // 粒子批次数组
                coloredLightObjects, // 彩色灯光对象数组
                animationState // 动画状态对象
            } = createChristmasTree(scene); // 调用圣诞树创建函数
            
            // 初始化相机控制参数
            const cameraControls = initCameraControls(camera); // 调用相机控制初始化函数
            
            // 开始动画循环
            animate({ // 调用动画循环函数，传入所有必要参数
                scene, // 3D场景
                camera, // 相机
                renderer, // 渲染器
                snowSystem, // 雪花系统
                treeGroup, // 树组
                particleBatches, // 粒子批次
                coloredLightObjects, // 彩色灯光
                cameraControls, // 相机控制
                animationState // 动画状态
            }); // animate调用结束
            
            // 添加窗口大小调整事件监听
            window.addEventListener('resize', () => onWindowResize(camera, renderer)); // 监听窗口大小变化
        } // initThreeJs函数结束
        
        /**
         * 创建透视相机
         */
        function createCamera() { // 相机创建函数开始
            const camera = new THREE.PerspectiveCamera( // 创建透视相机对象
                CONFIG.CAMERA.FOV, // 视场角度
                window.innerWidth / window.innerHeight, // 宽高比
                CONFIG.CAMERA.NEAR, // 近裁剪面
                CONFIG.CAMERA.FAR // 远裁剪面
            ); // PerspectiveCamera创建结束
            
            camera.position.copy(CONFIG.CAMERA.INITIAL_POSITION); // 设置相机初始位置
            camera.lookAt(CONFIG.CAMERA.TARGET); // 设置相机观察目标
            
            return camera; // 返回相机对象
        } // createCamera函数结束
        
        /**
         * 创建WebGL渲染器
         */
        function createRenderer() { // 渲染器创建函数开始
            const renderer = new THREE.WebGLRenderer({ antialias: true }); // 创建WebGL渲染器，启用抗锯齿
            renderer.setSize(window.innerWidth, window.innerHeight); // 设置渲染器尺寸为窗口大小
            renderer.shadowMap.enabled = false; // 禁用阴影映射提高性能
            document.body.appendChild(renderer.domElement); // 将渲染器DOM元素添加到页面
            
            return renderer; // 返回渲染器对象
        } // createRenderer函数结束
        
        /**
         * 加载背景纹理
         */
        function loadBackgroundTexture(scene, renderer, camera) { // 背景纹理加载函数开始
            const textureLoader = new THREE.TextureLoader(); // 创建纹理加载器

            // 尝试多个可能的路径
            const possiblePaths = [
                './christmas_tree.jpg', // 相对路径
                'christmas_tree.jpg',   // 当前目录路径
                './christmas_tree.jpg?t=' + Date.now(), // 时间戳破缓存
                './christmas_tree.jpg?v=' + Math.random().toString(36).substr(2, 9) // 随机字符串破缓存
            ];

            // 尝试加载每个路径
            let pathIndex = 0;
            
            function tryLoadNextPath() {
                if (pathIndex >= possiblePaths.length) {
                    console.error('所有路径都加载失败，使用黑色背景');
                    scene.background = new THREE.Color(0x000000);
                    return;
                }

                const currentPath = possiblePaths[pathIndex];
                console.log(`尝试路径 ${pathIndex + 1}: ${currentPath}`);
                
                textureLoader.load( // 开始加载纹理
                    currentPath, // 当前尝试的路径
                    texture => { // 加载成功回调
                        console.log(`路径 ${currentPath} 加载成功`);
                        texture.colorSpace = THREE.SRGBColorSpace; // 设置颜色空间
                        texture.minFilter = THREE.LinearFilter; // 设置缩小过滤器
                        texture.magFilter = THREE.LinearFilter; // 设置放大过滤器
                        scene.background = texture; // 设置场景背景

                        // ⭐ 强制重渲染（关键）
                        renderer.render(scene, camera); // 立即渲染一帧，确保背景显示
                    },
                    progress => { // 加载进度回调
                        console.log(`加载进度: ${Math.round((progress.loaded / progress.total) * 100)}%`);
                    },
                    err => { // 加载失败回调
                        console.error(`路径 ${currentPath} 加载失败:`, err);
                        pathIndex++;
                        tryLoadNextPath(); // 尝试下一个路径
                    }
                ); // 纹理加载结束
            }

            // 开始尝试第一个路径
            tryLoadNextPath();
        } // loadBackgroundTexture函数结束
        
        /**
         * 创建雪花粒子系统（渐进式）
         */
        function createSnowParticles(scene) { // 雪花粒子系统创建函数开始
            const { COUNT, MAX_HEIGHT, RANGE, BASE_SPEED, SPEED_VARIANCE } = CONFIG.SNOW; // 解构获取雪花配置
            
            // 创建几何体
            const snowGeometry = new THREE.BufferGeometry(); // 创建缓冲几何体
            
            // 创建属性数组
            const snowPositions = new Float32Array(COUNT * 3); // 位置数组（X,Y,Z坐标）
            const snowColors = new Float32Array(COUNT * 3); // 颜色数组（R,G,B值）
            const snowSizes = new Float32Array(COUNT); // 大小数组
            const snowSpeeds = new Float32Array(COUNT); // 速度数组
            const snowActive = new Float32Array(COUNT); // 激活状态数组（控制每个粒子是否活跃）
            
            // 白色雪花
            const whiteColor = new THREE.Color(0xffffff); // 创建白色颜色对象
            const whiteColorArray = [whiteColor.r, whiteColor.g, whiteColor.b]; // 获取颜色RGB值数组
            
            // 初始化雪花粒子（初始都不活跃）
            for (let i = 0; i < COUNT; i++) { // 遍历所有雪花粒子
                const i3 = i * 3; // 计算位置数组索引（每个粒子3个坐标值）
                
                // 随机位置（初始在很高的地方）
                snowPositions[i3] = (Math.random() - 0.5) * RANGE; // X坐标随机
                snowPositions[i3 + 1] = MAX_HEIGHT + Math.random() * 10; // Y坐标（更高处）
                snowPositions[i3 + 2] = (Math.random() - 0.5) * RANGE; // Z坐标随机
                
                // 白色
                snowColors.set(whiteColorArray, i3); // 设置粒子颜色为白色
                
                // 随机大小
                snowSizes[i] = 0.05 + Math.random() * 0.2; // 随机大小范围0.05-0.25
                
                // 随机速度
                snowSpeeds[i] = BASE_SPEED + Math.random() * SPEED_VARIANCE; // 基础速度加随机变化
                
                // 初始不活跃
                snowActive[i] = 0; // 设置为不活跃状态
            } // 雪花粒子初始化循环结束
            
            // 设置几何体属性
            snowGeometry.setAttribute('position', new THREE.BufferAttribute(snowPositions, 3));
            snowGeometry.setAttribute('color', new THREE.BufferAttribute(snowColors, 3));
            snowGeometry.setAttribute('size', new THREE.BufferAttribute(snowSizes, 1));
            snowGeometry.setAttribute('active', new THREE.BufferAttribute(snowActive, 1));
            
            // 创建材质
            const snowMaterial = new THREE.PointsMaterial({
                size: 0.1,
                vertexColors: true,
                transparent: true,
                opacity: 0.8,
                blending: THREE.AdditiveBlending,
                sizeAttenuation: true
            });
            
            // 创建粒子系统
            const snowParticles = new THREE.Points(snowGeometry, snowMaterial);
            scene.add(snowParticles);
            
            // 返回动画更新函数
            return {
                snowParticles,
                updateSnowAnimation: (time, fadeInComplete, snowStartTime) => updateSnowAnimation(snowParticles, COUNT, snowSpeeds, time, fadeInComplete, snowStartTime)
            };
        }
        
        /**
         * 更新雪花动画（渐进式激活）
         */
        function updateSnowAnimation(snowParticles, particleCount, snowSpeeds, time, fadeInComplete, snowStartTime) {
            const { MAX_HEIGHT, MIN_HEIGHT, RANGE, WIND_DIRECTION, BASE_SPEED, SPEED_VARIANCE } = CONFIG.SNOW;
            const positionsArray = snowParticles.geometry.attributes.position.array;
            const activeArray = snowParticles.geometry.attributes.active.array;
            
            const elapsedSinceSnowStart = snowStartTime ? (Date.now() - snowStartTime) / 1000 : 0;
            
            for (let i = 0; i < particleCount; i++) {
                const i3 = i * 3;
                const speed = snowSpeeds[i];
                
                // 渐进式激活雪花（0.8秒内逐渐激活所有雪花）
                if (activeArray[i] === 0 && elapsedSinceSnowStart > 0) {
                    const activationDelay = (i / particleCount) * 0.8; // 每个粒子延迟激活
                    if (elapsedSinceSnowStart >= activationDelay) {
                        activeArray[i] = 1;
                        // 将活跃粒子从高处开始下落
                        positionsArray[i3 + 1] = MAX_HEIGHT + Math.random() * 5;
                    }
                }
                
                // 只有活跃的雪花才参与动画
                if (activeArray[i] === 1) {
                    // 雪花下落 - 使用更自然的速度
                    positionsArray[i3 + 1] -= speed * 0.6; // 降低下落速度
                    
                    // 风的影响（更轻微）
                    positionsArray[i3] += WIND_DIRECTION.x * 0.3;
                    positionsArray[i3 + 2] += WIND_DIRECTION.z * 0.3;
                    
                    // 左右摇摆（更缓慢）
                    positionsArray[i3] += Math.sin(time * 0.3 + i * 0.1) * 0.005;
                    positionsArray[i3 + 2] += Math.cos(time * 0.4 + i * 0.15) * 0.004;
                    
                    // 雪花重新生成
                    if (positionsArray[i3 + 1] < MIN_HEIGHT) {
                        positionsArray[i3 + 1] = MAX_HEIGHT + Math.random() * 10;
                        positionsArray[i3] = (Math.random() - 0.5) * RANGE;
                        positionsArray[i3 + 2] = (Math.random() - 0.5) * RANGE;
                    }
                }
            }
            
            snowParticles.geometry.attributes.position.needsUpdate = true;
            snowParticles.geometry.attributes.active.needsUpdate = true;
            
            // 雪花透明度变化 - 只在淡入完成后才应用动态变化
            if (fadeInComplete && snowParticles.material) {
                snowParticles.material.opacity = 0.6 + Math.sin(time * 0.3) * 0.2;
            }
        }
        
        /**
         * 创建树粒子系统（批处理版本）
         */
        function createTreeParticlesBatched() {
            const batches = [];
            const { PARTICLE_COUNT, BATCH_SIZE } = CONFIG.TREE;
            
            // 将粒子分组为批次，每个批次是一组"星形粒子"
            const BATCH_PARTICLE_COUNT = CONFIG.TREE.BATCH_SIZE; // 每个星形粒子包含的原始粒子数
            const batchCount = Math.floor(PARTICLE_COUNT / BATCH_PARTICLE_COUNT);
            
            // 存储所有粒子的目标位置、颜色和大小
            const particleData = [];
            
            // 先生成所有粒子的目标位置、颜色和大小
            for (let i = 0; i < PARTICLE_COUNT; i++) {
                const i3 = i * 3;
                
                // 随机选择粒子类型（树干或树叶）
                const isTrunk = Math.random() < CONFIG.TREE.TRUNK_RATIO;
                
                const data = {
                    index: i,
                    isTrunk: isTrunk,
                    targetPosition: new THREE.Vector3(),
                    color: new THREE.Color(),
                    size: 0
                };
                
                // 生成粒子在树中的位置和属性
                if (isTrunk) {
                    generateTrunkParticleData(data);
                } else {
                    generateLeafParticleData(data);
                }
                
                particleData.push(data);
            }
            
            // 创建批次
            for (let batchIndex = 0; batchIndex < batchCount; batchIndex++) {
                // 为当前批次创建单个几何体，包含所有粒子
                const clusterPositions = new Float32Array(BATCH_PARTICLE_COUNT * 3);
                const targetPositions = new Float32Array(BATCH_PARTICLE_COUNT * 3);
                const colors = new Float32Array(BATCH_PARTICLE_COUNT * 3);
                const sizes = new Float32Array(BATCH_PARTICLE_COUNT);
                const baseSizes = new Float32Array(BATCH_PARTICLE_COUNT);
                
                for (let i = 0; i < BATCH_PARTICLE_COUNT; i++) {
                    const particleIndex = batchIndex * BATCH_PARTICLE_COUNT + i;
                    if (particleIndex >= PARTICLE_COUNT) break;
                    
                    const data = particleData[particleIndex];
                    const i3 = i * 3;
                    
                    // 将粒子随机分布在空间中，形成星形效果
                    const randomRadius = CONFIG.ANIMATION.PARTICLE_ANIMATION.INITIAL_RADIUS;
                    clusterPositions[i3] = (Math.random() - 0.5) * randomRadius * 2;
                    clusterPositions[i3 + 1] = (Math.random() - 0.5) * randomRadius * 1.5 + randomRadius * 0.2;
                    clusterPositions[i3 + 2] = (Math.random() - 0.5) * randomRadius * 2;
                    
                    // 目标位置
                    targetPositions[i3] = data.targetPosition.x;
                    targetPositions[i3 + 1] = data.targetPosition.y;
                    targetPositions[i3 + 2] = data.targetPosition.z;
                    
                    // 颜色
                    colors[i3] = data.color.r;
                    colors[i3 + 1] = data.color.g;
                    colors[i3 + 2] = data.color.b;
                    
                    // 大小 - 初始设置为星形大小
                    const starSizeMultiplier = 3.0;
                    sizes[i] = data.size * starSizeMultiplier;
                    baseSizes[i] = data.size;
                }
                
                // 创建几何体
                const geometry = new THREE.BufferGeometry();
                geometry.setAttribute('position', new THREE.BufferAttribute(clusterPositions, 3));
                geometry.setAttribute('targetPosition', new THREE.BufferAttribute(targetPositions, 3));
                geometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));
                geometry.setAttribute('size', new THREE.BufferAttribute(sizes, 1));
                geometry.setAttribute('baseSize', new THREE.BufferAttribute(baseSizes, 1));
                // 星星阶段的大小倍率
                const starSizes = new Float32Array(BATCH_PARTICLE_COUNT).fill(3.0);
                geometry.setAttribute('starSize', new THREE.BufferAttribute(starSizes, 1));
                
                // 创建材质
                const material = new THREE.PointsMaterial({
                    size: 0.25,
                    vertexColors: true,
                    transparent: true,
                    opacity: 1,
                    blending: THREE.AdditiveBlending
                });
                
                const points = new THREE.Points(geometry, material);
                points.visible = false; // 一开始不可见
                
                // 保存批次数据
                points.userData.originalPositions = clusterPositions;
                points.userData.targetPositions = targetPositions;
                points.userData.batchIndex = batchIndex;
                points.userData.starPhase = 0; // 0: 星形阶段, 1: 过渡阶段, 2: 最终位置
                
                // 将星形粒子组添加到批次数组
                batches.push(points);
            }
            
            return batches;
        }
        
        /**
         * 生成树干粒子数据
         */
        function generateTrunkParticleData(data) {
            const { TRUNK_HEIGHT, TRUNK_BASE_RADIUS, TRUNK_TOP_RADIUS } = CONFIG.TREE;
            
            // 树干高度
            const height = Math.random() * TRUNK_HEIGHT;
            
            // 树干半径随高度变化
            const radiusRatio = height / TRUNK_HEIGHT;
            const radius = TRUNK_BASE_RADIUS - (TRUNK_BASE_RADIUS - TRUNK_TOP_RADIUS) * radiusRatio;
            const angle = Math.random() * Math.PI * 2;
            
            // 设置位置
            data.targetPosition.set(
                Math.cos(angle) * radius,
                height,
                Math.sin(angle) * radius
            );
            
            // 设置颜色
            const trunkColor = CONFIG.COLORS.TREE[9];
            data.color.set(trunkColor.r, trunkColor.g, trunkColor.b);
            
            // 设置大小
            data.size = 2 + Math.random() * 3;
        }
        
        /**
         * 生成树叶粒子数据
         */
        function generateLeafParticleData(data) {
            const { 
                LEAF_HEIGHT_RANGE, LEAF_BASE_HEIGHT, LEAF_BASE_RADIUS, 
                RIBBON_PROBABILITY, RIBBON_COUNT, RIBBON_SPIRAL_TURNS 
            } = CONFIG.TREE;
            
            // 随机高度
            const randomHeight = Math.random() * LEAF_HEIGHT_RANGE + LEAF_BASE_HEIGHT;
            
            // 圆锥形状计算
            const heightRatio = (randomHeight - LEAF_BASE_HEIGHT) / LEAF_HEIGHT_RANGE;
            const maxRadius = LEAF_BASE_RADIUS * (1 - heightRatio);
            
            // 是否生成彩带粒子
            const isRibbon = Math.random() < RIBBON_PROBABILITY;
            
            let radius, angle;
            let ribbonColorIndex = -1;
            
            if (isRibbon) {
                // 彩带粒子：螺旋分布
                const ribbonIndex = Math.floor(Math.random() * RIBBON_COUNT);
                const ribbonColors = CONFIG.COLORS.RIBBON;
                ribbonColorIndex = ribbonColors[Math.floor(Math.random() * ribbonColors.length)];
                
                const spiralOffset = (ribbonIndex / RIBBON_COUNT) * 2 * Math.PI;
                const spiralAngle = spiralOffset + (randomHeight - LEAF_BASE_HEIGHT) * 
                    (2 * Math.PI * RIBBON_SPIRAL_TURNS / LEAF_HEIGHT_RANGE);
                
                // 彩带粒子只在树的最外层生成
                radius = maxRadius * (0.92 + Math.random() * 0.08);
                angle = spiralAngle + (Math.random() - 0.5) * 0.1;
            } else {
                // 普通树叶粒子：随机分布
                radius = Math.sqrt(Math.random()) * maxRadius;
                angle = Math.random() * Math.PI * 2;
                
                // 按高度调整密度
                const densityFactor = 1.2 - Math.abs(heightRatio - 0.5) * 0.4;
                
                // 这里不再生成远离树的不可见粒子，而是直接跳过创建，这样更高效
                if (Math.random() <= 0.2 * densityFactor) {
                    // 跳过创建该粒子，减少不必要的渲染
                    data.targetPosition.set(0, 0, 0);
                    data.color.setRGB(0, 0, 0); // 设置为黑色
                    data.size = 0; // 设置为不可见大小
                    return;
                }
            }
            
            // 设置位置
            data.targetPosition.set(
                Math.cos(angle) * radius,
                randomHeight,
                Math.sin(angle) * radius
            );
            
            // 设置颜色
            const colorIndex = determineLeafColorIndex(isRibbon, ribbonColorIndex, heightRatio);
            const color = CONFIG.COLORS.TREE[colorIndex];
            
            // 应用阴影效果（仅普通树叶）
            if (!isRibbon) {
                const shadowFactor = 0.8 + heightRatio * 0.2;
                data.color.setRGB(color.r * shadowFactor, color.g * shadowFactor, color.b * shadowFactor);
            } else {
                data.color.setRGB(color.r, color.g, color.b);
            }
            
            // 设置大小
            const sizeFactor = heightRatio > 0.8 ? 0.8 : 1.0;
            const ribbonSizeFactor = isRibbon ? 1.8 : 1.0;
            data.size = (1.5 + Math.random() * 3) * sizeFactor * ribbonSizeFactor * (0.9 + Math.random() * 0.2);
        }
        
        /**
         * 创建圣诞树
         */
        function createChristmasTree(scene) { // 圣诞树创建函数开始
            
            // 创建粒子系统（批处理版本）
            const particleBatches = createTreeParticlesBatched(); // 调用批次粒子创建函数
            
            // 创建树的根容器
            const treeGroup = new THREE.Group(); // 创建3D组对象作为树的根容器
            
            // 添加所有批次到树组（每个批次是一个Points对象）
            particleBatches.forEach(batch => { // 遍历所有粒子批次
                treeGroup.add(batch); // 将批次添加到树组中
            }); // 遍历结束
            scene.add(treeGroup); // 将树组添加到场景中
            
            // 添加彩色装饰灯
            const coloredLightObjects = addColoredLights(treeGroup); // 调用彩色灯光添加函数
            
            // 设置树的位置和缩放
            treeGroup.position.copy(CONFIG.TREE.POSITION_OFFSET); // 设置树的位置偏移
            treeGroup.scale.copy(CONFIG.TREE.SCALE); // 设置树的缩放比例
            treeGroup.updateMatrixWorld(true); // 更新世界矩阵
            
            // 初始化动画状态
            const animationState = { // 创建动画状态对象
                startTime: Date.now(), // 记录开始时间
                completed: false, // 动画是否完成标记
                isRotating: false, // 旋转状态标记
                snowStarted: false, // 雪花是否开始标记
                snowStartTime: 0, // 雪花开始时间戳
                treeCompleted: false // 树是否完全成型标记
            }; // animationState对象定义结束
            
            return { // 返回创建的圣诞树相关对象
                treeGroup, // 树组
                particleBatches, // 粒子批次
                coloredLightObjects, // 彩色灯光
                animationState // 动画状态
            }; // return语句结束
        } // createChristmasTree函数结束
        

        

        
        /**
         * 确定树叶颜色索引
         */
        function determineLeafColorIndex(isRibbon, ribbonColorIndex, heightRatio) {
            if (isRibbon && ribbonColorIndex !== -1) {
                return ribbonColorIndex;
            }
            
            // 普通树叶粒子颜色
            const rand = Math.random();
            if (rand < 0.97) {
                return Math.floor(Math.random() * 4); // 选择前4种深绿/冷绿颜色
            } else {
                return 7 + Math.floor(Math.random() * 2); // 选择高光颜色
            }
        }
        
        /**
         * 添加彩色装饰灯
         */
        function addColoredLights(treeGroup) {
            const coloredLightObjects = [];
            
            CONFIG.LIGHTS.forEach((lightConfig, index) => {
                const coloredLight = new THREE.PointLight(
                    lightConfig.color, 
                    lightConfig.intensity, 
                    lightConfig.distance
                );
                
                // 随机位置
                const angle = (index / CONFIG.LIGHTS.length) * Math.PI * 2;
                const radius = 3 + Math.random() * 2;
                coloredLight.position.set(
                    Math.cos(angle) * radius,
                    5 + Math.random() * 5,
                    Math.sin(angle) * radius
                );
                
                treeGroup.add(coloredLight);
                coloredLightObjects.push(coloredLight);
            });
            
            return coloredLightObjects;
        }
        
        /**
         * 初始化相机控制参数
         */
        function initCameraControls(camera) {
            const cameraDistance = camera.position.distanceTo(CONFIG.CAMERA.TARGET);
            
            return {
                rotationX: THREE.MathUtils.degToRad(0),
                rotationY: THREE.MathUtils.degToRad(0),
                distance: cameraDistance
            };
        }
        
        /**
         * 更新批次可见性
         */
        function updateBatchVisibility(batches, startTime) {
            const elapsed = Date.now() - startTime;
            const interval = CONFIG.TREE.BATCH_INTERVAL;
            const visibleCount = Math.floor(elapsed / interval);
            
            for (let i = 0; i < batches.length; i++) {
                if (i <= visibleCount && !batches[i].userData.startTime) {
                    batches[i].visible = true;
                    batches[i].userData.startTime = Date.now();
                }
            }
        }
        
        /**
         * 检查树是否完全成型
         */
        function checkTreeCompletion(batches, animationState) {
            // 检查所有批次是否都到达最终位置（starPhase = 2）
            const allBatchesCompleted = batches.every(batch => 
                batch.visible && batch.userData.starPhase >= 2
            );
            
            if (allBatchesCompleted && !animationState.treeCompleted) {
                animationState.treeCompleted = true;
                return true; // 树刚完成
            }
            
            return false; // 树未完成或已经完成
        }

        /**
         * 更新批次移动动画
         */
        function updateBatchMovement(batches, startTime) {
            const now = Date.now();
            const appearInterval = CONFIG.TREE.BATCH_INTERVAL;
            const starPhaseDuration = CONFIG.ANIMATION.PARTICLE_ANIMATION.STAR_PHASE_DURATION;
            const transitionDuration = CONFIG.ANIMATION.PARTICLE_ANIMATION.TRANSITION_DURATION;
            
            // 计算关键时间点
            const allParticlesVisibleTime = startTime + CONFIG.TREE.BATCH_INTERVAL * Math.ceil(CONFIG.TREE.PARTICLE_COUNT / CONFIG.TREE.BATCH_SIZE) + CONFIG.ANIMATION.PARTICLE_ANIMATION.ALL_PARTICLES_VISIBLE_DELAY;
            const starPhaseEndTime = allParticlesVisibleTime + starPhaseDuration;
            const transitionEndTime = starPhaseEndTime + transitionDuration;
            
            batches.forEach((points, batchIndex) => {
                const time = Date.now() * 0.001;
                const batchAppearTime = startTime + batchIndex * appearInterval;
                const elapsedSinceAppear = now - batchAppearTime;
                
                if (elapsedSinceAppear <= 0) {
                    // 批次还未出现，保持透明
                    points.material.opacity = 0;
                    return;
                }
                
                // 根据当前时间确定动画阶段
                let sparkle, convergeBrightness;
                
                if (now < allParticlesVisibleTime) {
                    // 阶段0：粒子出现阶段，逐渐显示
                    const appearProgress = THREE.MathUtils.clamp(elapsedSinceAppear / 500, 0, 1);
                    sparkle = 0.7 + Math.sin(time * 6 + batchIndex) * 0.3;
                    convergeBrightness = appearProgress;
                } else if (now < starPhaseEndTime) {
                    // 阶段1：星形闪耀阶段
                    sparkle = 0.7 + Math.sin(time * 6 + batchIndex) * 0.3;
                    convergeBrightness = 1.0;
                } else if (now < transitionEndTime) {
                    // 阶段2：过渡汇聚阶段
                    const transitionProgress = THREE.MathUtils.clamp((now - starPhaseEndTime) / transitionDuration, 0, 1);
                    sparkle = 0.7 + Math.sin(time * 6 + batchIndex) * 0.3;
                    convergeBrightness = 1.0;
                } else {
                    // 阶段3：最终形成树
                    sparkle = 0.9 + Math.sin(time * 3 + batchIndex) * 0.1;
                    convergeBrightness = 1.0;
                }
                
                // 最终透明度
                points.material.opacity = sparkle * convergeBrightness;
                
                const geometry = points.geometry;
                const positions = geometry.attributes.position.array;
                const targetPositions = geometry.attributes.targetPosition.array;
                
                // 阶段0和1：粒子出现和星形闪耀阶段
                if (now < starPhaseEndTime) {
                    // 静态显示，无漂移效果
                    for (let i = 0; i < positions.length; i += 3) {
                        // 直接使用原始位置，保持静态
                        positions[i] = points.userData.originalPositions[i];
                        positions[i + 1] = points.userData.originalPositions[i + 1];
                        positions[i + 2] = points.userData.originalPositions[i + 2];
                    }
                    
                    geometry.attributes.position.needsUpdate = true;
                    
                    // ⭐ 星形阶段（闪耀）- 控制size
                    const sizes = geometry.attributes.size.array;
                    const baseSizes = geometry.attributes.baseSize.array;
                    const starSizes = geometry.attributes.starSize.array;
                    
                    const sparkle = 1 + Math.sin(time * 6 + batchIndex) * 0.3;
                    
                    for (let i = 0; i < sizes.length; i++) {
                        sizes[i] = baseSizes[i] * starSizes[i] * sparkle;
                    }
                    
                    geometry.attributes.size.needsUpdate = true;
                } 
                // 阶段2：过渡汇聚阶段
                else if (now < transitionEndTime) {
                    const elapsedSinceTransition = now - starPhaseEndTime;
                    const t = elapsedSinceTransition / transitionDuration;
                    // 使用更慢的缓动函数，使过渡更平缓
                    const eased = t < 0.5 ? 2 * t * t : 1 - Math.pow(-2 * t + 2, 2) / 2;
                    
                    // 通过BufferAttribute数组进行位置插值
                    for (let i = 0; i < positions.length; i += 3) {
                        const startX = points.userData.originalPositions[i];
                        const startY = points.userData.originalPositions[i + 1];
                        const startZ = points.userData.originalPositions[i + 2];
                        
                        const targetX = targetPositions[i];
                        const targetY = targetPositions[i + 1];
                        const targetZ = targetPositions[i + 2];
                        
                        // 直线轨迹汇聚
                        positions[i] = startX + (targetX - startX) * eased;
                        positions[i + 1] = startY + (targetY - startY) * eased;
                        positions[i + 2] = startZ + (targetZ - startZ) * eased;
                    }
                    
                    geometry.attributes.position.needsUpdate = true;
                    
                    // ⭐ 过渡阶段（大 → 小，连续缩放）- 控制size
                    const sizes = geometry.attributes.size.array;
                    const baseSizes = geometry.attributes.baseSize.array;
                    const starSizes = geometry.attributes.starSize.array;
                    
                    const scale = THREE.MathUtils.lerp(
                        starSizes[0], // 星星阶段倍率
                        1.0,          // 最终倍率
                        eased
                    );
                    
                    for (let i = 0; i < sizes.length; i++) {
                        sizes[i] = baseSizes[i] * scale;
                    }
                    
                    geometry.attributes.size.needsUpdate = true;
                    
                    points.userData.starPhase = eased; // 记录过渡进度
                } 
                // 阶段3：完全形成树形态
                else {
                    // 通过BufferAttribute数组确保所有粒子位于最终位置
                    for (let i = 0; i < positions.length; i += 3) {
                        positions[i] = targetPositions[i];
                        positions[i + 1] = targetPositions[i + 1];
                        positions[i + 2] = targetPositions[i + 2];
                    }
                    
                    geometry.attributes.position.needsUpdate = true;
                    
                    // ⭐ 最终阶段（稳定小粒子）- 控制size
                    const sizes = geometry.attributes.size.array;
                    const baseSizes = geometry.attributes.baseSize.array;
                    
                    for (let i = 0; i < sizes.length; i++) {
                        sizes[i] = baseSizes[i];
                    }
                    
                    geometry.attributes.size.needsUpdate = true;
                    
                    points.userData.starPhase = 2;
                }
            });
        }
        
        /**
         * 动画循环
         */
        function animate(params) { // 动画主循环函数
            const { // 解构获取动画参数对象中的所有必要组件
                scene, // 3D场景
                camera, // 相机
                renderer, // 渲染器
                snowSystem, // 雪花系统
                treeGroup, // 树组
                particleBatches, // 粒子批次
                coloredLightObjects, // 彩色灯光
                cameraControls, // 相机控制
                animationState // 动画状态
            } = params; // 解构赋值结束
            
            // 获取当前时间
            const time = Date.now() * 0.001; // 获取当前时间（转换为秒）
            
            // 更新批次可见性
            updateBatchVisibility(particleBatches, animationState.startTime); // 更新粒子批次显示状态
            updateBatchMovement(particleBatches, animationState.startTime); // 更新粒子移动动画
            
            // 应用树的倾斜（始终应用）
            treeGroup.rotation.x = CONFIG.TREE.TILT_X;
            
            // 圣诞树旋转逻辑
            const now = Date.now();
            // 计算关键时间点
            const allParticlesVisibleTime = animationState.startTime + CONFIG.TREE.BATCH_INTERVAL * Math.ceil(CONFIG.TREE.PARTICLE_COUNT / CONFIG.TREE.BATCH_SIZE) + CONFIG.ANIMATION.PARTICLE_ANIMATION.ALL_PARTICLES_VISIBLE_DELAY;
            const starPhaseEndTime = allParticlesVisibleTime + CONFIG.ANIMATION.PARTICLE_ANIMATION.STAR_PHASE_DURATION;
            const transitionDuration = CONFIG.ANIMATION.PARTICLE_ANIMATION.TRANSITION_DURATION;
            const transitionEndTime = starPhaseEndTime + transitionDuration;
            
            // 使用监听器检测树是否完全成型
            const treeJustCompleted = checkTreeCompletion(particleBatches, animationState);
            
            // 树成型检查和雪花启动（使用监听器）
            if (!animationState.snowStarted && treeJustCompleted) {
                snowSystem.snowParticles.visible = true;
                snowSystem.snowParticles.material.opacity = 0;
                animationState.snowStarted = true;
                animationState.snowStartTime = now;
            }
            
            // 只有在过渡汇聚阶段才开始加速旋转
            if (now >= starPhaseEndTime && now < transitionEndTime) {
                treeGroup.rotation.y += CONFIG.TREE.ROTATION_SPEED * 2; // 移动阶段加速旋转
                if (!animationState.isRotating) {
                    animationState.isRotating = true;
                }
            } else if (now >= transitionEndTime) {
                treeGroup.rotation.y += CONFIG.TREE.ROTATION_SPEED; // 完成后正常旋转
            }
            
            // 更新相机位置
            updateCameraPosition(camera, cameraControls);
            
            // 只有在雪花开始后才更新雪花动画
            if (animationState.snowStarted) {
                // 添加淡入效果
                let fadeInComplete = false;
                if (animationState.snowStartTime > 0) {
                    const snowFadeInDuration = 500; // 0.5秒淡入时间
                    const elapsedSinceSnowStart = now - animationState.snowStartTime;
                    const fadeInProgress = THREE.MathUtils.clamp(elapsedSinceSnowStart / snowFadeInDuration, 0, 1);
                    snowSystem.snowParticles.material.opacity = fadeInProgress * 0.8;
                    fadeInComplete = fadeInProgress >= 1.0;
                }
                
                snowSystem.updateSnowAnimation(time, fadeInComplete, animationState.snowStartTime);
            }
            
            // 禁用此函数，避免破坏size的稳定性
            // updateParticlesAnimation(particleBatches, time, animationState);
            
            // 更新彩色装饰灯
            updateColoredLights(coloredLightObjects, time);
            
            // 渲染场景
            renderer.render(scene, camera); // 渲染当前帧
            
            // 请求下一帧动画
            requestAnimationFrame(() => animate(params)); // 递归调用下一帧动画
        } // animate函数结束
        
        /**
         * 更新相机位置
         */
        function updateCameraPosition(camera, cameraControls) {
            const spherical = new THREE.Spherical();
            spherical.radius = cameraControls.distance;
            spherical.theta = cameraControls.rotationY;
            spherical.phi = cameraControls.rotationX + Math.PI / 2;
            
            camera.position.setFromSpherical(spherical);
            camera.position.add(CONFIG.CAMERA.TARGET);
            camera.lookAt(CONFIG.CAMERA.TARGET);
        }
        

        
        /**
         * 更新粒子动画
         */
        function updateParticlesAnimation(particleBatches, time, animationState) {
            // 检查所有粒子是否已完成星形到树形态的过渡
            const allParticlesTransitioned = particleBatches.every(points => 
                points.userData.starPhase >= 2
            );
            
            if (!allParticlesTransitioned) return;
            
            // 在所有粒子完成过渡后，添加微妙的动态效果
            particleBatches.forEach(points => {
                const geometry = points.geometry;
                const colors = geometry.attributes.color.array;
                const sizes = geometry.attributes.size.array;
                
                // ❌ 不再使用 material.size
            });
        }
        
        /**
         * 更新彩色装饰灯
         */
        function updateColoredLights(coloredLightObjects, time) {
            coloredLightObjects.forEach((light, index) => {
                const lightConfig = CONFIG.LIGHTS[index];
                const baseIntensity = lightConfig.intensity;
                const flickerSpeed = lightConfig.flickerSpeed;
                
                // 计算闪烁强度
                const flicker = 0.5 + Math.sin(time * flickerSpeed * Math.PI * 2) * 0.5;
                light.intensity = baseIntensity * flicker;
            });
        }
        
        /**
         * 窗口大小调整事件处理
         */
        function onWindowResize(camera, renderer) { // 窗口大小调整处理函数
            camera.aspect = window.innerWidth / window.innerHeight; // 更新相机宽高比
            camera.updateProjectionMatrix(); // 更新相机投影矩阵
            renderer.setSize(window.innerWidth, window.innerHeight); // 更新渲染器尺寸
        } // onWindowResize函数结束
    </script> <!-- JavaScript代码结束 -->
</body> <!-- 文档主体结束 -->
</html> <!-- HTML文档结束 -->
