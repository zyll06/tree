<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>åœ£è¯æ ‘</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background-color: #000;
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
        }
        canvas {
            display: block;
        }
    </style>
</head>
<body>
    <script src="three.min.js"></script>
    <script>
        // å¸¸é‡å®šä¹‰ï¼šå®šä¹‰æ‰€æœ‰ç³»ç»Ÿå‚æ•°é…ç½®
        const CONFIG = { // åˆ›å»ºå…¨å±€é…ç½®å¯¹è±¡
            // é›ªèŠ±ç³»ç»Ÿé…ç½®
            SNOW: { // é›ªèŠ±ç›¸å…³å‚æ•°
                COUNT: 3000, // é›ªèŠ±ç²’å­æ€»æ•°ï¼Œå‡å°‘æ•°é‡æé«˜æ€§èƒ½
                MAX_HEIGHT: 30, // é›ªèŠ±æœ€å¤§é«˜åº¦ï¼ˆYè½´åæ ‡ä¸Šé™ï¼‰
                MIN_HEIGHT: -5, // é›ªèŠ±æœ€å°é«˜åº¦ï¼ˆYè½´åæ ‡ä¸‹é™ï¼‰
                RANGE: 40, // é›ªèŠ±åˆ†å¸ƒèŒƒå›´ï¼ˆXå’ŒZè½´çš„éšæœºèŒƒå›´ï¼‰
                WIND_DIRECTION: new THREE.Vector3(-0.015, 0, -0.008), // é£çš„æ–¹å‘å‘é‡ï¼ˆXå’ŒZè½´åç§»ï¼‰
                BASE_SPEED: 0.055, // é›ªèŠ±åŸºç¡€ä¸‹è½é€Ÿåº¦ï¼Œå·²æé«˜
                SPEED_VARIANCE: 0.12 // é€Ÿåº¦å˜åŒ–èŒƒå›´ï¼Œå¢åŠ ä½¿ä¸‹è½æ›´è‡ªç„¶
            }, // SNOWé…ç½®ç»“æŸ
            // æ ‘ç³»ç»Ÿé…ç½®
            TREE: { // åœ£è¯æ ‘ç›¸å…³å‚æ•°
                PARTICLE_COUNT: 10000, // æ ‘çš„æ€»ç²’å­æ•°é‡
                TRUNK_RATIO: 0.15, // æ ‘å¹²ç²’å­æ¯”ä¾‹ï¼ˆ15%ï¼‰
                TRUNK_HEIGHT: 2, // æ ‘å¹²é«˜åº¦
                TRUNK_BASE_RADIUS: 0.6, // æ ‘å¹²åº•éƒ¨åŠå¾„
                TRUNK_TOP_RADIUS: 0.2, // æ ‘å¹²é¡¶éƒ¨åŠå¾„
                LEAF_HEIGHT_RANGE: 10, // æ ‘å¶é«˜åº¦èŒƒå›´
                LEAF_BASE_HEIGHT: 1, // æ ‘å¶èµ·å§‹é«˜åº¦
                LEAF_BASE_RADIUS: 4.26, // æ ‘å¶åŸºç¡€åŠå¾„
                RIBBON_PROBABILITY: 0.04, // å½©å¸¦ç²’å­å‡ºç°æ¦‚ç‡ï¼ˆ3%ï¼‰
                RIBBON_COUNT: 3, // å½©å¸¦æ•°é‡
                RIBBON_SPIRAL_TURNS: 3, // å½©å¸¦èºæ—‹åœˆæ•°
                POSITION_OFFSET: new THREE.Vector3(0, -7, 0), // æ ‘çš„ä½ç½®åç§»å‘é‡
                SCALE: new THREE.Vector3(2, 2.2, 2), // æ ‘çš„ç¼©æ”¾æ¯”ä¾‹
                TILT_X: THREE.MathUtils.degToRad(-30), // Xè½´å€¾æ–œè§’åº¦ï¼ˆè½¬æ¢ä¸ºå¼§åº¦ï¼‰
                ROTATION_SPEED: -0.002, // æ ‘çš„æ—‹è½¬é€Ÿåº¦ï¼ˆè´Ÿå€¼è¡¨ç¤ºé€†æ—¶é’ˆï¼‰
                BATCH_SIZE: 600, // æ¯æ‰¹å¤„ç†çš„ç²’å­æ•°é‡
                BATCH_INTERVAL: 120 // æ‰¹æ¬¡é—´éš”æ—¶é—´ï¼ˆæ¯«ç§’ï¼‰ï¼Œæ§åˆ¶æ˜Ÿæ˜Ÿç‚¹äº®é€Ÿåº¦
            }, // TREEé…ç½®ç»“æŸ
            // ç›¸æœºé…ç½®
            CAMERA: { // ç›¸æœºç›¸å…³å‚æ•°
                FOV: 65, // è§†åœºè§’åº¦ï¼ˆåº¦æ•°ï¼‰
                NEAR: 0.1, // è¿‘è£å‰ªé¢è·ç¦»
                FAR: 1000, // è¿œè£å‰ªé¢è·ç¦»
                INITIAL_POSITION: new THREE.Vector3(12, 7, 12), // ç›¸æœºåˆå§‹ä½ç½®
                TARGET: new THREE.Vector3(0, 4, 0) // ç›¸æœºè§‚å¯Ÿç›®æ ‡ç‚¹
            }, // CAMERAé…ç½®ç»“æŸ
            // ç¯å…‰é…ç½®
            LIGHTS: [ // è£…é¥°ç¯å…‰é…ç½®æ•°ç»„
                { color: 0xff0000, intensity: 0.8, distance: 5, flickerSpeed: 1.0 },  // çº¢è‰²ç¯å…‰
                { color: 0x00ff00, intensity: 0.6, distance: 4, flickerSpeed: 1.2 },  // ç»¿è‰²ç¯å…‰
                { color: 0x0000ff, intensity: 0.7, distance: 4.5, flickerSpeed: 2.0 },  // è“è‰²ç¯å…‰
                { color: 0xffff00, intensity: 0.9, distance: 5.5, flickerSpeed: 1.5 }   // é»„è‰²ç¯å…‰
            ], // LIGHTSé…ç½®ç»“æŸ
            // é¢œè‰²é…ç½®
            COLORS: { // é¢œè‰²ç›¸å…³å‚æ•°
                TREE: [ // æ ‘çš„é¢œè‰²æ•°ç»„
                    new THREE.Color(0x008800),  // æ·±ç»¿è‰²ï¼ˆæ ‘ä¸»ä½“ï¼‰
                    new THREE.Color(0x006600),  // æ›´æ·±çš„ç»¿è‰²ï¼ˆæ ‘ä¸»ä½“ï¼‰
                    new THREE.Color(0x009933),  // å†·ç»¿è‰²ï¼ˆæ ‘ä¸»ä½“ï¼‰
                    new THREE.Color(0x005522),  // æœ€å†·çš„ç»¿è‰²ï¼ˆæ ‘ä¸»ä½“ï¼‰
                    new THREE.Color(0xff0000),  // çº¢è‰²ï¼ˆè£…é¥°ï¼‰
                    new THREE.Color(0xffcc00),  // é‡‘è‰²ï¼ˆè£…é¥°ï¼‰
                    new THREE.Color(0x0000cc),  // æ·±è“è‰²ï¼ˆè£…é¥°ï¼‰
                    new THREE.Color(0xffffcc),  // æ·¡é»„è‰²ï¼ˆé«˜å…‰ï¼‰
                    new THREE.Color(0xffffff),  // ç™½è‰²ï¼ˆé«˜å…‰ï¼‰
                    new THREE.Color(0x5D3A00)   // æ·±æ£•è‰²ï¼ˆæ ‘å¹²ï¼‰
                ], // TREEé¢œè‰²æ•°ç»„ç»“æŸ
                RIBBON: [4, 5, 6]  // å½©å¸¦ä½¿ç”¨çš„é¢œè‰²ç´¢å¼•ï¼ˆå¯¹åº”TREEæ•°ç»„ä¸­çš„é¢œè‰²ï¼‰
            }, // COLORSé…ç½®ç»“æŸ
            // åŠ¨ç”»é…ç½®
            ANIMATION: { // åŠ¨ç”»ç›¸å…³å‚æ•°
                PULSE_SPEED: 2.0, // è„‰å†²åŠ¨ç”»é€Ÿåº¦
                PULSE_AMOUNT: 0.1, // è„‰å†²åŠ¨ç”»å¹…åº¦
                DECORATION_FLICKER_SPEED: 5.0, // è£…é¥°ç¯é—ªçƒé€Ÿåº¦
                PARTICLE_ANIMATION: { // ç²’å­åŠ¨ç”»å‚æ•°
                    STAR_PHASE_DURATION: 4000,  // æ˜Ÿå½¢é—ªè€€é˜¶æ®µæŒç»­æ—¶é—´ï¼ˆæ¯«ç§’ï¼‰
                    TRANSITION_DURATION: 8000,   // ä»æ˜Ÿå½¢åˆ°æ ‘å½¢æ€è¿‡æ¸¡æ—¶é—´ï¼ˆæ¯«ç§’ï¼‰
                    START_DELAY: 200,  // å¼€å§‹å»¶è¿Ÿï¼ˆæ¯«ç§’ï¼‰
                    EASE_FACTOR: 1.2,  // ç¼“åŠ¨å› å­ï¼Œæ§åˆ¶è¿‡æ¸¡å¹³æ»‘åº¦
                    INITIAL_RADIUS: 40,  // ç²’å­åˆå§‹éšæœºåˆ†å¸ƒåŠå¾„
                    ALL_PARTICLES_VISIBLE_DELAY: 500   // ç­‰å¾…æ‰€æœ‰ç²’å­å‡ºç°åå†å¼€å§‹ç§»åŠ¨
                } // PARTICLE_ANIMATIONç»“æŸ
            } // ANIMATIONé…ç½®ç»“æŸ
        }; // CONFIGå¯¹è±¡ç»“æŸ

        // é¡µé¢åŠ è½½å®Œæˆååˆå§‹åŒ–Three.js
        window.addEventListener('DOMContentLoaded', initThreeJs); // DOMåŠ è½½å®Œæˆäº‹ä»¶ç›‘å¬å™¨
        
        /**
         * Three.jsä¸»åˆå§‹åŒ–å‡½æ•°
         * è´Ÿè´£åˆ›å»ºå’Œé…ç½®3Dåœºæ™¯ã€ç›¸æœºã€æ¸²æŸ“å™¨ç­‰æ ¸å¿ƒç»„ä»¶
         */
        function initThreeJs() { // Three.jsåˆå§‹åŒ–å‡½æ•°å¼€å§‹
            // åˆ›å»ºThree.jsåœºæ™¯å¯¹è±¡
            const scene = new THREE.Scene(); // åˆ›å»º3Dåœºæ™¯å®¹å™¨
            
            // åˆå§‹åŒ–ç›¸æœº
            const camera = createCamera(); // è°ƒç”¨ç›¸æœºåˆ›å»ºå‡½æ•°
            
            // åˆå§‹åŒ–æ¸²æŸ“å™¨
            const renderer = createRenderer(); // è°ƒç”¨æ¸²æŸ“å™¨åˆ›å»ºå‡½æ•°
            
            // åˆ›å»ºé›ªèŠ±ç²’å­ç³»ç»Ÿï¼ˆåˆå§‹éšè—ï¼‰
            const snowSystem = createSnowParticles(scene); // è°ƒç”¨é›ªèŠ±ç³»ç»Ÿåˆ›å»ºå‡½æ•°
            snowSystem.snowParticles.visible = false; // åˆå§‹éšè—é›ªç²’å­
            
            // åŠ è½½èƒŒæ™¯å›¾ç‰‡ - æ”¾åœ¨æœ€åç¡®ä¿å…¶ä»–ç»„ä»¶å·²å°±ç»ª
            loadBackgroundTexture(scene, renderer, camera); // è°ƒç”¨èƒŒæ™¯çº¹ç†åŠ è½½å‡½æ•°ï¼Œä¼ å…¥å¿…è¦å‚æ•°
            
            // åˆ›å»ºåœ£è¯æ ‘
            const { // è§£æ„èµ‹å€¼ï¼Œè·å–åˆ›å»ºåœ£è¯æ ‘è¿”å›çš„å¤šä¸ªå¯¹è±¡
                treeGroup, // æ ‘çš„ç»„å¯¹è±¡
                particleBatches, // ç²’å­æ‰¹æ¬¡æ•°ç»„
                coloredLightObjects, // å½©è‰²ç¯å…‰å¯¹è±¡æ•°ç»„
                animationState // åŠ¨ç”»çŠ¶æ€å¯¹è±¡
            } = createChristmasTree(scene); // è°ƒç”¨åœ£è¯æ ‘åˆ›å»ºå‡½æ•°
            
            // åˆå§‹åŒ–ç›¸æœºæ§åˆ¶å‚æ•°
            const cameraControls = initCameraControls(camera); // è°ƒç”¨ç›¸æœºæ§åˆ¶åˆå§‹åŒ–å‡½æ•°
            
            // å¼€å§‹åŠ¨ç”»å¾ªç¯
            animate({ // è°ƒç”¨åŠ¨ç”»å¾ªç¯å‡½æ•°ï¼Œä¼ å…¥æ‰€æœ‰å¿…è¦å‚æ•°
                scene, // 3Dåœºæ™¯
                camera, // ç›¸æœº
                renderer, // æ¸²æŸ“å™¨
                snowSystem, // é›ªèŠ±ç³»ç»Ÿ
                treeGroup, // æ ‘ç»„
                particleBatches, // ç²’å­æ‰¹æ¬¡
                coloredLightObjects, // å½©è‰²ç¯å…‰
                cameraControls, // ç›¸æœºæ§åˆ¶
                animationState // åŠ¨ç”»çŠ¶æ€
            }); // animateè°ƒç”¨ç»“æŸ
            
            // æ·»åŠ çª—å£å¤§å°è°ƒæ•´äº‹ä»¶ç›‘å¬
            window.addEventListener('resize', () => onWindowResize(camera, renderer)); // ç›‘å¬çª—å£å¤§å°å˜åŒ–
        } // initThreeJså‡½æ•°ç»“æŸ
        
        /**
         * åˆ›å»ºé€è§†ç›¸æœº
         */
        function createCamera() { // ç›¸æœºåˆ›å»ºå‡½æ•°å¼€å§‹
            const camera = new THREE.PerspectiveCamera( // åˆ›å»ºé€è§†ç›¸æœºå¯¹è±¡
                CONFIG.CAMERA.FOV, // è§†åœºè§’åº¦
                window.innerWidth / window.innerHeight, // å®½é«˜æ¯”
                CONFIG.CAMERA.NEAR, // è¿‘è£å‰ªé¢
                CONFIG.CAMERA.FAR // è¿œè£å‰ªé¢
            ); // PerspectiveCameraåˆ›å»ºç»“æŸ
            
            camera.position.copy(CONFIG.CAMERA.INITIAL_POSITION); // è®¾ç½®ç›¸æœºåˆå§‹ä½ç½®
            camera.lookAt(CONFIG.CAMERA.TARGET); // è®¾ç½®ç›¸æœºè§‚å¯Ÿç›®æ ‡
            
            return camera; // è¿”å›ç›¸æœºå¯¹è±¡
        } // createCameraå‡½æ•°ç»“æŸ
        
        /**
         * åˆ›å»ºWebGLæ¸²æŸ“å™¨
         */
        function createRenderer() { // æ¸²æŸ“å™¨åˆ›å»ºå‡½æ•°å¼€å§‹
            const renderer = new THREE.WebGLRenderer({ antialias: true }); // åˆ›å»ºWebGLæ¸²æŸ“å™¨ï¼Œå¯ç”¨æŠ—é”¯é½¿
            renderer.setSize(window.innerWidth, window.innerHeight); // è®¾ç½®æ¸²æŸ“å™¨å°ºå¯¸ä¸ºçª—å£å¤§å°
            renderer.shadowMap.enabled = false; // ç¦ç”¨é˜´å½±æ˜ å°„æé«˜æ€§èƒ½
            document.body.appendChild(renderer.domElement); // å°†æ¸²æŸ“å™¨DOMå…ƒç´ æ·»åŠ åˆ°é¡µé¢
            
            return renderer; // è¿”å›æ¸²æŸ“å™¨å¯¹è±¡
        } // createRendererå‡½æ•°ç»“æŸ
        
        /**
         * åŠ è½½èƒŒæ™¯çº¹ç†
         */
        function loadBackgroundTexture(scene, renderer, camera) { // èƒŒæ™¯çº¹ç†åŠ è½½å‡½æ•°å¼€å§‹
            
            // â­â­â­ å¼ºåˆ¶ç¡®ä¿å›¾ç‰‡åŠ è½½æˆåŠŸçš„ç­–ç•¥
            console.log('ğŸ” å¼€å§‹å¼ºåˆ¶åŠ è½½èƒŒæ™¯å›¾ç‰‡...');
            
            // ç«‹å³åˆ›å»ºåŸºç¡€èƒŒæ™¯ï¼Œé¿å…ç©ºç™½
            createSolidBackground(scene, renderer, camera);
            
            // ä½¿ç”¨å¤šé‡ç­–ç•¥åŒæ—¶åŠ è½½ï¼Œç¡®ä¿æˆåŠŸ
            loadWithMultipleStrategies(scene, renderer, camera);
        } // loadBackgroundTextureå‡½æ•°ç»“æŸ
        
        /**
         * åˆ›å»ºçº¯è‰²åŸºç¡€èƒŒæ™¯ï¼ˆé¿å…ç©ºç™½ï¼‰
         */
        function createSolidBackground(scene, renderer, camera) {
            const gradientCanvas = document.createElement('canvas');
            gradientCanvas.width = 512;
            gradientCanvas.height = 512;
            const ctx = gradientCanvas.getContext('2d');
            
            // åˆ›å»ºæ·±è“æ¸å˜èƒŒæ™¯
            const gradient = ctx.createLinearGradient(0, 0, 0, 512);
            gradient.addColorStop(0, '#000033');
            gradient.addColorStop(0.5, '#000066');
            gradient.addColorStop(1, '#000099');
            
            ctx.fillStyle = gradient;
            ctx.fillRect(0, 0, 512, 512);
            
            const baseTexture = new THREE.CanvasTexture(gradientCanvas);
            scene.background = baseTexture;
            renderer.render(scene, camera);
            
            console.log('âœ… åŸºç¡€èƒŒæ™¯å·²è®¾ç½®');
        }
        
        /**
         * ä½¿ç”¨å¤šé‡ç­–ç•¥å¼ºåˆ¶åŠ è½½å›¾ç‰‡
         */
        function loadWithMultipleStrategies(scene, renderer, camera) {
            let loadSuccess = false;
            const maxRetries = 3;
            let retryCount = 0;
            
            // ç­–ç•¥1ï¼šåŒæ­¥é¢„åŠ è½½ + ç¼“å­˜ç ´å
            function trySyncLoad() {
                const img = new Image();
                const timestamp = Date.now();
                const cacheBusterUrl = `./christmas_tree.jpg?_=${timestamp}&retry=${retryCount}`;
                
                console.log(`ğŸ”„ åŒæ­¥åŠ è½½å°è¯• ${retryCount + 1}: ${cacheBusterUrl}`);
                
                // å¼ºåˆ¶åˆ·æ–°ç¼“å­˜
                img.src = '';
                
                setTimeout(() => {
                    img.crossOrigin = 'anonymous';
                    img.onload = function() {
                        if (loadSuccess) return;
                        loadSuccess = true;
                        console.log('âœ… åŒæ­¥åŠ è½½æˆåŠŸ!');
                        applyImageBackground(img, scene, renderer, camera);
                    };
                    
                    img.onerror = function() {
                        console.log(`âŒ åŒæ­¥åŠ è½½å¤±è´¥ ${retryCount + 1}`);
                        retryCount++;
                        if (retryCount < maxRetries) {
                            setTimeout(trySyncLoad, 200 * retryCount);
                        } else {
                            // åŒæ­¥å¤±è´¥ï¼Œå°è¯•å¼‚æ­¥ç­–ç•¥
                            tryAsyncLoad();
                        }
                    };
                    
                    img.src = cacheBusterUrl;
                }, 100);
            }
            
            // ç­–ç•¥2ï¼šå¼‚æ­¥åŠ è½½ + XMLHttpRequest
            function tryAsyncLoad() {
                console.log('ğŸ”„ å°è¯•å¼‚æ­¥åŠ è½½ç­–ç•¥...');
                
                const xhr = new XMLHttpRequest();
                xhr.open('GET', './christmas_tree.jpg', true);
                xhr.responseType = 'blob';
                
                xhr.onload = function() {
                    if (loadSuccess) return;
                    
                    if (xhr.status === 200) {
                        const blob = xhr.response;
                        const url = URL.createObjectURL(blob);
                        
                        const img = new Image();
                        img.onload = function() {
                            if (loadSuccess) return;
                            loadSuccess = true;
                            console.log('âœ… å¼‚æ­¥åŠ è½½æˆåŠŸ!');
                            applyImageBackground(img, scene, renderer, camera);
                            URL.revokeObjectURL(url);
                        };
                        img.onerror = function() {
                            console.log('âŒ å¼‚æ­¥å›¾ç‰‡åˆ›å»ºå¤±è´¥');
                            tryCanvasBasedLoad();
                        };
                        img.src = url;
                    } else {
                        console.log('âŒ å¼‚æ­¥HTTPè¯·æ±‚å¤±è´¥');
                        tryCanvasBasedLoad();
                    }
                };
                
                xhr.onerror = function() {
                    console.log('âŒ å¼‚æ­¥è¯·æ±‚ç½‘ç»œé”™è¯¯');
                    tryCanvasBasedLoad();
                };
                
                xhr.send();
            }
            
            // ç­–ç•¥3ï¼šCanvasé‡ç»˜
            function tryCanvasBasedLoad() {
                console.log('ğŸ”„ å°è¯•Canvasé‡ç»˜ç­–ç•¥...');
                
                const img = new Image();
                img.onload = function() {
                    if (loadSuccess) return;
                    loadSuccess = true;
                    
                    // é€šè¿‡Canvasé‡æ–°ç»˜åˆ¶ï¼Œç¡®ä¿è·¨åŸŸå…¼å®¹
                    const canvas = document.createElement('canvas');
                    canvas.width = img.width;
                    canvas.height = img.height;
                    const ctx = canvas.getContext('2d');
                    
                    try {
                        ctx.drawImage(img, 0, 0);
                        const canvasTexture = new THREE.CanvasTexture(canvas);
                        scene.background = canvasTexture;
                        renderer.render(scene, camera);
                        console.log('âœ… Canvasé‡ç»˜æˆåŠŸ!');
                    } catch (e) {
                        console.log('âŒ Canvasé‡ç»˜å¤±è´¥:', e);
                        createEnhancedFallback(scene, renderer, camera);
                    }
                };
                
                img.onerror = function() {
                    console.log('âŒ Canvaså›¾ç‰‡åŠ è½½å¤±è´¥');
                    createEnhancedFallback(scene, renderer, camera);
                };
                
                // å°è¯•ä¸åŒçš„è·¯å¾„å˜ä½“
                img.src = retryCount === 0 ? 'christmas_tree.jpg' : './christmas_tree.jpg';
            }
            
            // ç­–ç•¥4ï¼šå¢å¼ºçš„åå¤‡æ–¹æ¡ˆ
            function createEnhancedFallback(scene, renderer, camera) {
                console.log('ğŸ¨ åˆ›å»ºå¢å¼ºåå¤‡èƒŒæ™¯...');
                
                const canvas = document.createElement('canvas');
                canvas.width = 1024;
                canvas.height = 1024;
                const ctx = canvas.getContext('2d');
                
                // åˆ›å»ºå¤æ‚æ˜Ÿç©ºèƒŒæ™¯
                // æ·±è“æ¸å˜
                const bgGradient = ctx.createRadialGradient(512, 512, 100, 512, 512, 800);
                bgGradient.addColorStop(0, '#003366');
                bgGradient.addColorStop(0.5, '#002244');
                bgGradient.addColorStop(1, '#001122');
                ctx.fillStyle = bgGradient;
                ctx.fillRect(0, 0, 1024, 1024);
                
                // æ·»åŠ æ˜Ÿæ˜Ÿ
                for (let i = 0; i < 500; i++) {
                    const x = Math.random() * 1024;
                    const y = Math.random() * 1024;
                    const size = Math.random() * 2;
                    const opacity = Math.random() * 0.8 + 0.2;
                    
                    ctx.fillStyle = `rgba(255, 255, 255, ${opacity})`;
                    ctx.beginPath();
                    ctx.arc(x, y, size, 0, Math.PI * 2);
                    ctx.fill();
                }
                
                // æ·»åŠ å½©è‰²æ˜Ÿæ˜Ÿ
                for (let i = 0; i < 50; i++) {
                    const x = Math.random() * 1024;
                    const y = Math.random() * 1024;
                    const colors = ['#ffff99', '#99ccff', '#ff99cc', '#ccff99'];
                    const color = colors[Math.floor(Math.random() * colors.length)];
                    
                    ctx.fillStyle = color;
                    ctx.fillRect(x, y, 1, 1);
                }
                
                const enhancedTexture = new THREE.CanvasTexture(canvas);
                scene.background = enhancedTexture;
                renderer.render(scene, camera);
                
                console.log('âœ… å¢å¼ºåå¤‡èƒŒæ™¯å·²åº”ç”¨');
            }
            
            // åº”ç”¨æˆåŠŸåŠ è½½çš„å›¾ç‰‡
            function applyImageBackground(img, scene, renderer, camera) {
                const texture = new THREE.Texture(img);
                texture.needsUpdate = true;
                texture.colorSpace = THREE.SRGBColorSpace;
                texture.minFilter = THREE.LinearFilter;
                texture.magFilter = THREE.LinearFilter;
                texture.wrapS = THREE.ClampToEdgeWrapping;
                texture.wrapT = THREE.ClampToEdgeWrapping;
                texture.generateMipmaps = false;
                
                scene.background = texture;
                
                // å¤šæ¬¡æ¸²æŸ“ç¡®ä¿æ˜¾ç¤º
                setTimeout(() => renderer.render(scene, camera), 50);
                setTimeout(() => renderer.render(scene, camera), 200);
                setTimeout(() => renderer.render(scene, camera), 500);
                
                console.log('ğŸ‰ èƒŒæ™¯å›¾ç‰‡åº”ç”¨æˆåŠŸ!');
            }
            
            // å¼€å§‹å°è¯•
            trySyncLoad();
        }
        
        /**
         * ä½¿ç”¨åŸç”ŸImageå¯¹è±¡åŠ è½½å›¾ç‰‡ï¼ˆé¿å…è·¨åŸŸé—®é¢˜ï¼‰
         */
        function loadImageWithNative(imagePath, scene, renderer, camera) {
            console.log('ğŸ–¼ï¸ ä½¿ç”¨åŸç”ŸImageå¯¹è±¡åŠ è½½:', imagePath);
            
            const img = new Image();
            
            // å…³é”®ï¼šè®¾ç½®crossOriginå±æ€§
            img.crossOrigin = 'anonymous';
            
            img.onload = function() {
                console.log('âœ… åŸç”ŸImageåŠ è½½æˆåŠŸ');
                
                const texture = new THREE.Texture(img);
                texture.needsUpdate = true;
                texture.colorSpace = THREE.SRGBColorSpace;
                texture.minFilter = THREE.LinearFilter;
                texture.magFilter = THREE.LinearFilter;
                texture.wrapS = THREE.ClampToEdgeWrapping;
                texture.wrapT = THREE.ClampToEdgeWrapping;
                texture.generateMipmaps = false;
                
                scene.background = texture;
                
                // å¼ºåˆ¶æ¸²æŸ“
                setTimeout(() => {
                    renderer.render(scene, camera);
                    console.log('èƒŒæ™¯å›¾ç‰‡å·²åº”ç”¨');
                }, 100);
            };
            
            img.onerror = function(err) {
                console.error('âŒ åŸç”ŸImageåŠ è½½å¤±è´¥:', err);
                useFallbackBackground(scene, renderer, camera);
            };
            
            img.src = imagePath;
        }
        
        /**
         * å°è¯•å¤šä¸ªè·¯å¾„
         */
        function tryMultiplePaths(scene, renderer, camera) {
            const imagePaths = [
                './christmas_tree.jpg',           
                'christmas_tree.jpg',             
                './christmas_tree.jpg?v=' + Date.now(),
                window.location.origin + '/christmas_tree.jpg'
            ];
            
            let pathIndex = 0;
            
            function tryNextPath() {
                if (pathIndex >= imagePaths.length) {
                    console.error('æ‰€æœ‰HTTPè·¯å¾„éƒ½å¤±è´¥ï¼Œå°è¯•åŸç”ŸImageåŠ è½½');
                    loadImageWithNative('./christmas_tree.jpg', scene, renderer, camera);
                    return;
                }
                
                const currentPath = imagePaths[pathIndex];
                console.log(`ğŸ” å°è¯•HTTPè·¯å¾„ ${pathIndex + 1}: ${currentPath}`);
                
                // å…ˆæµ‹è¯•æ–‡ä»¶æ˜¯å¦å­˜åœ¨
                fetch(currentPath, { method: 'HEAD' })
                    .then(response => {
                        if (response.ok) {
                            console.log(`âœ… HTTP HEADè¯·æ±‚æˆåŠŸ: ${currentPath}`);
                            loadImageWithNative(currentPath, scene, renderer, camera);
                        } else {
                            throw new Error(`HTTP ${response.status}: ${response.statusText}`);
                        }
                    })
                    .catch(err => {
                        console.error(`âŒ HTTPè·¯å¾„å¤±è´¥: ${currentPath}`, err);
                        pathIndex++;
                        tryNextPath();
                    });
            }
            
            tryNextPath();
        }
        
        /**
         * ä½¿ç”¨åå¤‡èƒŒæ™¯
         */
        function useFallbackBackground(scene, renderer, camera) {
            console.log('ğŸ¨ ä½¿ç”¨æ¸å˜èƒŒæ™¯ä½œä¸ºåå¤‡');
            
            // åˆ›å»ºæ¸å˜èƒŒæ™¯
            const canvas = document.createElement('canvas');
            canvas.width = 512;
            canvas.height = 512;
            const ctx = canvas.getContext('2d');
            
            // åˆ›å»ºæ¸å˜
            const gradient = ctx.createLinearGradient(0, 0, 0, 512);
            gradient.addColorStop(0, '#001133');
            gradient.addColorStop(0.5, '#003366');
            gradient.addColorStop(1, '#112244');
            
            ctx.fillStyle = gradient;
            ctx.fillRect(0, 0, 512, 512);
            
            // æ·»åŠ æ˜Ÿæ˜Ÿæ•ˆæœ
            for (let i = 0; i < 100; i++) {
                ctx.fillStyle = `rgba(255, 255, 255, ${Math.random()})`;
                ctx.fillRect(
                    Math.random() * 512,
                    Math.random() * 512,
                    1, 1
                );
            }
            
            const texture = new THREE.CanvasTexture(canvas);
            scene.background = texture;
            renderer.render(scene, camera);
            
            console.log('âœ… æ¸å˜èƒŒæ™¯å·²åº”ç”¨');
        }
        
        /**
         * åˆ›å»ºé›ªèŠ±ç²’å­ç³»ç»Ÿï¼ˆæ¸è¿›å¼ï¼‰
         */
        function createSnowParticles(scene) { // é›ªèŠ±ç²’å­ç³»ç»Ÿåˆ›å»ºå‡½æ•°å¼€å§‹
            const { COUNT, MAX_HEIGHT, RANGE, BASE_SPEED, SPEED_VARIANCE } = CONFIG.SNOW; // è§£æ„è·å–é›ªèŠ±é…ç½®
            
            // åˆ›å»ºå‡ ä½•ä½“
            const snowGeometry = new THREE.BufferGeometry(); // åˆ›å»ºç¼“å†²å‡ ä½•ä½“
            
            // åˆ›å»ºå±æ€§æ•°ç»„
            const snowPositions = new Float32Array(COUNT * 3); // ä½ç½®æ•°ç»„ï¼ˆX,Y,Zåæ ‡ï¼‰
            const snowColors = new Float32Array(COUNT * 3); // é¢œè‰²æ•°ç»„ï¼ˆR,G,Bå€¼ï¼‰
            const snowSizes = new Float32Array(COUNT); // å¤§å°æ•°ç»„
            const snowSpeeds = new Float32Array(COUNT); // é€Ÿåº¦æ•°ç»„
            const snowActive = new Float32Array(COUNT); // æ¿€æ´»çŠ¶æ€æ•°ç»„ï¼ˆæ§åˆ¶æ¯ä¸ªç²’å­æ˜¯å¦æ´»è·ƒï¼‰
            
            // ç™½è‰²é›ªèŠ±
            const whiteColor = new THREE.Color(0xffffff); // åˆ›å»ºç™½è‰²é¢œè‰²å¯¹è±¡
            const whiteColorArray = [whiteColor.r, whiteColor.g, whiteColor.b]; // è·å–é¢œè‰²RGBå€¼æ•°ç»„
            
            // åˆå§‹åŒ–é›ªèŠ±ç²’å­ï¼ˆåˆå§‹éƒ½ä¸æ´»è·ƒï¼‰
            for (let i = 0; i < COUNT; i++) { // éå†æ‰€æœ‰é›ªèŠ±ç²’å­
                const i3 = i * 3; // è®¡ç®—ä½ç½®æ•°ç»„ç´¢å¼•ï¼ˆæ¯ä¸ªç²’å­3ä¸ªåæ ‡å€¼ï¼‰
                
                // éšæœºä½ç½®ï¼ˆåˆå§‹åœ¨å¾ˆé«˜çš„åœ°æ–¹ï¼‰
                snowPositions[i3] = (Math.random() - 0.5) * RANGE; // Xåæ ‡éšæœº
                snowPositions[i3 + 1] = MAX_HEIGHT + Math.random() * 10; // Yåæ ‡ï¼ˆæ›´é«˜å¤„ï¼‰
                snowPositions[i3 + 2] = (Math.random() - 0.5) * RANGE; // Zåæ ‡éšæœº
                
                // ç™½è‰²
                snowColors.set(whiteColorArray, i3); // è®¾ç½®ç²’å­é¢œè‰²ä¸ºç™½è‰²
                
                // éšæœºå¤§å°
                snowSizes[i] = 0.05 + Math.random() * 0.2; // éšæœºå¤§å°èŒƒå›´0.05-0.25
                
                // éšæœºé€Ÿåº¦
                snowSpeeds[i] = BASE_SPEED + Math.random() * SPEED_VARIANCE; // åŸºç¡€é€Ÿåº¦åŠ éšæœºå˜åŒ–
                
                // åˆå§‹ä¸æ´»è·ƒ
                snowActive[i] = 0; // è®¾ç½®ä¸ºä¸æ´»è·ƒçŠ¶æ€
            } // é›ªèŠ±ç²’å­åˆå§‹åŒ–å¾ªç¯ç»“æŸ
            
            // è®¾ç½®å‡ ä½•ä½“å±æ€§
            snowGeometry.setAttribute('position', new THREE.BufferAttribute(snowPositions, 3));
            snowGeometry.setAttribute('color', new THREE.BufferAttribute(snowColors, 3));
            snowGeometry.setAttribute('size', new THREE.BufferAttribute(snowSizes, 1));
            snowGeometry.setAttribute('active', new THREE.BufferAttribute(snowActive, 1));
            
            // åˆ›å»ºæè´¨
            const snowMaterial = new THREE.PointsMaterial({
                size: 0.1,
                vertexColors: true,
                transparent: true,
                opacity: 0.8,
                blending: THREE.AdditiveBlending,
                sizeAttenuation: true
            });
            
            // åˆ›å»ºç²’å­ç³»ç»Ÿ
            const snowParticles = new THREE.Points(snowGeometry, snowMaterial);
            scene.add(snowParticles);
            
            // è¿”å›åŠ¨ç”»æ›´æ–°å‡½æ•°
            return {
                snowParticles,
                updateSnowAnimation: (time, fadeInComplete, snowStartTime) => updateSnowAnimation(snowParticles, COUNT, snowSpeeds, time, fadeInComplete, snowStartTime)
            };
        }
        
        /**
         * æ›´æ–°é›ªèŠ±åŠ¨ç”»ï¼ˆæ¸è¿›å¼æ¿€æ´»ï¼‰
         */
        function updateSnowAnimation(snowParticles, particleCount, snowSpeeds, time, fadeInComplete, snowStartTime) {
            const { MAX_HEIGHT, MIN_HEIGHT, RANGE, WIND_DIRECTION, BASE_SPEED, SPEED_VARIANCE } = CONFIG.SNOW;
            const positionsArray = snowParticles.geometry.attributes.position.array;
            const activeArray = snowParticles.geometry.attributes.active.array;
            
            const elapsedSinceSnowStart = snowStartTime ? (Date.now() - snowStartTime) / 1000 : 0;
            
            for (let i = 0; i < particleCount; i++) {
                const i3 = i * 3;
                const speed = snowSpeeds[i];
                
                // æ¸è¿›å¼æ¿€æ´»é›ªèŠ±ï¼ˆ0.8ç§’å†…é€æ¸æ¿€æ´»æ‰€æœ‰é›ªèŠ±ï¼‰
                if (activeArray[i] === 0 && elapsedSinceSnowStart > 0) {
                    const activationDelay = (i / particleCount) * 0.8; // æ¯ä¸ªç²’å­å»¶è¿Ÿæ¿€æ´»
                    if (elapsedSinceSnowStart >= activationDelay) {
                        activeArray[i] = 1;
                        // å°†æ´»è·ƒç²’å­ä»é«˜å¤„å¼€å§‹ä¸‹è½
                        positionsArray[i3 + 1] = MAX_HEIGHT + Math.random() * 5;
                    }
                }
                
                // åªæœ‰æ´»è·ƒçš„é›ªèŠ±æ‰å‚ä¸åŠ¨ç”»
                if (activeArray[i] === 1) {
                    // é›ªèŠ±ä¸‹è½ - ä½¿ç”¨æ›´è‡ªç„¶çš„é€Ÿåº¦
                    positionsArray[i3 + 1] -= speed * 0.6; // é™ä½ä¸‹è½é€Ÿåº¦
                    
                    // é£çš„å½±å“ï¼ˆæ›´è½»å¾®ï¼‰
                    positionsArray[i3] += WIND_DIRECTION.x * 0.3;
                    positionsArray[i3 + 2] += WIND_DIRECTION.z * 0.3;
                    
                    // å·¦å³æ‘‡æ‘†ï¼ˆæ›´ç¼“æ…¢ï¼‰
                    positionsArray[i3] += Math.sin(time * 0.3 + i * 0.1) * 0.005;
                    positionsArray[i3 + 2] += Math.cos(time * 0.4 + i * 0.15) * 0.004;
                    
                    // é›ªèŠ±é‡æ–°ç”Ÿæˆ
                    if (positionsArray[i3 + 1] < MIN_HEIGHT) {
                        positionsArray[i3 + 1] = MAX_HEIGHT + Math.random() * 10;
                        positionsArray[i3] = (Math.random() - 0.5) * RANGE;
                        positionsArray[i3 + 2] = (Math.random() - 0.5) * RANGE;
                    }
                }
            }
            
            snowParticles.geometry.attributes.position.needsUpdate = true;
            snowParticles.geometry.attributes.active.needsUpdate = true;
            
            // é›ªèŠ±é€æ˜åº¦å˜åŒ– - åªåœ¨æ·¡å…¥å®Œæˆåæ‰åº”ç”¨åŠ¨æ€å˜åŒ–
            if (fadeInComplete && snowParticles.material) {
                snowParticles.material.opacity = 0.6 + Math.sin(time * 0.3) * 0.2;
            }
        }
        
        /**
         * åˆ›å»ºæ ‘ç²’å­ç³»ç»Ÿï¼ˆæ‰¹å¤„ç†ç‰ˆæœ¬ï¼‰
         */
        function createTreeParticlesBatched() {
            const batches = [];
            const { PARTICLE_COUNT, BATCH_SIZE } = CONFIG.TREE;
            
            // å°†ç²’å­åˆ†ç»„ä¸ºæ‰¹æ¬¡ï¼Œæ¯ä¸ªæ‰¹æ¬¡æ˜¯ä¸€ç»„"æ˜Ÿå½¢ç²’å­"
            const BATCH_PARTICLE_COUNT = CONFIG.TREE.BATCH_SIZE; // æ¯ä¸ªæ˜Ÿå½¢ç²’å­åŒ…å«çš„åŸå§‹ç²’å­æ•°
            const batchCount = Math.floor(PARTICLE_COUNT / BATCH_PARTICLE_COUNT);
            
            // å­˜å‚¨æ‰€æœ‰ç²’å­çš„ç›®æ ‡ä½ç½®ã€é¢œè‰²å’Œå¤§å°
            const particleData = [];
            
            // å…ˆç”Ÿæˆæ‰€æœ‰ç²’å­çš„ç›®æ ‡ä½ç½®ã€é¢œè‰²å’Œå¤§å°
            for (let i = 0; i < PARTICLE_COUNT; i++) {
                const i3 = i * 3;
                
                // éšæœºé€‰æ‹©ç²’å­ç±»å‹ï¼ˆæ ‘å¹²æˆ–æ ‘å¶ï¼‰
                const isTrunk = Math.random() < CONFIG.TREE.TRUNK_RATIO;
                
                const data = {
                    index: i,
                    isTrunk: isTrunk,
                    targetPosition: new THREE.Vector3(),
                    color: new THREE.Color(),
                    size: 0
                };
                
                // ç”Ÿæˆç²’å­åœ¨æ ‘ä¸­çš„ä½ç½®å’Œå±æ€§
                if (isTrunk) {
                    generateTrunkParticleData(data);
                } else {
                    generateLeafParticleData(data);
                }
                
                particleData.push(data);
            }
            
            // åˆ›å»ºæ‰¹æ¬¡
            for (let batchIndex = 0; batchIndex < batchCount; batchIndex++) {
                // ä¸ºå½“å‰æ‰¹æ¬¡åˆ›å»ºå•ä¸ªå‡ ä½•ä½“ï¼ŒåŒ…å«æ‰€æœ‰ç²’å­
                const clusterPositions = new Float32Array(BATCH_PARTICLE_COUNT * 3);
                const targetPositions = new Float32Array(BATCH_PARTICLE_COUNT * 3);
                const colors = new Float32Array(BATCH_PARTICLE_COUNT * 3);
                const sizes = new Float32Array(BATCH_PARTICLE_COUNT);
                const baseSizes = new Float32Array(BATCH_PARTICLE_COUNT);
                
                for (let i = 0; i < BATCH_PARTICLE_COUNT; i++) {
                    const particleIndex = batchIndex * BATCH_PARTICLE_COUNT + i;
                    if (particleIndex >= PARTICLE_COUNT) break;
                    
                    const data = particleData[particleIndex];
                    const i3 = i * 3;
                    
                    // å°†ç²’å­éšæœºåˆ†å¸ƒåœ¨ç©ºé—´ä¸­ï¼Œå½¢æˆæ˜Ÿå½¢æ•ˆæœ
                    const randomRadius = CONFIG.ANIMATION.PARTICLE_ANIMATION.INITIAL_RADIUS;
                    clusterPositions[i3] = (Math.random() - 0.5) * randomRadius * 2;
                    clusterPositions[i3 + 1] = (Math.random() - 0.5) * randomRadius * 1.5 + randomRadius * 0.2;
                    clusterPositions[i3 + 2] = (Math.random() - 0.5) * randomRadius * 2;
                    
                    // ç›®æ ‡ä½ç½®
                    targetPositions[i3] = data.targetPosition.x;
                    targetPositions[i3 + 1] = data.targetPosition.y;
                    targetPositions[i3 + 2] = data.targetPosition.z;
                    
                    // é¢œè‰²
                    colors[i3] = data.color.r;
                    colors[i3 + 1] = data.color.g;
                    colors[i3 + 2] = data.color.b;
                    
                    // å¤§å° - åˆå§‹è®¾ç½®ä¸ºæ˜Ÿå½¢å¤§å°
                    const starSizeMultiplier = 3.0;
                    sizes[i] = data.size * starSizeMultiplier;
                    baseSizes[i] = data.size;
                }
                
                // åˆ›å»ºå‡ ä½•ä½“
                const geometry = new THREE.BufferGeometry();
                geometry.setAttribute('position', new THREE.BufferAttribute(clusterPositions, 3));
                geometry.setAttribute('targetPosition', new THREE.BufferAttribute(targetPositions, 3));
                geometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));
                geometry.setAttribute('size', new THREE.BufferAttribute(sizes, 1));
                geometry.setAttribute('baseSize', new THREE.BufferAttribute(baseSizes, 1));
                // æ˜Ÿæ˜Ÿé˜¶æ®µçš„å¤§å°å€ç‡
                const starSizes = new Float32Array(BATCH_PARTICLE_COUNT).fill(3.0);
                geometry.setAttribute('starSize', new THREE.BufferAttribute(starSizes, 1));
                
                // åˆ›å»ºæè´¨
                const material = new THREE.PointsMaterial({
                    size: 0.25,
                    vertexColors: true,
                    transparent: true,
                    opacity: 1,
                    blending: THREE.AdditiveBlending
                });
                
                const points = new THREE.Points(geometry, material);
                points.visible = false; // ä¸€å¼€å§‹ä¸å¯è§
                
                // ä¿å­˜æ‰¹æ¬¡æ•°æ®
                points.userData.originalPositions = clusterPositions;
                points.userData.targetPositions = targetPositions;
                points.userData.batchIndex = batchIndex;
                points.userData.starPhase = 0; // 0: æ˜Ÿå½¢é˜¶æ®µ, 1: è¿‡æ¸¡é˜¶æ®µ, 2: æœ€ç»ˆä½ç½®
                
                // å°†æ˜Ÿå½¢ç²’å­ç»„æ·»åŠ åˆ°æ‰¹æ¬¡æ•°ç»„
                batches.push(points);
            }
            
            return batches;
        }
        
        /**
         * ç”Ÿæˆæ ‘å¹²ç²’å­æ•°æ®
         */
        function generateTrunkParticleData(data) {
            const { TRUNK_HEIGHT, TRUNK_BASE_RADIUS, TRUNK_TOP_RADIUS } = CONFIG.TREE;
            
            // æ ‘å¹²é«˜åº¦
            const height = Math.random() * TRUNK_HEIGHT;
            
            // æ ‘å¹²åŠå¾„éšé«˜åº¦å˜åŒ–
            const radiusRatio = height / TRUNK_HEIGHT;
            const radius = TRUNK_BASE_RADIUS - (TRUNK_BASE_RADIUS - TRUNK_TOP_RADIUS) * radiusRatio;
            const angle = Math.random() * Math.PI * 2;
            
            // è®¾ç½®ä½ç½®
            data.targetPosition.set(
                Math.cos(angle) * radius,
                height,
                Math.sin(angle) * radius
            );
            
            // è®¾ç½®é¢œè‰²
            const trunkColor = CONFIG.COLORS.TREE[9];
            data.color.set(trunkColor.r, trunkColor.g, trunkColor.b);
            
            // è®¾ç½®å¤§å°
            data.size = 2 + Math.random() * 3;
        }
        
        /**
         * ç”Ÿæˆæ ‘å¶ç²’å­æ•°æ®
         */
        function generateLeafParticleData(data) {
            const { 
                LEAF_HEIGHT_RANGE, LEAF_BASE_HEIGHT, LEAF_BASE_RADIUS, 
                RIBBON_PROBABILITY, RIBBON_COUNT, RIBBON_SPIRAL_TURNS 
            } = CONFIG.TREE;
            
            // éšæœºé«˜åº¦
            const randomHeight = Math.random() * LEAF_HEIGHT_RANGE + LEAF_BASE_HEIGHT;
            
            // åœ†é”¥å½¢çŠ¶è®¡ç®—
            const heightRatio = (randomHeight - LEAF_BASE_HEIGHT) / LEAF_HEIGHT_RANGE;
            const maxRadius = LEAF_BASE_RADIUS * (1 - heightRatio);
            
            // æ˜¯å¦ç”Ÿæˆå½©å¸¦ç²’å­
            const isRibbon = Math.random() < RIBBON_PROBABILITY;
            
            let radius, angle;
            let ribbonColorIndex = -1;
            
            if (isRibbon) {
                // å½©å¸¦ç²’å­ï¼šèºæ—‹åˆ†å¸ƒ
                const ribbonIndex = Math.floor(Math.random() * RIBBON_COUNT);
                const ribbonColors = CONFIG.COLORS.RIBBON;
                ribbonColorIndex = ribbonColors[Math.floor(Math.random() * ribbonColors.length)];
                
                const spiralOffset = (ribbonIndex / RIBBON_COUNT) * 2 * Math.PI;
                const spiralAngle = spiralOffset + (randomHeight - LEAF_BASE_HEIGHT) * 
                    (2 * Math.PI * RIBBON_SPIRAL_TURNS / LEAF_HEIGHT_RANGE);
                
                // å½©å¸¦ç²’å­åªåœ¨æ ‘çš„æœ€å¤–å±‚ç”Ÿæˆ
                radius = maxRadius * (0.92 + Math.random() * 0.08);
                angle = spiralAngle + (Math.random() - 0.5) * 0.1;
            } else {
                // æ™®é€šæ ‘å¶ç²’å­ï¼šéšæœºåˆ†å¸ƒ
                radius = Math.sqrt(Math.random()) * maxRadius;
                angle = Math.random() * Math.PI * 2;
                
                // æŒ‰é«˜åº¦è°ƒæ•´å¯†åº¦
                const densityFactor = 1.2 - Math.abs(heightRatio - 0.5) * 0.4;
                
                // è¿™é‡Œä¸å†ç”Ÿæˆè¿œç¦»æ ‘çš„ä¸å¯è§ç²’å­ï¼Œè€Œæ˜¯ç›´æ¥è·³è¿‡åˆ›å»ºï¼Œè¿™æ ·æ›´é«˜æ•ˆ
                if (Math.random() <= 0.2 * densityFactor) {
                    // è·³è¿‡åˆ›å»ºè¯¥ç²’å­ï¼Œå‡å°‘ä¸å¿…è¦çš„æ¸²æŸ“
                    data.targetPosition.set(0, 0, 0);
                    data.color.setRGB(0, 0, 0); // è®¾ç½®ä¸ºé»‘è‰²
                    data.size = 0; // è®¾ç½®ä¸ºä¸å¯è§å¤§å°
                    return;
                }
            }
            
            // è®¾ç½®ä½ç½®
            data.targetPosition.set(
                Math.cos(angle) * radius,
                randomHeight,
                Math.sin(angle) * radius
            );
            
            // è®¾ç½®é¢œè‰²
            const colorIndex = determineLeafColorIndex(isRibbon, ribbonColorIndex, heightRatio);
            const color = CONFIG.COLORS.TREE[colorIndex];
            
            // åº”ç”¨é˜´å½±æ•ˆæœï¼ˆä»…æ™®é€šæ ‘å¶ï¼‰
            if (!isRibbon) {
                const shadowFactor = 0.8 + heightRatio * 0.2;
                data.color.setRGB(color.r * shadowFactor, color.g * shadowFactor, color.b * shadowFactor);
            } else {
                data.color.setRGB(color.r, color.g, color.b);
            }
            
            // è®¾ç½®å¤§å°
            const sizeFactor = heightRatio > 0.8 ? 0.8 : 1.0;
            const ribbonSizeFactor = isRibbon ? 1.8 : 1.0;
            data.size = (1.5 + Math.random() * 3) * sizeFactor * ribbonSizeFactor * (0.9 + Math.random() * 0.2);
        }
        
        /**
         * åˆ›å»ºåœ£è¯æ ‘
         */
        function createChristmasTree(scene) { // åœ£è¯æ ‘åˆ›å»ºå‡½æ•°å¼€å§‹
            
            // åˆ›å»ºç²’å­ç³»ç»Ÿï¼ˆæ‰¹å¤„ç†ç‰ˆæœ¬ï¼‰
            const particleBatches = createTreeParticlesBatched(); // è°ƒç”¨æ‰¹æ¬¡ç²’å­åˆ›å»ºå‡½æ•°
            
            // åˆ›å»ºæ ‘çš„æ ¹å®¹å™¨
            const treeGroup = new THREE.Group(); // åˆ›å»º3Dç»„å¯¹è±¡ä½œä¸ºæ ‘çš„æ ¹å®¹å™¨
            
            // æ·»åŠ æ‰€æœ‰æ‰¹æ¬¡åˆ°æ ‘ç»„ï¼ˆæ¯ä¸ªæ‰¹æ¬¡æ˜¯ä¸€ä¸ªPointså¯¹è±¡ï¼‰
            particleBatches.forEach(batch => { // éå†æ‰€æœ‰ç²’å­æ‰¹æ¬¡
                treeGroup.add(batch); // å°†æ‰¹æ¬¡æ·»åŠ åˆ°æ ‘ç»„ä¸­
            }); // éå†ç»“æŸ
            scene.add(treeGroup); // å°†æ ‘ç»„æ·»åŠ åˆ°åœºæ™¯ä¸­
            
            // æ·»åŠ å½©è‰²è£…é¥°ç¯
            const coloredLightObjects = addColoredLights(treeGroup); // è°ƒç”¨å½©è‰²ç¯å…‰æ·»åŠ å‡½æ•°
            
            // è®¾ç½®æ ‘çš„ä½ç½®å’Œç¼©æ”¾
            treeGroup.position.copy(CONFIG.TREE.POSITION_OFFSET); // è®¾ç½®æ ‘çš„ä½ç½®åç§»
            treeGroup.scale.copy(CONFIG.TREE.SCALE); // è®¾ç½®æ ‘çš„ç¼©æ”¾æ¯”ä¾‹
            treeGroup.updateMatrixWorld(true); // æ›´æ–°ä¸–ç•ŒçŸ©é˜µ
            
            // åˆå§‹åŒ–åŠ¨ç”»çŠ¶æ€
            const animationState = { // åˆ›å»ºåŠ¨ç”»çŠ¶æ€å¯¹è±¡
                startTime: Date.now(), // è®°å½•å¼€å§‹æ—¶é—´
                completed: false, // åŠ¨ç”»æ˜¯å¦å®Œæˆæ ‡è®°
                isRotating: false, // æ—‹è½¬çŠ¶æ€æ ‡è®°
                snowStarted: false, // é›ªèŠ±æ˜¯å¦å¼€å§‹æ ‡è®°
                snowStartTime: 0, // é›ªèŠ±å¼€å§‹æ—¶é—´æˆ³
                treeCompleted: false // æ ‘æ˜¯å¦å®Œå…¨æˆå‹æ ‡è®°
            }; // animationStateå¯¹è±¡å®šä¹‰ç»“æŸ
            
            return { // è¿”å›åˆ›å»ºçš„åœ£è¯æ ‘ç›¸å…³å¯¹è±¡
                treeGroup, // æ ‘ç»„
                particleBatches, // ç²’å­æ‰¹æ¬¡
                coloredLightObjects, // å½©è‰²ç¯å…‰
                animationState // åŠ¨ç”»çŠ¶æ€
            }; // returnè¯­å¥ç»“æŸ
        } // createChristmasTreeå‡½æ•°ç»“æŸ
        

        

        
        /**
         * ç¡®å®šæ ‘å¶é¢œè‰²ç´¢å¼•
         */
        function determineLeafColorIndex(isRibbon, ribbonColorIndex, heightRatio) {
            if (isRibbon && ribbonColorIndex !== -1) {
                return ribbonColorIndex;
            }
            
            // æ™®é€šæ ‘å¶ç²’å­é¢œè‰²
            const rand = Math.random();
            if (rand < 0.97) {
                return Math.floor(Math.random() * 4); // é€‰æ‹©å‰4ç§æ·±ç»¿/å†·ç»¿é¢œè‰²
            } else {
                return 7 + Math.floor(Math.random() * 2); // é€‰æ‹©é«˜å…‰é¢œè‰²
            }
        }
        
        /**
         * æ·»åŠ å½©è‰²è£…é¥°ç¯
         */
        function addColoredLights(treeGroup) {
            const coloredLightObjects = [];
            
            CONFIG.LIGHTS.forEach((lightConfig, index) => {
                const coloredLight = new THREE.PointLight(
                    lightConfig.color, 
                    lightConfig.intensity, 
                    lightConfig.distance
                );
                
                // éšæœºä½ç½®
                const angle = (index / CONFIG.LIGHTS.length) * Math.PI * 2;
                const radius = 3 + Math.random() * 2;
                coloredLight.position.set(
                    Math.cos(angle) * radius,
                    5 + Math.random() * 5,
                    Math.sin(angle) * radius
                );
                
                treeGroup.add(coloredLight);
                coloredLightObjects.push(coloredLight);
            });
            
            return coloredLightObjects;
        }
        
        /**
         * åˆå§‹åŒ–ç›¸æœºæ§åˆ¶å‚æ•°
         */
        function initCameraControls(camera) {
            const cameraDistance = camera.position.distanceTo(CONFIG.CAMERA.TARGET);
            
            return {
                rotationX: THREE.MathUtils.degToRad(0),
                rotationY: THREE.MathUtils.degToRad(0),
                distance: cameraDistance
            };
        }
        
        /**
         * æ›´æ–°æ‰¹æ¬¡å¯è§æ€§
         */
        function updateBatchVisibility(batches, startTime) {
            const elapsed = Date.now() - startTime;
            const interval = CONFIG.TREE.BATCH_INTERVAL;
            const visibleCount = Math.floor(elapsed / interval);
            
            for (let i = 0; i < batches.length; i++) {
                if (i <= visibleCount && !batches[i].userData.startTime) {
                    batches[i].visible = true;
                    batches[i].userData.startTime = Date.now();
                }
            }
        }
        
        /**
         * æ£€æŸ¥æ ‘æ˜¯å¦å®Œå…¨æˆå‹
         */
        function checkTreeCompletion(batches, animationState) {
            // æ£€æŸ¥æ‰€æœ‰æ‰¹æ¬¡æ˜¯å¦éƒ½åˆ°è¾¾æœ€ç»ˆä½ç½®ï¼ˆstarPhase = 2ï¼‰
            const allBatchesCompleted = batches.every(batch => 
                batch.visible && batch.userData.starPhase >= 2
            );
            
            if (allBatchesCompleted && !animationState.treeCompleted) {
                animationState.treeCompleted = true;
                return true; // æ ‘åˆšå®Œæˆ
            }
            
            return false; // æ ‘æœªå®Œæˆæˆ–å·²ç»å®Œæˆ
        }

        /**
         * æ›´æ–°æ‰¹æ¬¡ç§»åŠ¨åŠ¨ç”»
         */
        function updateBatchMovement(batches, startTime) {
            const now = Date.now();
            const appearInterval = CONFIG.TREE.BATCH_INTERVAL;
            const starPhaseDuration = CONFIG.ANIMATION.PARTICLE_ANIMATION.STAR_PHASE_DURATION;
            const transitionDuration = CONFIG.ANIMATION.PARTICLE_ANIMATION.TRANSITION_DURATION;
            
            // è®¡ç®—å…³é”®æ—¶é—´ç‚¹
            const allParticlesVisibleTime = startTime + CONFIG.TREE.BATCH_INTERVAL * Math.ceil(CONFIG.TREE.PARTICLE_COUNT / CONFIG.TREE.BATCH_SIZE) + CONFIG.ANIMATION.PARTICLE_ANIMATION.ALL_PARTICLES_VISIBLE_DELAY;
            const starPhaseEndTime = allParticlesVisibleTime + starPhaseDuration;
            const transitionEndTime = starPhaseEndTime + transitionDuration;
            
            batches.forEach((points, batchIndex) => {
                const time = Date.now() * 0.001;
                const batchAppearTime = startTime + batchIndex * appearInterval;
                const elapsedSinceAppear = now - batchAppearTime;
                
                if (elapsedSinceAppear <= 0) {
                    // æ‰¹æ¬¡è¿˜æœªå‡ºç°ï¼Œä¿æŒé€æ˜
                    points.material.opacity = 0;
                    return;
                }
                
                // æ ¹æ®å½“å‰æ—¶é—´ç¡®å®šåŠ¨ç”»é˜¶æ®µ
                let sparkle, convergeBrightness;
                
                if (now < allParticlesVisibleTime) {
                    // é˜¶æ®µ0ï¼šç²’å­å‡ºç°é˜¶æ®µï¼Œé€æ¸æ˜¾ç¤º
                    const appearProgress = THREE.MathUtils.clamp(elapsedSinceAppear / 500, 0, 1);
                    sparkle = 0.7 + Math.sin(time * 6 + batchIndex) * 0.3;
                    convergeBrightness = appearProgress;
                } else if (now < starPhaseEndTime) {
                    // é˜¶æ®µ1ï¼šæ˜Ÿå½¢é—ªè€€é˜¶æ®µ
                    sparkle = 0.7 + Math.sin(time * 6 + batchIndex) * 0.3;
                    convergeBrightness = 1.0;
                } else if (now < transitionEndTime) {
                    // é˜¶æ®µ2ï¼šè¿‡æ¸¡æ±‡èšé˜¶æ®µ
                    const transitionProgress = THREE.MathUtils.clamp((now - starPhaseEndTime) / transitionDuration, 0, 1);
                    sparkle = 0.7 + Math.sin(time * 6 + batchIndex) * 0.3;
                    convergeBrightness = 1.0;
                } else {
                    // é˜¶æ®µ3ï¼šæœ€ç»ˆå½¢æˆæ ‘
                    sparkle = 0.9 + Math.sin(time * 3 + batchIndex) * 0.1;
                    convergeBrightness = 1.0;
                }
                
                // æœ€ç»ˆé€æ˜åº¦
                points.material.opacity = sparkle * convergeBrightness;
                
                const geometry = points.geometry;
                const positions = geometry.attributes.position.array;
                const targetPositions = geometry.attributes.targetPosition.array;
                
                // é˜¶æ®µ0å’Œ1ï¼šç²’å­å‡ºç°å’Œæ˜Ÿå½¢é—ªè€€é˜¶æ®µ
                if (now < starPhaseEndTime) {
                    // é™æ€æ˜¾ç¤ºï¼Œæ— æ¼‚ç§»æ•ˆæœ
                    for (let i = 0; i < positions.length; i += 3) {
                        // ç›´æ¥ä½¿ç”¨åŸå§‹ä½ç½®ï¼Œä¿æŒé™æ€
                        positions[i] = points.userData.originalPositions[i];
                        positions[i + 1] = points.userData.originalPositions[i + 1];
                        positions[i + 2] = points.userData.originalPositions[i + 2];
                    }
                    
                    geometry.attributes.position.needsUpdate = true;
                    
                    // â­ æ˜Ÿå½¢é˜¶æ®µï¼ˆé—ªè€€ï¼‰- æ§åˆ¶size
                    const sizes = geometry.attributes.size.array;
                    const baseSizes = geometry.attributes.baseSize.array;
                    const starSizes = geometry.attributes.starSize.array;
                    
                    const sparkle = 1 + Math.sin(time * 6 + batchIndex) * 0.3;
                    
                    for (let i = 0; i < sizes.length; i++) {
                        sizes[i] = baseSizes[i] * starSizes[i] * sparkle;
                    }
                    
                    geometry.attributes.size.needsUpdate = true;
                } 
                // é˜¶æ®µ2ï¼šè¿‡æ¸¡æ±‡èšé˜¶æ®µ
                else if (now < transitionEndTime) {
                    const elapsedSinceTransition = now - starPhaseEndTime;
                    const t = elapsedSinceTransition / transitionDuration;
                    // ä½¿ç”¨æ›´æ…¢çš„ç¼“åŠ¨å‡½æ•°ï¼Œä½¿è¿‡æ¸¡æ›´å¹³ç¼“
                    const eased = t < 0.5 ? 2 * t * t : 1 - Math.pow(-2 * t + 2, 2) / 2;
                    
                    // é€šè¿‡BufferAttributeæ•°ç»„è¿›è¡Œä½ç½®æ’å€¼
                    for (let i = 0; i < positions.length; i += 3) {
                        const startX = points.userData.originalPositions[i];
                        const startY = points.userData.originalPositions[i + 1];
                        const startZ = points.userData.originalPositions[i + 2];
                        
                        const targetX = targetPositions[i];
                        const targetY = targetPositions[i + 1];
                        const targetZ = targetPositions[i + 2];
                        
                        // ç›´çº¿è½¨è¿¹æ±‡èš
                        positions[i] = startX + (targetX - startX) * eased;
                        positions[i + 1] = startY + (targetY - startY) * eased;
                        positions[i + 2] = startZ + (targetZ - startZ) * eased;
                    }
                    
                    geometry.attributes.position.needsUpdate = true;
                    
                    // â­ è¿‡æ¸¡é˜¶æ®µï¼ˆå¤§ â†’ å°ï¼Œè¿ç»­ç¼©æ”¾ï¼‰- æ§åˆ¶size
                    const sizes = geometry.attributes.size.array;
                    const baseSizes = geometry.attributes.baseSize.array;
                    const starSizes = geometry.attributes.starSize.array;
                    
                    const scale = THREE.MathUtils.lerp(
                        starSizes[0], // æ˜Ÿæ˜Ÿé˜¶æ®µå€ç‡
                        1.0,          // æœ€ç»ˆå€ç‡
                        eased
                    );
                    
                    for (let i = 0; i < sizes.length; i++) {
                        sizes[i] = baseSizes[i] * scale;
                    }
                    
                    geometry.attributes.size.needsUpdate = true;
                    
                    points.userData.starPhase = eased; // è®°å½•è¿‡æ¸¡è¿›åº¦
                } 
                // é˜¶æ®µ3ï¼šå®Œå…¨å½¢æˆæ ‘å½¢æ€
                else {
                    // é€šè¿‡BufferAttributeæ•°ç»„ç¡®ä¿æ‰€æœ‰ç²’å­ä½äºæœ€ç»ˆä½ç½®
                    for (let i = 0; i < positions.length; i += 3) {
                        positions[i] = targetPositions[i];
                        positions[i + 1] = targetPositions[i + 1];
                        positions[i + 2] = targetPositions[i + 2];
                    }
                    
                    geometry.attributes.position.needsUpdate = true;
                    
                    // â­ æœ€ç»ˆé˜¶æ®µï¼ˆç¨³å®šå°ç²’å­ï¼‰- æ§åˆ¶size
                    const sizes = geometry.attributes.size.array;
                    const baseSizes = geometry.attributes.baseSize.array;
                    
                    for (let i = 0; i < sizes.length; i++) {
                        sizes[i] = baseSizes[i];
                    }
                    
                    geometry.attributes.size.needsUpdate = true;
                    
                    points.userData.starPhase = 2;
                }
            });
        }
        
        /**
         * åŠ¨ç”»å¾ªç¯
         */
        function animate(params) { // åŠ¨ç”»ä¸»å¾ªç¯å‡½æ•°
            const { // è§£æ„è·å–åŠ¨ç”»å‚æ•°å¯¹è±¡ä¸­çš„æ‰€æœ‰å¿…è¦ç»„ä»¶
                scene, // 3Dåœºæ™¯
                camera, // ç›¸æœº
                renderer, // æ¸²æŸ“å™¨
                snowSystem, // é›ªèŠ±ç³»ç»Ÿ
                treeGroup, // æ ‘ç»„
                particleBatches, // ç²’å­æ‰¹æ¬¡
                coloredLightObjects, // å½©è‰²ç¯å…‰
                cameraControls, // ç›¸æœºæ§åˆ¶
                animationState // åŠ¨ç”»çŠ¶æ€
            } = params; // è§£æ„èµ‹å€¼ç»“æŸ
            
            // è·å–å½“å‰æ—¶é—´
            const time = Date.now() * 0.001; // è·å–å½“å‰æ—¶é—´ï¼ˆè½¬æ¢ä¸ºç§’ï¼‰
            
            // æ›´æ–°æ‰¹æ¬¡å¯è§æ€§
            updateBatchVisibility(particleBatches, animationState.startTime); // æ›´æ–°ç²’å­æ‰¹æ¬¡æ˜¾ç¤ºçŠ¶æ€
            updateBatchMovement(particleBatches, animationState.startTime); // æ›´æ–°ç²’å­ç§»åŠ¨åŠ¨ç”»
            
            // åº”ç”¨æ ‘çš„å€¾æ–œï¼ˆå§‹ç»ˆåº”ç”¨ï¼‰
            treeGroup.rotation.x = CONFIG.TREE.TILT_X;
            
            // åœ£è¯æ ‘æ—‹è½¬é€»è¾‘
            const now = Date.now();
            // è®¡ç®—å…³é”®æ—¶é—´ç‚¹
            const allParticlesVisibleTime = animationState.startTime + CONFIG.TREE.BATCH_INTERVAL * Math.ceil(CONFIG.TREE.PARTICLE_COUNT / CONFIG.TREE.BATCH_SIZE) + CONFIG.ANIMATION.PARTICLE_ANIMATION.ALL_PARTICLES_VISIBLE_DELAY;
            const starPhaseEndTime = allParticlesVisibleTime + CONFIG.ANIMATION.PARTICLE_ANIMATION.STAR_PHASE_DURATION;
            const transitionDuration = CONFIG.ANIMATION.PARTICLE_ANIMATION.TRANSITION_DURATION;
            const transitionEndTime = starPhaseEndTime + transitionDuration;
            
            // ä½¿ç”¨ç›‘å¬å™¨æ£€æµ‹æ ‘æ˜¯å¦å®Œå…¨æˆå‹
            const treeJustCompleted = checkTreeCompletion(particleBatches, animationState);
            
            // æ ‘æˆå‹æ£€æŸ¥å’Œé›ªèŠ±å¯åŠ¨ï¼ˆä½¿ç”¨ç›‘å¬å™¨ï¼‰
            if (!animationState.snowStarted && treeJustCompleted) {
                snowSystem.snowParticles.visible = true;
                snowSystem.snowParticles.material.opacity = 0;
                animationState.snowStarted = true;
                animationState.snowStartTime = now;
            }
            
            // åªæœ‰åœ¨è¿‡æ¸¡æ±‡èšé˜¶æ®µæ‰å¼€å§‹åŠ é€Ÿæ—‹è½¬
            if (now >= starPhaseEndTime && now < transitionEndTime) {
                treeGroup.rotation.y += CONFIG.TREE.ROTATION_SPEED * 2; // ç§»åŠ¨é˜¶æ®µåŠ é€Ÿæ—‹è½¬
                if (!animationState.isRotating) {
                    animationState.isRotating = true;
                }
            } else if (now >= transitionEndTime) {
                treeGroup.rotation.y += CONFIG.TREE.ROTATION_SPEED; // å®Œæˆåæ­£å¸¸æ—‹è½¬
            }
            
            // æ›´æ–°ç›¸æœºä½ç½®
            updateCameraPosition(camera, cameraControls);
            
            // åªæœ‰åœ¨é›ªèŠ±å¼€å§‹åæ‰æ›´æ–°é›ªèŠ±åŠ¨ç”»
            if (animationState.snowStarted) {
                // æ·»åŠ æ·¡å…¥æ•ˆæœ
                let fadeInComplete = false;
                if (animationState.snowStartTime > 0) {
                    const snowFadeInDuration = 500; // 0.5ç§’æ·¡å…¥æ—¶é—´
                    const elapsedSinceSnowStart = now - animationState.snowStartTime;
                    const fadeInProgress = THREE.MathUtils.clamp(elapsedSinceSnowStart / snowFadeInDuration, 0, 1);
                    snowSystem.snowParticles.material.opacity = fadeInProgress * 0.8;
                    fadeInComplete = fadeInProgress >= 1.0;
                }
                
                snowSystem.updateSnowAnimation(time, fadeInComplete, animationState.snowStartTime);
            }
            
            // ç¦ç”¨æ­¤å‡½æ•°ï¼Œé¿å…ç ´åsizeçš„ç¨³å®šæ€§
            // updateParticlesAnimation(particleBatches, time, animationState);
            
            // æ›´æ–°å½©è‰²è£…é¥°ç¯
            updateColoredLights(coloredLightObjects, time);
            
            // æ¸²æŸ“åœºæ™¯
            renderer.render(scene, camera); // æ¸²æŸ“å½“å‰å¸§
            
            // è¯·æ±‚ä¸‹ä¸€å¸§åŠ¨ç”»
            requestAnimationFrame(() => animate(params)); // é€’å½’è°ƒç”¨ä¸‹ä¸€å¸§åŠ¨ç”»
        } // animateå‡½æ•°ç»“æŸ
        
        /**
         * æ›´æ–°ç›¸æœºä½ç½®
         */
        function updateCameraPosition(camera, cameraControls) {
            const spherical = new THREE.Spherical();
            spherical.radius = cameraControls.distance;
            spherical.theta = cameraControls.rotationY;
            spherical.phi = cameraControls.rotationX + Math.PI / 2;
            
            camera.position.setFromSpherical(spherical);
            camera.position.add(CONFIG.CAMERA.TARGET);
            camera.lookAt(CONFIG.CAMERA.TARGET);
        }
        

        
        /**
         * æ›´æ–°ç²’å­åŠ¨ç”»
         */
        function updateParticlesAnimation(particleBatches, time, animationState) {
            // æ£€æŸ¥æ‰€æœ‰ç²’å­æ˜¯å¦å·²å®Œæˆæ˜Ÿå½¢åˆ°æ ‘å½¢æ€çš„è¿‡æ¸¡
            const allParticlesTransitioned = particleBatches.every(points => 
                points.userData.starPhase >= 2
            );
            
            if (!allParticlesTransitioned) return;
            
            // åœ¨æ‰€æœ‰ç²’å­å®Œæˆè¿‡æ¸¡åï¼Œæ·»åŠ å¾®å¦™çš„åŠ¨æ€æ•ˆæœ
            particleBatches.forEach(points => {
                const geometry = points.geometry;
                const colors = geometry.attributes.color.array;
                const sizes = geometry.attributes.size.array;
                
                // âŒ ä¸å†ä½¿ç”¨ material.size
            });
        }
        
        /**
         * æ›´æ–°å½©è‰²è£…é¥°ç¯
         */
        function updateColoredLights(coloredLightObjects, time) {
            coloredLightObjects.forEach((light, index) => {
                const lightConfig = CONFIG.LIGHTS[index];
                const baseIntensity = lightConfig.intensity;
                const flickerSpeed = lightConfig.flickerSpeed;
                
                // è®¡ç®—é—ªçƒå¼ºåº¦
                const flicker = 0.5 + Math.sin(time * flickerSpeed * Math.PI * 2) * 0.5;
                light.intensity = baseIntensity * flicker;
            });
        }
        
        /**
         * çª—å£å¤§å°è°ƒæ•´äº‹ä»¶å¤„ç†
         */
        function onWindowResize(camera, renderer) { // çª—å£å¤§å°è°ƒæ•´å¤„ç†å‡½æ•°
            camera.aspect = window.innerWidth / window.innerHeight; // æ›´æ–°ç›¸æœºå®½é«˜æ¯”
            camera.updateProjectionMatrix(); // æ›´æ–°ç›¸æœºæŠ•å½±çŸ©é˜µ
            renderer.setSize(window.innerWidth, window.innerHeight); // æ›´æ–°æ¸²æŸ“å™¨å°ºå¯¸
        } // onWindowResizeå‡½æ•°ç»“æŸ
    </script> <!-- JavaScriptä»£ç ç»“æŸ -->
</body> <!-- æ–‡æ¡£ä¸»ä½“ç»“æŸ -->
</html> <!-- HTMLæ–‡æ¡£ç»“æŸ -->

